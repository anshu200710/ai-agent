

/* =======================
   Simple voice agent no eleven labs
======================= */

import express from "express";
import twilio from "twilio";

import CallSession from "../models/CallSession.js";
import Customer from "../models/Customer.js";
import Complaint from "../models/Complaint.js";

const router = express.Router();
const VoiceResponse = twilio.twiml.VoiceResponse;

/* =======================
   FOR CLEAN PRONOUN SAVE
======================= */

function cleanSpeech(text) {
  if (!text) return "";

  return text
    .replace(/[à¥¤]/g, "") // remove Hindi full stop
    .replace(/[.,!?]/g, "") // remove English punctuation
    .trim()
    .toLowerCase();
}

/* =======================
   CONSTANTS
======================= */
const YES_WORDS = ["haan", "haanji", "yes", "ji", "bilkul", "sahi"];
const TRANSFER_KEYWORDS = ["agent", "human", "representative"];

const CONFUSION_WORDS = [
  "kya",
  "what",
  "repeat",
  "dobara",
  "samajh",
  "samajh nahi",
  "clear nahi",
  "pardon",
  "haan kya",
  "matlab",
];

/* =======================
   HELPER: ASK & LISTEN
======================= */
function ask(twiml, text, call) {
  if (call) {
    call.temp.lastQuestion = text;
  }

  const gather = twiml.gather({
    input: "speech",
    language: "hi-IN",
    speechTimeout: "auto",
    timeout: 6,
    action: "/voice/process",
    method: "POST",
  });

  // gather.say(text);

  gather.say(
    {
      voice: "Polly.Aditi",
      language: "hi-IN",
    },
    text,
  );
}

/* =======================
   INCOMING CALL
======================= */
router.post("/", async (req, res) => {
  const { CallSid, From } = req.body;
  const twiml = new VoiceResponse();

  await CallSession.findOneAndUpdate(
    { callSid: CallSid },
    {
      callSid: CallSid,
      from: From,
      step: "ask_chassis",
      temp: { retries: 0 },
    },
    { upsert: true, new: true },
  );

  const call = await CallSession.findOne({ callSid: CallSid });

  ask(
    twiml,
    "Namaskar. Main Rajesh Motors JCB se bol rahi hoon. Kripya apni machine ka chassis number boliye.",
    call,
  );

  res.type("text/xml").send(twiml.toString());
});

/* =======================
   PROCESS CALL
======================= */
router.post("/process", async (req, res) => {
  const twiml = new VoiceResponse();
  const { CallSid, SpeechResult } = req.body;
  const rawSpeech = SpeechResult || "";
  const speech = cleanSpeech(rawSpeech);
  // const speech = (SpeechResult || "").trim().toLowerCase();

  const call = await CallSession.findOne({ callSid: CallSid });

  if (!call || !speech) {
    ask(twiml, "Awaaz clear nahi aayi. Kripya dobara boliye.", call);
    return res.type("text/xml").send(twiml.toString());
  }

  /* ðŸ” Transfer to Human */
  if (TRANSFER_KEYWORDS.some((w) => speech.includes(w))) {
    twiml.say(
      "Theek hai. Aapko customer care agent se connect kiya ja raha hai.",
    );
    twiml.dial(process.env.HUMAN_AGENT_NUMBER);
    return res.type("text/xml").send(twiml.toString());
  }

  /* ðŸ¤” Confusion Handling */
  if (
    CONFUSION_WORDS.some((w) => speech.includes(w)) &&
    call.temp?.lastQuestion
  ) {
    call.temp.retries += 1;

    if (call.temp.retries > 3) {
      twiml.say("Main aapko agent se connect kar raha hoon.");
      twiml.dial(process.env.HUMAN_AGENT_NUMBER);
      return res.type("text/xml").send(twiml.toString());
    }

    ask(twiml, call.temp.lastQuestion, call);
    await call.save();
    return res.type("text/xml").send(twiml.toString());
  }

  call.temp.retries = 0;

  /* =======================
     STATE MACHINE
  ======================= */
  switch (call.step) {
    /* ---------- ASK CHASSIS ---------- */
    case "ask_chassis": {
      if (speech.length < 4) {
        ask(
          twiml,
          "Chassis number clear nahi mila. Kripya dheere aur saaf boliye.",
          call,
        );
        break;
      }

      call.temp.chassisNo = speech;
      const customer = await Customer.findOne({ chassisNo: speech });

      if (customer) {
        call.temp.customerId = customer._id;
        call.temp.name = customer.name;
        call.temp.phone = customer.phone;
        call.temp.city = customer.city;
        call.step = "ask_complaint";

        ask(
          twiml,
          `Dhanyavaad. Record mil gaya hai. Aap ${customer.name} ${customer.city} se bol rahe hain.
           Ab kripya apni problem batayein.`,
          call,
        );
      } else {
        call.step = "repeat_chassis";
        ask(
          twiml,
          "Record nahi mila. Kripya chassis number dobara boliye.",
          call,
        );
      }

      break;
    }

    /* ---------- REPEAT CHASSIS ---------- */
    case "repeat_chassis": {
      if (speech.length < 4) {
        ask(
          twiml,
          "Chassis number clear nahi mila. Kripya dobara boliye.",
          call,
        );
        break;
      }

      call.temp.chassisNo = speech;
      const customer = await Customer.findOne({ chassisNo: speech });

      if (customer) {
        call.temp.customerId = customer._id;
        call.temp.name = customer.name;
        call.temp.phone = customer.phone;
        call.temp.city = customer.city;
        call.step = "ask_complaint";

        ask(twiml, "Record mil gaya hai. Kripya apni problem batayein.", call);
      } else {
        call.step = "ask_name";
        ask(twiml, "Record nahi mila. Kripya apna poora naam boliye.", call);
      }
      break;
    }

    /* ---------- ASK NAME ---------- */
    case "ask_name":
      call.temp.name = speech;
      call.step = "ask_phone";
      ask(
        twiml,
        "Dhanyavaad. Ab kripya apna 10 digit mobile number boliye.",
        call,
      );
      break;

    /* ---------- ASK PHONE ---------- */
    case "ask_phone": {
      call.temp.phone = speech.replace(/\D/g, "");

      if (call.temp.phone.length !== 10) {
        ask(
          twiml,
          "Mobile number sahi nahi lag raha. Kripya sirf 10 digit number boliye.",
          call,
        );
        break;
      }

      const customer = await Customer.findOne({ phone: call.temp.phone });

      if (customer) {
        call.temp.customerId = customer._id;
        call.temp.city = customer.city;
        call.step = "confirm_customer";

        ask(
          twiml,
          `Aap ${customer.name} se bol rahe hain. Kya ye sahi hai? yes ya no boliye.`,
          call,
        );
      } else {
        call.step = "ask_city";
        ask(twiml, "Kripya apne sheher ka naam boliye.", call);
      }
      break;
    }

    /* ---------- CONFIRM CUSTOMER ---------- */
    case "confirm_customer":
      if (YES_WORDS.some((w) => speech.includes(w))) {
        call.step = "ask_complaint";
        ask(twiml, "Ab kripya apni machine ki problem batayein.", call);
      } else {
        call.step = "ask_city";
        ask(twiml, "Theek hai. Kripya apne sheher ka naam boliye.", call);
      }
      break;

    /* ---------- ASK CITY ---------- */
    case "ask_city":
      call.temp.city = speech;
      call.step = "ask_complaint";
      ask(twiml, "Dhanyavaad. Ab kripya apni problem batayein.", call);
      break;

    /* ---------- COMPLAINT ---------- */
    case "ask_complaint": {
      call.temp.complaint = speech;
      call.step = "done";

      const customer = call.temp.customerId
        ? await Customer.findById(call.temp.customerId)
        : await Customer.create({
            chassisNo: call.temp.chassisNo,
            name: call.temp.name,
            phone: call.temp.phone,
            city: call.temp.city,
          });

      await Complaint.create({
        customerId: customer._id,
        chassisNo: call.temp.chassisNo,
        phone: call.temp.phone,
        description: call.temp.complaint,
        callSid: CallSid,
        status: "open",
      });

      twiml.say(
        "Dhanyavaad. Aapki complaint register ho chuki hai. Hamari service team jald hi aapse sampark karegi.",
      );
      twiml.hangup();
      break;
    }
  }

  await call.save();
  res.type("text/xml").send(twiml.toString());
});

export default router;



















/* =======================
   Even Labs added for clear voice
======================= */

import express from "express";
import twilio from "twilio";

import CallSession from "../models/CallSession.js";
import Customer from "../models/Customer.js";
import Complaint from "../models/Complaint.js";

import { generateSpeech } from "../services/elevenlabsTTS.js";

const router = express.Router();
const VoiceResponse = twilio.twiml.VoiceResponse;

/* =======================
   CLEAN SPEECH
======================= */
function cleanSpeech(text) {
  if (!text) return "";
  return text
    .replace(/[à¥¤]/g, "")
    .replace(/[.,!?]/g, "")
    .trim()
    .toLowerCase();
}

/* =======================
   CONSTANTS
======================= */
const YES_WORDS = ["haan", "haanji", "yes", "ji", "bilkul", "sahi"];
const TRANSFER_KEYWORDS = ["agent", "human", "representative"];

const CONFUSION_WORDS = [
  "kya",
  "what",
  "repeat",
  "dobara",
  "samajh",
  "samajh nahi",
  "clear nahi",
  "pardon",
  "haan kya",
  "matlab",
];

const TRANSFER_WORDS = [
  "transfer",
  "call transfer",
  "agent",
  "human",
  "representative",
  "baat karni",
  "human se",
  "agent se",
];

/* =======================
   ASK + LISTEN (ElevenLabs)
======================= */
async function ask(twiml, text, call) {
  if (call) call.temp.lastQuestion = text;

  const gather = twiml.gather({
    input: "speech",
    language: "hi-IN",
    speechTimeout: "auto",
    timeout: 6,
    action: "/voice/process",
    method: "POST",
  });

  try {
    const audioUrl = await generateSpeech(text, `tts_${Date.now()}.mp3`);
    gather.play(audioUrl);
  } catch (err) {
    console.error("ElevenLabs failed, fallback to Polly:", err.message);
    gather.say({ voice: "Polly.Aditi", language: "hi-IN" }, text);
  }
}

/* =======================
   INCOMING CALL
======================= */
router.post("/", async (req, res) => {
  const { CallSid, From } = req.body;
  const twiml = new VoiceResponse();

  await CallSession.findOneAndUpdate(
    { callSid: CallSid },
    {
      callSid: CallSid,
      from: From,
      step: "ask_chassis",
      temp: { retries: 0 },
    },
    { upsert: true, new: true },
  );

  const call = await CallSession.findOne({ callSid: CallSid });

  await ask(
    twiml,
    "Namaskar. Main Rajesh Motors JCB se bol raha hoon. Kripya apni machine ka chassis number boliye.",
    call,
  );

  res.type("text/xml").send(twiml.toString());
});

/* =======================
   PROCESS CALL
======================= */
router.post("/process", async (req, res) => {
  const twiml = new VoiceResponse();
  const { CallSid, SpeechResult } = req.body;
  const speech = cleanSpeech(SpeechResult || "");

  const call = await CallSession.findOne({ callSid: CallSid });

  if (!call || !speech) {
    await ask(twiml, "Awaaz clear nahi aayi. Kripya dobara boliye.", call);
    return res.type("text/xml").send(twiml.toString());
  }

  /* ðŸ” Transfer to Human */
  if (TRANSFER_KEYWORDS.some((w) => speech.includes(w))) {
    // twiml.say(
    //   "Theek hai. Aapko customer care agent se connect kiya ja raha hai.",
    // );
    // twiml.dial(process.env.HUMAN_AGENT_NUMBER);
    await ask(
      twiml,
      "Theek hai. Aapko customer care agent se connect kiya ja raha hai.",
      call,
    );
    twiml.dial(process.env.HUMAN_AGENT_NUMBER);
    return res.type("text/xml").send(twiml.toString());
  }

  /* ðŸ¤” Confusion Handling */
  if (
    CONFUSION_WORDS.some((w) => speech.includes(w)) &&
    call.temp?.lastQuestion
  ) {
    call.temp.retries += 1;

    if (call.temp.retries > 3) {
      twiml.say("Main aapko agent se connect kar raha hoon.");
      twiml.dial(process.env.HUMAN_AGENT_NUMBER);
      return res.type("text/xml").send(twiml.toString());
    }

    await ask(twiml, call.temp.lastQuestion, call);
    await call.save();
    return res.type("text/xml").send(twiml.toString());
  }

  call.temp.retries = 0;

  /* =======================
     STATE MACHINE
  ======================= */
  switch (call.step) {
    case "ask_chassis": {
      if (speech.length < 4) {
        await ask(
          twiml,
          "Chassis number clear nahi mila. Kripya dheere boliye.",
          call,
        );
        break;
      }

      call.temp.chassisNo = speech;
      const customer = await Customer.findOne({ chassisNo: speech });

      if (customer) {
        call.temp.customerId = customer._id;
        call.temp.name = customer.name;
        call.temp.phone = customer.phone;
        call.temp.city = customer.city;
        call.step = "ask_complaint";

        await ask(
          twiml,
          `Dhanyavaad. Aap ${customer.name}, ${customer.city} se bol rahe hain. Ab apni problem batayein.`,
          call,
        );
      } else {
        call.step = "unregistered_options";
        await ask(
          twiml,
          "Aap pehle se registered nahi lag rahe hain. Ya toh sahi chassis number boliye, ya kya main aapki call human agent ko transfer kar doon?",
          call,
        );
      }
      break;
    }

    case "unregistered_options": {
      // If user wants human
      if (TRANSFER_WORDS.some((w) => speech.includes(w))) {
        await ask(
          twiml,
          "Theek hai. Main aapko customer care agent se connect kar raha hoon.",
          call,
        );
        twiml.dial(process.env.HUMAN_AGENT_NUMBER);
        return res.type("text/xml").send(twiml.toString());
      }

      // If user tries chassis again
      if (speech.length >= 4) {
        call.temp.chassisNo = speech;
        const customer = await Customer.findOne({ chassisNo: speech });

        if (customer) {
          call.temp.customerId = customer._id;
          call.temp.name = customer.name;
          call.temp.phone = customer.phone;
          call.temp.city = customer.city;
          call.step = "ask_complaint";

          await ask(
            twiml,
            `Dhanyavaad. Aap ${customer.name}, ${customer.city} se bol rahe hain. Ab apni problem batayein.`,
            call,
          );
        } else {
          call.step = "ask_name";
          await ask(
            twiml,
            "Chassis number phir bhi nahi mila. Kripya apna poora naam boliye.",
            call,
          );
        }
        break;
      }

      // If unclear response
      await ask(
        twiml,
        "Kripya sahi chassis number boliye ya human agent ke liye boliye.",
        call,
      );
      break;
    }

    case "repeat_chassis": {
      call.temp.chassisNo = speech;
      call.step = "ask_name";
      await ask(twiml, "Kripya apna poora naam boliye.", call);
      break;
    }

    case "ask_name":
      call.temp.name = speech;
      call.step = "ask_phone";
      await ask(twiml, "Ab apna 10 digit mobile number boliye.", call);
      break;

    case "ask_phone": {
      call.temp.phone = speech.replace(/\D/g, "");
      if (call.temp.phone.length !== 10) {
        await ask(
          twiml,
          "Mobile number galat lag raha hai. Dobara boliye.",
          call,
        );
        break;
      }

      call.step = "ask_city";
      await ask(twiml, "Kripya apne sheher ka naam boliye.", call);
      break;
    }

    case "ask_city":
      call.temp.city = speech;
      call.step = "ask_complaint";
      await ask(twiml, "Ab kripya apni machine ki problem batayein.", call);
      break;

    case "ask_complaint": {
      call.temp.complaint = speech;
      call.step = "done";

      // const customer = await Customer.create({
      //   chassisNo: call.temp.chassisNo,
      //   name: call.temp.name,
      //   phone: call.temp.phone,
      //   city: call.temp.city,
      // });

      const customer = await Customer.findOneAndUpdate(
        { chassisNo: call.temp.chassisNo },
        {
          $set: {
            name: call.temp.name,
            phone: call.temp.phone,
            city: call.temp.city,
          },
        },
        { upsert: true, new: true },
      );

      await Complaint.create({
        customerId: customer._id,
        chassisNo: call.temp.chassisNo,
        phone: call.temp.phone,
        description: call.temp.complaint,
        callSid: CallSid,
        status: "open",
      });

      await ask(
        twiml,
        "Dhanyavaad. Aapki complaint register ho chuki hai. Hamari team jald sampark karegi.",
        call,
      );
      twiml.hangup();
      break;
    }
  }

  await call.save();
  res.type("text/xml").send(twiml.toString());
});

export default router;

/* =======================
 Db configure properly voice call agent
======================= */

import express from "express";
import twilio from "twilio";

import CallSession from "../models/CallSession.js";
import Customer from "../models/Customer.js";
import Complaint from "../models/Complaint.js";

const router = express.Router();
const VoiceResponse = twilio.twiml.VoiceResponse;

/* =======================
   CLEAN SPEECH
======================= */
function cleanSpeech(text) {
  if (!text) return "";
  return text.replace(/[à¥¤.,!?]/g, "").trim().toLowerCase();
}

/* =======================
   CONSTANTS
======================= */
const TRANSFER_KEYWORDS = ["agent", "human", "representative"];
const CONFUSION_WORDS = [
  "kya",
  "repeat",
  "dobara",
  "samajh",
  "samajh nahi",
  "clear nahi",
  "pardon",
];

/* =======================
   ASK + LISTEN
======================= */
function ask(twiml, text, call) {
  call.temp.lastQuestion = text;

  const gather = twiml.gather({
    input: "speech",
    language: "hi-IN",
    speechTimeout: "auto",
    timeout: 6,
    action: "/voice/process",
    method: "POST",
  });

  gather.say({ voice: "Polly.Aditi", language: "hi-IN" }, text);
}

/* =======================
   INCOMING CALL
======================= */
router.post("/", async (req, res) => {
  const { CallSid, From } = req.body;
  const twiml = new VoiceResponse();

  await CallSession.findOneAndUpdate(
    { callSid: CallSid },
    {
      callSid: CallSid,
      from: From,
      step: "ask_identifier",
      temp: { retries: 0 },
    },
    { upsert: true, new: true }
  );

  const call = await CallSession.findOne({ callSid: CallSid });

  ask(
    twiml,
    "Namaskar. Kripya apni machine ka chassis number ya apna registered mobile number boliye.",
    call
  );

  res.type("text/xml").send(twiml.toString());
});

/* =======================
   PROCESS CALL
======================= */
router.post("/process", async (req, res) => {
  const twiml = new VoiceResponse();
  const { CallSid, SpeechResult } = req.body;

  const speech = cleanSpeech(SpeechResult || "");
  const call = await CallSession.findOne({ callSid: CallSid });

  if (!call || !speech) {
    ask(twiml, "Awaaz clear nahi aayi. Kripya dobara boliye.", call);
    return res.type("text/xml").send(twiml.toString());
  }

  /* ðŸ” MANUAL TRANSFER */
  if (TRANSFER_KEYWORDS.some((w) => speech.includes(w))) {
    twiml.say("Aapko agent se connect kiya ja raha hai.");
    twiml.dial(process.env.HUMAN_AGENT_NUMBER);
    return res.type("text/xml").send(twiml.toString());
  }

  /* ðŸ¤” CONFUSION HANDLING */
  if (CONFUSION_WORDS.some((w) => speech.includes(w))) {
    call.temp.retries += 1;

    if (call.temp.retries > 2) {
      twiml.say("Aapko agent se connect kiya ja raha hai.");
      twiml.dial(process.env.HUMAN_AGENT_NUMBER);
      return res.type("text/xml").send(twiml.toString());
    }

    ask(twiml, call.temp.lastQuestion, call);
    await call.save();
    return res.type("text/xml").send(twiml.toString());
  }

  call.temp.retries = 0;

  /* =======================
     STATE MACHINE
  ======================= */
  switch (call.step) {
    /* ---------- IDENTIFIER ---------- */
    case "ask_identifier": {
      const digits = speech.replace(/\D/g, "");
      let customer = null;

      if (digits.length === 10) {
        customer = await Customer.findOne({ phone: digits });
      }

      if (!customer) {
        customer = await Customer.findOne({ chassisNo: speech });
      }

      if (!customer) {
        call.temp.retries += 1;

        if (call.temp.retries > 2) {
          twiml.say("Record nahi mila. Aapko agent se connect kiya ja raha hai.");
          twiml.dial(process.env.HUMAN_AGENT_NUMBER);
          return res.type("text/xml").send(twiml.toString());
        }

        ask(
          twiml,
          "Record nahi mila. Kripya chassis number ya registered mobile number dobara boliye.",
          call
        );
        break;
      }

      call.temp.customerId = customer._id;
      call.step = "ask_complaint";

      ask(
        twiml,
        `Aapka record mil gaya hai. Aap ${customer.city} se ${customer.name} baat kar rahe hain. Kripya apni problem batayein.`,
        call
      );
      break;
    }

    /* ---------- COMPLAINT ---------- */
    case "ask_complaint": {
      const customer = await Customer.findById(call.temp.customerId);

      await Complaint.create({
        customerId: customer._id,
        chassisNo: customer.chassisNo,
        phone: customer.phone,
        name: customer.name,
        city: customer.city,
        machineModel: customer.machineModel,
        warrantyStatus: customer.warrantyStatus,
        description: speech,
        callSid: CallSid,
      });

      twiml.say(
        "Dhanyavaad. Aapki complaint register ho chuki hai. Hamari service team jald hi aapse sampark karegi."
      );
      twiml.hangup();
      break;
    }
  }

  await call.save();
  res.type("text/xml").send(twiml.toString());
});

export default router;













/* ==========================
======= data perfect ly saved
============================== */

// import express from "express";
// import twilio from "twilio";

// import CallSession from "../models/CallSession.js";
// import Customer from "../models/Customer.js";
// import Complaint from "../models/Complaint.js";
// import complaintMap from "../utils/complaintClassifier.js";

// const router = express.Router();
// const VoiceResponse = twilio.twiml.VoiceResponse;

// /* =======================
//    CLEAN SPEECH
// ======================= */
// function cleanSpeech(text) {
//   if (!text) return "";
//   return text
//     .toLowerCase()
//     .replace(/[à¥¤.,!?]/g, "")
//     .replace(/\s+/g, " ")
//     .trim();
// }

// function normalizeText(text) {
//   if (!text) return "";
//   return text.toLowerCase().replace(/\s+/g, " ").trim();
// }

// /* =======================
//    HINDI â†’ ENGLISH NORMALISER
//    Twilio hi-IN STT returns Devanagari script.
//    Every keyword used in detectComplaintIntent() AND in followUpQuestions options
//    MUST have its Devanagari form mapped here â€” otherwise includes() will never
//    match and the caller silently gets "Other".
//    Keys are sorted longest-first at runtime so multi-word phrases match before
//    their own substrings (e.g. "à¤•à¤¾à¤® à¤¨à¤¹à¥€à¤‚ à¤•à¤° à¤°à¤¹à¥€" before "à¤•à¤¾à¤® à¤¨à¤¹à¥€à¤‚").
// ======================= */
// const hindiToEnglishMap = {
//   // â”€â”€â”€ top-level complaint categories â”€â”€â”€
//   "à¤Ÿà¤¾à¤¯à¤°": "tyre",
//   "à¤Ÿà¤¾à¤¯à¤° à¤¨à¤¹à¥€à¤‚": "tyre",
//   "à¤à¤¸à¥€": "ac",
//   "à¤.à¤¸à¥€": "ac",
//   "à¤‡à¤‚à¤œà¤¨": "engine",
//   "à¤¹à¤¾à¤‡à¤¡à¥à¤°à¥‹à¤²à¤¿à¤•": "hydraulic",
//   "à¤¬à¤¿à¤œà¤²à¥€": "electrical",
//   "à¤‡à¤²à¥‡à¤•à¥à¤Ÿà¥à¤°à¤¿à¤•à¤²": "electrical",
//   "à¤¬à¥ˆà¤Ÿà¤°à¥€": "battery",

//   // â”€â”€â”€ generic intent words â”€â”€â”€
//   "à¤¨à¥‰à¤Ÿ à¤µà¤°à¥à¤•à¤¿à¤‚à¤—": "not working",
//   "à¤µà¤°à¥à¤• à¤¨à¤¹à¥€à¤‚": "not working",
//   "à¤•à¤¾à¤® à¤¨à¤¹à¥€à¤‚ à¤•à¤° à¤°à¤¹à¤¾ à¤¹à¥ˆ": "not working",
//   "à¤•à¤¾à¤® à¤¨à¤¹à¥€à¤‚ à¤•à¤° à¤°à¤¹à¥€ à¤¹à¥ˆ": "not working",
//   "à¤•à¤¾à¤® à¤¨à¤¹à¥€à¤‚ à¤•à¤° à¤°à¤¹à¤¾": "not working",
//   "à¤•à¤¾à¤® à¤¨à¤¹à¥€à¤‚ à¤•à¤° à¤°à¤¹à¥€": "not working",
//   "à¤•à¤¾à¤® à¤¨à¤¹à¥€à¤‚": "not working",
//   "à¤ à¤‚à¤¡à¤¾ à¤¨à¤¹à¥€à¤‚": "cooling",
//   "à¤ à¤‚à¤¡à¥€ à¤¨à¤¹à¥€à¤‚": "cooling",
//   "à¤ à¤‚à¤¡à¤¾": "cooling",
//   "à¤ à¤‚à¤¡à¥€": "cooling",

//   // â”€â”€â”€ AC sub-complaint keywords â”€â”€â”€
//   "à¤•à¥‚à¤²à¤¿à¤‚à¤—": "cooling",
//   "à¤¬à¤‚à¤¦": "band",

//   // â”€â”€â”€ Engine sub-complaint keywords â”€â”€â”€
//   "à¤¸à¥à¤®à¥‹à¤•": "smoke",
//   "à¤§à¥à¤†": "dhua",
//   "à¤§à¥à¤¯à¥‚à¤†": "dhua",
//   "à¤¨à¤¾à¤‡à¤¸": "noise",
//   "à¤¨à¥‰à¤‡à¤œà¤¼": "noise",
//   "à¤¨à¥‰à¤‡à¤œ": "noise",
//   "à¤†à¤µà¤¾à¤œà¤¼": "awaz",
//   "à¤†à¤µà¤¾à¤œ": "awaz",
//   "à¤—à¤°à¤®": "garam",
//   "à¤“à¤µà¤°à¤¹à¥€à¤Ÿ": "overheat",
//   "à¤¸à¥à¤Ÿà¤¾à¤°à¥à¤Ÿ à¤¨à¤¹à¥€à¤‚": "start",
//   "à¤¸à¥à¤Ÿà¤¾à¤°à¥à¤Ÿ": "start",
//   "à¤®à¤¿à¤¸à¤¿à¤‚à¤—": "missing",
//   "à¤¹à¥€à¤Ÿ": "heat",

//   // â”€â”€â”€ Hydraulic sub-complaint keywords â”€â”€â”€
//   "à¤ªà¥à¤°à¥‡à¤¶à¤°": "pressure",
//   "à¤²à¥€à¤•": "leak",
//   "à¤²à¥€à¤•à¥‡à¤œ": "leak",
//   "à¤¸à¥à¤²à¥‹": "slow",
//   "à¤§à¥€à¤°à¥‡": "dheere",
//   "à¤•à¤®": "kam",

//   // â”€â”€â”€ Electrical sub-complaint keywords â”€â”€â”€
//   "à¤¸à¥à¤Ÿà¤¾à¤°à¥à¤Ÿà¤°": "starter",
//   "à¤¸à¥‡à¤²à¥à¤«": "self",
//   "à¤µà¤¾à¤¯à¤°à¤¿à¤‚à¤—": "wiring",
//   "à¤²à¤¾à¤‡à¤Ÿ": "light",
//   "à¤†à¤°à¤ªà¥€à¤à¤®": "rpm",
//   "à¤®à¥€à¤Ÿà¤°": "meter",

//   // â”€â”€â”€ Tyre sub-complaint keywords â”€â”€â”€
//   "à¤ªà¤‚à¤•à¥à¤šà¤°": "puncture",
//   "à¤«à¤Ÿà¤¾ à¤—à¤¯à¤¾": "phatta",
//   "à¤«à¤Ÿà¥‡ à¤—à¤": "phatta",
//   "à¤«à¤Ÿ à¤—à¤¯à¤¾": "phatta",
//   "à¤«à¤Ÿà¤¾": "phatta",
//   "à¤«à¤Ÿà¥‡": "phatta",
//   "à¤«à¤Ÿ": "phatta",
//   "à¤•à¤Ÿ à¤—à¤¯à¤¾": "cut",
//   "à¤•à¤Ÿ": "cut",
//   "à¤¡à¥‡à¤¡": "dead",

//   // â”€â”€â”€ Transmission sub-complaint keywords â”€â”€â”€
//   "à¤—à¤¿à¤¯à¤°": "gear",
//   "à¤—à¤¿à¤¯à¤¼à¤¾à¤°": "gear",
//   "à¤¬à¥à¤°à¥‡à¤•": "brake",
//   "à¤°à¤¿à¤µà¤°à¥à¤¸": "reverse",

//   // â”€â”€â”€ Ram/Cylinder sub-complaint keywords â”€â”€â”€
//   "à¤°à¥‰à¤¡": "rod",
//   "à¤°à¥ˆà¤®": "ram",
//   "à¤¸à¥€à¤²": "seal",
//   "à¤¬à¥‡à¤‚à¤¡": "bend",
//   "à¤Ÿà¥‚à¤Ÿà¤¾ à¤—à¤¯à¤¾": "toot",
//   "à¤Ÿà¥‚à¤Ÿà¤¾": "toot",
//   "à¤Ÿà¥‚à¤Ÿà¥‡": "toot",

//   // â”€â”€â”€ Hose sub-complaint keywords â”€â”€â”€
//   "à¤¹à¥‹à¤¸": "hose",
//   "à¤ªà¤¾à¤‡à¤ª": "pipe",
//   "à¤“ à¤°à¤¿à¤‚à¤—": "o ring",

//   // â”€â”€â”€ Under Carriage sub-complaint keywords â”€â”€â”€
//   "à¤Ÿà¥à¤°à¥ˆà¤•": "track",
//   "à¤°à¥‹à¤²à¤°": "roller",
//   "à¤†à¤‡à¤¡à¤²à¤°": "idler",
//   "à¤†à¤‡à¤¡à¤²à¥‡à¤°": "idler",
//   "à¤¸à¥à¤ªà¥à¤°à¥‰à¤•à¥‡à¤Ÿ": "sprocket",
// };

// // pre-sort keys longest-first so multi-word phrases match before substrings
// const sortedHindiKeys = Object.keys(hindiToEnglishMap).sort(
//   (a, b) => b.length - a.length
// );

// function normalizeHindiIntent(text) {
//   if (!text) return "";
//   let normalized = text;
//   for (const hindi of sortedHindiKeys) {
//     if (normalized.includes(hindi)) {
//       normalized += " " + hindiToEnglishMap[hindi];
//     }
//   }
//   return normalized;
// }

// /* =======================
//    FOLLOW UP QUESTIONS
//    Contextual sub-complaint prompts asked AFTER a complaint category is detected.
//    â€¢ question  â†’ what the IVR says
//    â€¢ options   â†’ keyword â†’ sub-complaint title (partial match via includes())
// ======================= */
// const followUpQuestions = {
//   "AC System": {
//     question:
//       "AC cooling nahi kar rahi hai ya bilkul kaam nahi kar rahi hai? Cooling hai ya band hai?",
//     options: {
//       cooling: "AC not Cooling",
//       thanda: "AC not Cooling",
//       "nahi kar rahi": "AC not Cooling",
//       band: "AC not Working",
//       "not working": "AC not Working",
//       kaam: "AC not Working",
//     },
//   },

//   Engine: {
//     question:
//       "Engine mein kya dikkat hai? Overheating hai, smoke aa raha hai, noise hai ya start mein problem hai?",
//     options: {
//       overheat: "Engine Over heating",
//       garam: "Engine Over heating",
//       heat: "Engine Over heating",
//       smoke: "Smoke problem",
//       dhua: "Smoke problem",
//       noise: "Abnormal Noise",
//       awaz: "Abnormal Noise",
//       start: "Missing problem",
//       missing: "Missing problem",
//     },
//   },

//   Hydraulic: {
//     question:
//       "Hydraulic mein kya problem hai? Pressure kam hai, leak hai ya machine slow chal rahi hai?",
//     options: {
//       pressure: "Pressure down",
//       kam: "Pressure down",
//       leak: "Hydraulic pump leak",
//       slow: "Machine performance low/Slow working",
//       dheere: "Machine performance low/Slow working",
//     },
//   },

//   "Electrical Complaint": {
//     question:
//       "Electrical mein kya dikkat hai? Battery hai, self starter hai, wiring hai ya light mein problem hai?",
//     options: {
//       battery: "Battery problem",
//       starter: "Self/Starter motor problem",
//       self: "Self/Starter motor problem",
//       wiring: "Wiring problem",
//       light: "Light not working",
//       rpm: "speed/rpm meter not working",
//       meter: "speed/rpm meter not working",
//     },
//   },

//   "Tyre/Battery": {
//     question:
//       "Tyre mein kya problem hai? Phatta gaya hai, puncture hai ya cut hai?",
//     options: {
//       puncture: "Tyre puncture",
//       phatta: "Tyre puncture",
//       burst: "Tyre puncture",
//       cut: "Tyre cut",
//       battery: "Battery problem",
//       dead: "Battery problem",
//     },
//   },

//   "Transmission/Axle components": {
//     question:
//       "Transmission mein kya problem hai? Gear hai, brake hai ya reverse mein dikkat hai?",
//     options: {
//       gear: "Gear box problem",
//       gearbox: "Gear box problem",
//       brake: "Brake problem",
//       reverse: "Reverse forward issue",
//     },
//   },

//   "Ram/Cylinder": {
//     question:
//       "Ram ya cylinder mein kya problem hai? Leak hai, rod bend hai ya rod toot gaya hai?",
//     options: {
//       leak: "Ram leak",
//       bend: "Rod bend",
//       toot: "Rod broken",
//       broken: "Rod broken",
//       seal: "Seal leak",
//     },
//   },

//   Hose: {
//     question:
//       "Hose mein kya problem hai? Cut hai, leak hai ya O-ring mein dikkat hai?",
//     options: {
//       cut: "Hose cut",
//       leak: "Hose leakages",
//       "o ring": "Hose O ring Cut",
//       oring: "Hose O ring Cut",
//     },
//   },

//   "Under Carriage": {
//     question:
//       "Under carriage mein kya problem hai? Track hai, roller hai ya idler mein dikkat hai?",
//     options: {
//       track: "Track Motor leak",
//       roller: "Roller leakage",
//       idler: "Idler wheel noise",
//     },
//   },
// };

// /* =======================
//     HINDI NUMBER MAP
// ======================= */
// const hindiNumberMap = {
//   shunya: "0",
//   zero: "0",
//   ek: "1",
//   do: "2",
//   teen: "3",
//   char: "4",
//   chaar: "4",
//   paanch: "5",
//   panch: "5",
//   chhe: "6",
//   che: "6",
//   saat: "7",
//   aath: "8",
//   nau: "9",
// };

// function wordsToDigits(text) {
//   if (!text) return "";
//   let result = "";
//   text.split(" ").forEach((word) => {
//     if (hindiNumberMap[word]) {
//       result += hindiNumberMap[word];
//     }
//   });
//   return result;
// }

// /* =======================
//     CONFUSION DETECTION
// ======================= */
// function isConfusedSpeech(text) {
//   if (!text) return false;
//   const confusionWords = [
//     "kya",
//     "repeat",
//     "dobara",
//     "samajh nahi aaya",
//     "samajh nahi",
//     "fir se",
//   ];
//   return confusionWords.some((word) => text.includes(word));
// }

// /* =======================
//   COMPLAINT INTENT DETECTOR
//   Returns { primary, secondary[], confidence } or null.
//     confidence 0.95 â†’ single unambiguous match  â†’ skip confirmation
//     confidence 0.60 â†’ multiple possible matches â†’ ask confirmation first
// ======================= */
// function detectComplaintIntent(text) {
//   if (!text) return null;

//   const matches = [];
//   const words = text.split(" ");

//   // keywords too short / too common to be valid category-level signals
//   const SKIP_KEYWORDS = ["ek", "not working", "band"];

//   for (const [title, data] of Object.entries(complaintMap)) {
//     for (const keyword of data.keywords) {
//       if (SKIP_KEYWORDS.includes(keyword)) continue;

//       if (
//         text.includes(keyword) ||
//         words.some(
//           (w) =>
//             w.length > 2 &&
//             (keyword.includes(w) || w.includes(keyword))
//         )
//       ) {
//         matches.push(title);
//         break; // one match per category is enough
//       }
//     }
//   }

//   if (matches.length === 0) return null;

//   return {
//     primary: matches[0],
//     secondary: matches.slice(1),
//     confidence: matches.length === 1 ? 0.95 : 0.6,
//   };
// }

// /* =======================
//    ASK WITH GATHER  (enforces single gather per TwiML response)
// ======================= */
// function ask(twiml, text, call) {
//   call.temp.lastQuestion = text;

//   const gather = twiml.gather({
//     input: "speech",
//     language: "hi-IN",
//     speechTimeout: "auto",
//     timeout: 6,
//     actionOnEmptyResult: true,
//     action: "/voice/process",
//     method: "POST",
//   });

//   gather.say({ voice: "Polly.Aditi", language: "hi-IN" }, text);
// }

// /* =======================
//    INCOMING CALL  â€”  POST /voice/
// ======================= */
// router.post("/", async (req, res) => {
//   const { CallSid, From } = req.body;
//   const twiml = new VoiceResponse();

//   await CallSession.findOneAndUpdate(
//     { callSid: CallSid },
//     {
//       callSid: CallSid,
//       from: From,
//       step: "ivr_menu",
//       temp: { retries: 0 },
//     },
//     { upsert: true, new: true }
//   );

//   const gather = twiml.gather({
//     input: "dtmf",
//     numDigits: 1,
//     timeout: 5,
//     action: "/voice/process",
//     method: "POST",
//   });

//   gather.say(
//     { voice: "Polly.Aditi", language: "hi-IN" },
//     "Complaint register karne ke liye ek dabayein. Human agent se baat karne ke liye do dabayein."
//   );

//   res.type("text/xml").send(twiml.toString());
// });

// /* =======================
//    PROCESS CALL  â€”  POST /voice/process
// ======================= */
// router.post("/process", async (req, res) => {
//   const twiml = new VoiceResponse();
//   const { CallSid, Digits, SpeechResult } = req.body;

//   /* â”€â”€â”€ guard: session must exist â”€â”€â”€ */
//   const call = await CallSession.findOne({ callSid: CallSid });
//   if (!call) {
//     twiml.say("Technical error.");
//     twiml.hangup();
//     return res.type("text/xml").send(twiml.toString());
//   }

//   /* â”€â”€â”€ guard: nothing received â†’ replay last question â”€â”€â”€ */
//   if (!SpeechResult && !Digits) {
//     ask(twiml, call.temp.lastQuestion || "Kripya apna jawab bolein.", call);
//     await call.save();
//     return res.type("text/xml").send(twiml.toString());
//   }

//   /* =======================
//      IVR MENU  (DTMF only)
//   ======================= */
//   if (call.step === "ivr_menu") {
//     if (Digits === "2") {
//       twiml.say("Aapko agent se connect kiya ja raha hai.");
//       twiml.dial(process.env.HUMAN_AGENT_NUMBER);
//       return res.type("text/xml").send(twiml.toString());
//     }

//     if (Digits === "1") {
//       call.step = "ask_identifier";
//       ask(
//         twiml,
//         "Welcome to Rajesh JCB motors. Kripya apni machine ka chassis number ya registered mobile number boliye.",
//         call
//       );
//       await call.save();
//       return res.type("text/xml").send(twiml.toString());
//     }

//     // invalid key or no input
//     ask(twiml, "Kripya ek ya do dabayein.", call);
//     await call.save();
//     return res.type("text/xml").send(twiml.toString());
//   }

//   /* =======================
//      SPEECH PRE-PROCESSING
//      normalizeHindiIntent runs here once so that EVERY downstream match â€”
//      category detection AND sub-complaint keyword matching â€” already has
//      the romanized English equivalents appended.
//   ======================= */
//   const rawSpeech = normalizeText(cleanSpeech(SpeechResult || ""));
//   const speech = normalizeHindiIntent(rawSpeech);

//   console.log("ðŸŽ¤ RAW SPEECH :", SpeechResult);
//   console.log("ðŸ§¹ CLEANED    :", rawSpeech);
//   console.log("ðŸ”¤ NORMALIZED :", speech);

//   /* â”€â”€â”€ caller is confused / asking to repeat â”€â”€â”€ */
//   if (speech.length > 0 && isConfusedSpeech(speech)) {
//     ask(twiml, call.temp.lastQuestion || "Kripya dobara bolein.", call);
//     await call.save();
//     return res.type("text/xml").send(twiml.toString());
//   }

//   /* â”€â”€â”€ completely empty after cleaning â”€â”€â”€ */
//   if (!speech) {
//     call.temp.retries = (call.temp.retries || 0) + 1;

//     if (call.temp.retries >= 3) {
//       twiml.say(
//         "Humein aawaz sunai nahi de rahi. Aapko agent se connect kiya ja raha hai."
//       );
//       twiml.dial(process.env.HUMAN_AGENT_NUMBER);
//       return res.type("text/xml").send(twiml.toString());
//     }

//     ask(twiml, call.temp.lastQuestion || "Kripya apna jawab bolein.", call);
//     await call.save();
//     return res.type("text/xml").send(twiml.toString());
//   }

//   /* =======================
//      STATE MACHINE
//   ======================= */
//   switch (call.step) {
//     /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ IDENTIFIER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
//     case "ask_identifier": {
//       let digits = speech.replace(/\D/g, "");

//       // if digit extraction was too short try converting spoken Hindi words
//       if (digits.length < 10) {
//         const wordDigits = wordsToDigits(speech);
//         if (wordDigits.length >= 10) {
//           digits = wordDigits;
//         }
//       }

//       let customer = null;

//       // chassis: strip spaces + upper-case; override with word-digits if long enough
//       let chassis = speech.replace(/\s+/g, "").toUpperCase();
//       const digitFromWords = wordsToDigits(speech);
//       if (digitFromWords.length >= 4) {
//         chassis = digitFromWords;
//       }

//       // 1ï¸âƒ£  phone lookup
//       if (digits.length === 10) {
//         customer = await Customer.findOne({ phone: digits });
//       }
//       // 2ï¸âƒ£  chassis lookup
//       if (!customer) {
//         customer = await Customer.findOne({ chassisNo: chassis });
//       }

//       if (!customer) {
//         call.temp.retries = (call.temp.retries || 0) + 1;

//         if (call.temp.retries >= 3) {
//           twiml.say(
//             { voice: "Polly.Aditi", language: "hi-IN" },
//             "Humein details verify nahi ho pa rahi. Aapko agent se connect kiya ja raha hai."
//           );
//           twiml.dial(process.env.HUMAN_AGENT_NUMBER);
//           return res.type("text/xml").send(twiml.toString());
//         }

//         ask(
//           twiml,
//           "Record nahi mila. Kripya chassis number ya registered mobile number dobara boliye.",
//           call
//         );
//         break;
//       }

//       // âœ… customer found
//       call.temp.customerId = customer._id.toString();
//       call.temp.retries = 0;
//       call.step = "ask_machine_location";

//       ask(
//         twiml,
//         `Aapka record mil gaya. Aap ${customer.city} se ${customer.name} bol rahe hain. Machine kis location par hai?`,
//         call
//       );
//       break;
//     }

//     /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ LOCATION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
//     case "ask_machine_location": {
//       if (speech.length < 3) {
//         ask(twiml, "Kripya poora location batayein.", call);
//         break;
//       }
//       call.temp.machineLocation = speech;
//       call.step = "ask_contact_name";
//       ask(twiml, "Contact person ka naam batayein.", call);
//       break;
//     }

//     /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ CONTACT NAME â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
//     case "ask_contact_name": {
//       call.temp.contactName = speech;
//       call.step = "ask_complaint";
//       call.temp.retries = 0;
//       ask(twiml, "Machine ki complaint batayein.", call);
//       break;
//     }

//     /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ COMPLAINT DETECTION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
//     case "ask_complaint": {
//       call.temp.rawComplaint = rawSpeech; // always preserve original spoken text

//       const intent = detectComplaintIntent(speech);

//       if (!intent) {
//         call.temp.retries = (call.temp.retries || 0) + 1;

//         if (call.temp.retries >= 2) {
//           call.temp.retries = 0;
//           ask(
//             twiml,
//             "Kripya bolein: engine, tyre, AC, hydraulic ya electrical.",
//             call
//           );
//           break;
//         }

//         ask(
//           twiml,
//           "Kripya engine, hydraulic, AC, electrical ya tyre ka problem batayein.",
//           call
//         );
//         break;
//       }

//       // âœ… intent detected â€” store as flat fields (Mongoose-safe)
//       call.temp.retries = 0;
//       call.temp.detectedIntentPrimary = intent.primary;
//       call.temp.detectedIntentConfidence = intent.confidence;

//       /*
//        * BRANCHING:
//        *   HIGH confidence (0.95) â†’ single unambiguous match
//        *     â†’ set title, go straight to sub-complaint question
//        *   LOW  confidence (0.60) â†’ multiple categories matched
//        *     â†’ confirm category with caller first
//        */
//       if (intent.confidence >= 0.9) {
//         call.temp.complaintTitle = intent.primary;

//         if (followUpQuestions[intent.primary]) {
//           call.step = "ask_sub_complaint";
//           call.temp.subRetries = 0;
//           ask(twiml, followUpQuestions[intent.primary].question, call);
//         } else {
//           // no sub-questions defined â†’ save directly
//           call.temp.complaintSubTitle = "Other";
//           call.step = "save_complaint";
//         }
//       } else {
//         // ambiguous â†’ confirm with caller
//         call.step = "confirm_complaint";
//         ask(
//           twiml,
//           `Aap keh rahe hain ${intent.primary} ka issue hai, sahi? Haan ya nahi bolein.`,
//           call
//         );
//       }
//       break;
//     }

//     /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ CONFIRM COMPLAINT (only when confidence is low) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
//     case "confirm_complaint": {
//       const isYes =
//         speech.includes("haan") ||
//         speech.includes("à¤¹à¤¾à¤‚") ||
//         speech.includes("yes") ||
//         speech.includes("ji") ||
//         speech.includes("sahi");

//       const isNo =
//         speech.includes("nahi") ||
//         speech.includes("à¤¨à¤¹à¥€à¤‚") ||
//         speech.includes("no");

//       if (isYes) {
//         const title = call.temp.detectedIntentPrimary;
//         call.temp.complaintTitle = title;

//         if (followUpQuestions[title]) {
//           call.step = "ask_sub_complaint";
//           call.temp.subRetries = 0;
//           ask(twiml, followUpQuestions[title].question, call);
//         } else {
//           call.temp.complaintSubTitle = "Other";
//           call.step = "save_complaint";
//         }
//         break;
//       }

//       if (isNo) {
//         call.step = "ask_complaint";
//         call.temp.retries = 0;
//         ask(twiml, "Theek hai, kripya complaint dobara batayein.", call);
//         break;
//       }

//       // neither yes nor no understood
//       ask(twiml, "Kripya haan ya nahi bolein.", call);
//       break;
//     }

//     /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ SUB-COMPLAINT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
//     case "ask_sub_complaint": {
//       const title = call.temp.complaintTitle;
//       const followUp = followUpQuestions[title];

//       // safety net: no config found â†’ default to Other
//       if (!followUp) {
//         call.temp.complaintSubTitle = "Other";
//         call.step = "save_complaint";
//         break;
//       }

//       call.temp.subRetries = call.temp.subRetries || 0;

//       // match against NORMALIZED speech â€” Devanagariâ†’romanized already done
//       let detectedSub = null;
//       for (const [keyword, subTitle] of Object.entries(followUp.options)) {
//         if (speech.includes(keyword)) {
//           detectedSub = subTitle;
//           break;
//         }
//       }

//       if (!detectedSub) {
//         call.temp.subRetries += 1;

//         // after 2 failed attempts â†’ default to Other and save
//         if (call.temp.subRetries >= 2) {
//           call.temp.complaintSubTitle = "Other";
//           call.step = "save_complaint";
//           break;
//         }

//         // retry with a clearer prompt
//         ask(
//           twiml,
//           followUp.question + " Kripya thoda clear bolein.",
//           call
//         );
//         break;
//       }

//       // âœ… sub-complaint matched
//       call.temp.subRetries = 0;
//       call.temp.complaintSubTitle = detectedSub;
//       call.step = "save_complaint";
//       break;
//     }

//     /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ SAVE & CLOSE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
//     case "save_complaint": {
//       const customer = await Customer.findById(call.temp.customerId);

//       if (!customer) {
//         // edge-case: customer removed between steps
//         twiml.say("Technical error. Aapko agent se connect kiya ja raha hai.");
//         twiml.dial(process.env.HUMAN_AGENT_NUMBER);
//         return res.type("text/xml").send(twiml.toString());
//       }

//       await Complaint.create({
//         customerId: customer._id,
//         chassisNo: customer.chassisNo || "Unknown",
//         phone: customer.phone,
//         customerName: customer.name || "Unknown",
//         contactPersonName: call.temp.contactName || "Unknown",
//         machineLocation: call.temp.machineLocation || "Unknown",
//         description_raw: call.temp.rawComplaint || "Not provided by caller",
//         complaintTitle: call.temp.complaintTitle || "NA",
//         complaintSubTitle: call.temp.complaintSubTitle || "Other",
//         callSid: CallSid,
//         source: "IVR_VOICE_BOT",
//       });

//       call.step = "done";
//       twiml.say(
//         { voice: "Polly.Aditi", language: "hi-IN" },
//         "Dhanyavaad. Aapki complaint register ho gayi hai. Hamara team aapke saath jaldi contact karega."
//       );
//       twiml.hangup();
//       break;
//     }
//   }

//   await call.save();
//   res.type("text/xml").send(twiml.toString());
// });

// export default router;






































Good Keywords added for more imporvment






import express from "express";
import twilio from "twilio";
import axios from "axios";

import CallSession from "../models/CallSession.js";
import Customer from "../models/Customer.js";
import Complaint from "../models/Complaint.js";

const router = express.Router();
const VoiceResponse = twilio.twiml.VoiceResponse;

/* =======================
   EXTERNAL API CONFIG
======================= */
const EXTERNAL_API_BASE = "http://gprs.rajeshmotors.com/jcbServiceEnginerAPIv7";
const COMPLAINT_API_URL =
  "http://gprs.rajeshmotors.com/jcbServiceEnginerAPIv7/ai_call_complaint.php";
const API_TIMEOUT = 20000;
const API_HEADERS = {
  JCBSERVICEAPI: "MakeInJcb",
};

/* =======================
   ADVANCED NLU - INTENT DETECTION
======================= */
const intentPatterns = {
  // User is correcting/disagreeing
  correction: {
    patterns: [
      /à¤¨à¤¹à¥€à¤‚\s*à¤¨à¤¹à¥€à¤‚/i,
      /maine\s*(ye\s*)?nahi\s*kaha/i,
      /maine.*nahi.*bola/i,
      /galat\s*hai/i,
      /ye\s*nahi/i,
      /nahi\s*ji/i,
      /bilkul\s*nahi/i,
      /aisa\s*nahi/i,
      /sahi\s*nahi/i,
      /theek\s*nahi/i,
    ],
    priority: 100,
  },
  
  // User wants to skip/go to agent
  escalation: {
    patterns: [
      /agent\s*se\s*baat/i,
      /kisi\s*se\s*baat/i,
      /insaan\s*se/i,
      /call\s*transfer/i,
      /forward\s*kar/i,
      /samajh\s*nahi\s*aa\s*raha/i,
    ],
    priority: 95,
  },
  
  // User is asking a different question
  different_question: {
    patterns: [
      /main\s*ye\s*nahi\s*pooch\s*raha/i,
      /doosra\s*sawaal/i,
      /kuch\s*aur\s*poochna/i,
      /pehle\s*ye\s*batao/i,
      /ek\s*minute/i,
      /ruko/i,
      /wait/i,
    ],
    priority: 90,
  },
  
  // User doesn't know/remember
  uncertainty: {
    patterns: [
      /pata\s*nahi/i,
      /yaad\s*nahi/i,
      /maloom\s*nahi/i,
      /samajh\s*nahi/i,
      /nahi\s*pata/i,
      /bhool\s*gaya/i,
      /nahi\s*yaad/i,
    ],
    priority: 85,
  },
  
  // Affirmative responses
  affirmative: {
    patterns: [
      /^(haan|ha|à¤¹à¤¾à¤|à¤¹à¤¾à¤‚|yes|ji|sahi|theek|correct|bilkul)\s*$/i,
      /^(haan|ha|à¤¹à¤¾à¤|à¤¹à¤¾à¤‚|yes|ji)\s+(hai|sahi|theek|bilkul)/i,
    ],
    priority: 80,
  },
  
  // Negative responses  
  negative: {
    patterns: [
      /^(nahi|à¤¨à¤¹à¥€à¤‚|no|na)\s*$/i,
      /^(nahi|à¤¨à¤¹à¥€à¤‚|no)\s+(ji|hai)/i,
    ],
    priority: 80,
  },
};

function detectIntent(text) {
  if (!text) return null;
  
  const textLower = text.toLowerCase().trim();
  let bestMatch = null;
  let highestPriority = 0;
  
  for (const [intent, config] of Object.entries(intentPatterns)) {
    for (const pattern of config.patterns) {
      if (pattern.test(text)) {
        if (config.priority > highestPriority) {
          highestPriority = config.priority;
          bestMatch = intent;
        }
        break;
      }
    }
  }
  
  return bestMatch;
}

/* =======================
   ADVANCED NAME EXTRACTION
======================= */
const nameExtractionPatterns = {
  // Common noise words to remove
  noiseWords: [
    'mera', 'naam', 'hai', 'hoon', 'main', 'ji', 'sir', 'madam',
    'my', 'name', 'is', 'am', 'i',
    'kya', 'kaun', 'bolo', 'batao', 'suniye', 'dekhiye',
    'aaj', 'kal', 'din', 'raat', 'subah', 'sham',
    'baje', 'ghante', 'minute', 'second',
    'à¤®à¥‡à¤°à¤¾', 'à¤¨à¤¾à¤®', 'à¤¹à¥ˆ', 'à¤¹à¥‚à¤‚', 'à¤®à¥ˆà¤‚', 'à¤œà¥€',
  ],
  
  // Common name patterns
  commonNames: [
    'ram', 'shyam', 'mohan', 'sohan', 'ravi', 'vijay', 'raj', 'kumar',
    'singh', 'sharma', 'verma', 'gupta', 'anshu', 'ankit', 'amit',
    'suresh', 'ramesh', 'dinesh', 'mahesh', 'rakesh', 'lokesh',
    'pradeep', 'sandeep', 'rajesh', 'naresh', 'mukesh',
    'à¤°à¤¾à¤®', 'à¤¶à¥à¤¯à¤¾à¤®', 'à¤®à¥‹à¤¹à¤¨', 'à¤¸à¥‹à¤¹à¤¨', 'à¤°à¤µà¤¿', 'à¤µà¤¿à¤œà¤¯', 'à¤°à¤¾à¤œ',
  ],
  
  // Invalid name patterns
  invalidPatterns: [
    /^\d+$/,  // Only numbers
    /^[a-z]$/i,  // Single letter
    /complaint|problem|issue|dikkat/i,
    /machine|engine|hydraulic/i,
    /^(the|a|an|is|are|was|were)$/i,
  ],
};

function extractName(text) {
  if (!text) return null;
  
  const cleaned = text.toLowerCase()
    .replace(/[à¥¤.,!?:;]/g, '')
    .replace(/\s+/g, ' ')
    .trim();
  
  // Remove noise words
  let words = cleaned.split(' ').filter(word => {
    return !nameExtractionPatterns.noiseWords.includes(word);
  });
  
  // Filter out invalid words
  words = words.filter(word => {
    for (const pattern of nameExtractionPatterns.invalidPatterns) {
      if (pattern.test(word)) return false;
    }
    return word.length >= 2;
  });
  
  if (words.length === 0) return null;
  
  // Join remaining words as name
  const extractedName = words.join(' ');
  
  // Validate - must have at least 2 chars and some letters
  if (extractedName.length >= 2 && /[a-zA-Z\u0900-\u097F]/.test(extractedName)) {
    return extractedName;
  }
  
  return null;
}

/* =======================
   ADVANCED PHONE EXTRACTION
======================= */
const phoneExtractionPatterns = {
  hindiDigits: {
    'à¤¶à¥‚à¤¨à¥à¤¯': '0', 'zero': '0', 'shunya': '0',
    'à¤à¤•': '1', 'ek': '1', 'one': '1',
    'à¤¦à¥‹': '2', 'do': '2', 'two': '2',
    'à¤¤à¥€à¤¨': '3', 'teen': '3', 'three': '3',
    'à¤šà¤¾à¤°': '4', 'char': '4', 'chaar': '4', 'four': '4',
    'à¤ªà¤¾à¤‚à¤š': '5', 'paanch': '5', 'panch': '5', 'five': '5',
    'à¤›à¤¹': '6', 'chhe': '6', 'che': '6', 'six': '6',
    'à¤¸à¤¾à¤¤': '7', 'saat': '7', 'seven': '7',
    'à¤†à¤ ': '8', 'aath': '8', 'eight': '8',
    'à¤¨à¥Œ': '9', 'nau': '9', 'nine': '9',
    'à¤¦à¤¸': '10', 'das': '10', 'ten': '10',
  },
  
  // Patterns to clean
  noisePhrases: [
    'phone', 'number', 'contact', 'mobile',
    'à¤«à¥‹à¤¨', 'à¤¨à¤‚à¤¬à¤°', 'à¤¸à¤‚à¤ªà¤°à¥à¤•', 'à¤®à¥‹à¤¬à¤¾à¤‡à¤²',
    'mera', 'hai', 'is', 'the',
  ],
};

function extractPhoneNumber(text) {
  if (!text) return null;
  
  let cleaned = text.toLowerCase()
    .replace(/[à¥¤.,!?:;-]/g, ' ')
    .replace(/\s+/g, ' ')
    .trim();
  
  // Remove noise phrases
  for (const phrase of phoneExtractionPatterns.noisePhrases) {
    cleaned = cleaned.replace(new RegExp(phrase, 'gi'), ' ');
  }
  
  // Extract direct digits
  let digits = cleaned.replace(/\D/g, '');
  
  // If not enough digits, try word-to-digit conversion
  if (digits.length < 10) {
    const words = cleaned.split(/\s+/);
    let convertedDigits = '';
    
    for (const word of words) {
      if (phoneExtractionPatterns.hindiDigits[word]) {
        convertedDigits += phoneExtractionPatterns.hindiDigits[word];
      } else if (/^\d+$/.test(word)) {
        convertedDigits += word;
      }
    }
    
    if (convertedDigits.length >= 10) {
      digits = convertedDigits;
    }
  }
  
  // Validate 10-digit phone
  if (digits.length === 10 && /^[6-9]\d{9}$/.test(digits)) {
    return digits;
  }
  
  // Handle 11-digit with country code
  if (digits.length === 11 && digits.startsWith('91')) {
    const phone = digits.substring(1);
    if (/^[6-9]\d{9}$/.test(phone)) {
      return phone;
    }
  }
  
  // Try to find 10 consecutive digits
  const match = cleaned.match(/(\d{10})/);
  if (match && /^[6-9]\d{9}$/.test(match[1])) {
    return match[1];
  }
  
  return null;
}

/* =======================
   BRANCH, OUTLET & CITY CODE MAPPING
======================= */
const cityToBranchMap = {
  // AJMER Branch (Code: 1)
  ajmer: { branch: "AJMER", outlet: "AJMER", cityCode: "1" },
  kekri: { branch: "AJMER", outlet: "KEKRI", cityCode: "1" },

  // ALWAR Branch (Code: 2)
  alwar: { branch: "ALWAR", outlet: "ALWAR", cityCode: "2" },
  bharatpur: { branch: "ALWAR", outlet: "BHARATPUR", cityCode: "2" },
  bhiwadi: { branch: "ALWAR", outlet: "BHIWADI", cityCode: "2" },
  dholpur: { branch: "ALWAR", outlet: "DHOLPUR", cityCode: "2" },

  // BHILWARA Branch (Code: 3)
  bhilwara: { branch: "BHILWARA", outlet: "BHILWARA", cityCode: "3" },
  nimbahera: { branch: "BHILWARA", outlet: "NIMBAHERA", cityCode: "3" },
  pratapgarh: { branch: "BHILWARA", outlet: "PRATAPGARH", cityCode: "3" },

  // JAIPUR Branch (Code: 4)
  dausa: { branch: "JAIPUR", outlet: "DAUSA", cityCode: "4" },
  "goner road": { branch: "JAIPUR", outlet: "GONER ROAD", cityCode: "4" },
  jaipur: { branch: "JAIPUR", outlet: "JAIPUR", cityCode: "4" },
  karauli: { branch: "JAIPUR", outlet: "KARAULI", cityCode: "4" },
  karoli: { branch: "JAIPUR", outlet: "KARAULI", cityCode: "4" },
  kotputli: { branch: "JAIPUR", outlet: "KOTPUTLI", cityCode: "4" },
  "neem ka thana": { branch: "JAIPUR", outlet: "NEEM KA THANA", cityCode: "4" },
  tonk: { branch: "JAIPUR", outlet: "TONK", cityCode: "4" },
  vkia: { branch: "JAIPUR", outlet: "VKIA", cityCode: "4" },

  // KOTA Branch (Code: 5)
  jhalawar: { branch: "KOTA", outlet: "JHALAWAR", cityCode: "5" },
  kota: { branch: "KOTA", outlet: "KOTA", cityCode: "5" },
  ramganjmandi: { branch: "KOTA", outlet: "RAMGANJMANDI", cityCode: "5" },

  // SIKAR Branch (Code: 6)
  jhunjhunu: { branch: "SIKAR", outlet: "JHUNJHUNU", cityCode: "6" },
  sikar: { branch: "SIKAR", outlet: "SIKAR", cityCode: "6" },
  sujangarh: { branch: "SIKAR", outlet: "SUJANGARH", cityCode: "6" },

  // UDAIPUR Branch (Code: 7)
  banswara: { branch: "UDAIPUR", outlet: "BANSWARA", cityCode: "7" },
  dungarpur: { branch: "UDAIPUR", outlet: "DUNGARPUR", cityCode: "7" },
  rajsamand: { branch: "UDAIPUR", outlet: "RAJSAMAND", cityCode: "7" },
  udaipur: { branch: "UDAIPUR", outlet: "UDAIPUR", cityCode: "7" },
};

/* =======================
   ENHANCED COMPLAINT MAPPING WITH IMPROVED PATTERNS
======================= */
const complaintMap = {
  "AC System": {
    keywords: [
      "ac", "à¤à¤¸à¥€", "à¤à¤¸à¥€", "à¤à¤•à¤¸à¥€", "à¤ à¤¸à¥€", "à¤.à¤¸à¥€", 
      "cooling", "à¤ à¤‚à¤¡à¤¾", "à¤•à¥‚à¤²à¤¿à¤‚à¤—", "à¤ à¤‚à¤¡à¥€", "à¤•à¥‚à¤²", "à¤ à¤‚à¤¡"
    ],
    priority: 10,
    subTitles: {
      "AC not Working": [
        "à¤¨à¤¹à¥€à¤‚ à¤šà¤²", "band", "à¤¬à¤‚à¤¦", "à¤•à¤¾à¤® à¤¨à¤¹à¥€à¤‚", "work à¤¨à¤¹à¥€à¤‚", 
        "à¤šà¤¾à¤²à¥‚ à¤¨à¤¹à¥€à¤‚", "start à¤¨à¤¹à¥€à¤‚", "on à¤¨à¤¹à¥€à¤‚"
      ],
      "AC not Cooling": [
        "cooling", "à¤ à¤‚à¤¡à¤¾ à¤¨à¤¹à¥€à¤‚", "à¤ à¤‚à¤¡à¥€ à¤¨à¤¹à¥€à¤‚", "à¤•à¥‚à¤²à¤¿à¤‚à¤— à¤¨à¤¹à¥€à¤‚", 
        "cool à¤¨à¤¹à¥€à¤‚", "à¤—à¤°à¤®", "heat", "à¤ à¤‚à¤¡ à¤¨à¤¹à¥€à¤‚", "thanda nahi",
        "à¤šà¤¾à¤²à¥‚ à¤¹à¥ˆ à¤²à¥‡à¤•à¤¿à¤¨", "on hai lekin", "chal rahi lekin"
      ]
    }
  },

  "Attachment": {
    keywords: ["attachment", "bucket", "breaker", "rock breaker", "als", "livelink", "à¤…à¤Ÿà¥ˆà¤šà¤®à¥‡à¤‚à¤Ÿ", "à¤¬à¤•à¥‡à¤Ÿ"],
    priority: 5,
    subTitles: {
      "ALS problem": ["als", "à¤à¤à¤²à¤à¤¸"],
      "Bucket Crack Issue": ["bucket crack", "bucket à¤«à¤Ÿà¥€", "bucket à¤Ÿà¥‚à¤Ÿà¥€"],
      "Live link problem": ["livelink", "live link", "à¤²à¤¾à¤‡à¤µà¤²à¤¿à¤‚à¤•"],
      "Rock breaker problem": ["rock breaker", "breaker", "à¤°à¥‰à¤• à¤¬à¥à¤°à¥‡à¤•à¤°", "à¤¬à¥à¤°à¥‡à¤•à¤°"]
    }
  },

  "Body Work": {
    keywords: ["body", "bushing", "drum", "noise", "vibration", "à¤¬à¥‰à¤¡à¥€", "à¤¡à¥à¤°à¤®"],
    priority: 4,
    subTitles: {
      "Bushing Work": ["bushing", "à¤¬à¥à¤¶à¤¿à¤‚à¤—"],
      "Leakage from Drum": ["drum leak", "à¤¡à¥à¤°à¤® à¤²à¥€à¤•"],
      "Noise from Drum": ["drum noise", "drum à¤†à¤µà¤¾à¤œ", "à¤¡à¥à¤°à¤® à¤¶à¥‹à¤°"],
      "Vibration fault in Drum": ["vibration", "à¤•à¤‚à¤ªà¤¨"],
      "Water Sprinkle Pipe fault": ["water pipe", "sprinkle", "à¤ªà¤¾à¤¨à¥€ à¤ªà¤¾à¤‡à¤ª"],
      "color fad problem": ["color", "paint", "à¤°à¤‚à¤—"],
      "Decal/Sticker Pesting": ["sticker", "decal", "à¤¸à¥à¤Ÿà¥€à¤•à¤°"]
    }
  },

  "Cabin": {
    keywords: ["cabin", "cab", "door", "glass", "seat", "à¤•à¥‡à¤¬à¤¿à¤¨", "à¤¸à¥€à¤Ÿ", "à¤¦à¤°à¤µà¤¾à¤œà¤¾"],
    priority: 4,
    subTitles: {
      "bonnet crack": ["bonnet crack", "bonnet à¤«à¤Ÿà¥€"],
      "Cab Door Fault": ["door", "à¤¦à¤°à¤µà¤¾à¤œà¤¾"],
      "Cabin glass cracked": ["glass crack", "à¤¶à¥€à¤¶à¤¾ à¤Ÿà¥‚à¤Ÿà¤¾"],
      "Cabin Glass removed": ["glass remove", "à¤¶à¥€à¤¶à¤¾ à¤¹à¤Ÿà¤¾"],
      "Door/window lock inoperative": ["lock", "à¤¤à¤¾à¤²à¤¾"],
      "Fan not working": ["fan", "à¤ªà¤‚à¤–à¤¾"],
      "mounting problem": ["mounting", "à¤®à¤¾à¤‰à¤‚à¤Ÿà¤¿à¤‚à¤—"],
      "Operator Seat problems": ["seat", "à¤¸à¥€à¤Ÿ"],
      "Roof cracked": ["roof crack", "à¤›à¤¤"]
    }
  },

  "Electrical Complaint": {
  keywords: [
    "electrical", "battery", "light", "wiring", "starter", 
    "à¤¬à¤¿à¤œà¤²à¥€", "à¤¬à¥ˆà¤Ÿà¤°à¥€", "à¤²à¤¾à¤‡à¤Ÿ", "à¤µà¤¾à¤¯à¤°à¤¿à¤‚à¤—", "self", "à¤¸à¥‡à¤²à¥à¤«"
  ],
  priority: 6,
  subTitles: {
    "Starting trouble": [
      "start problem", "start à¤¨à¤¹à¥€à¤‚ à¤¹à¥‹ à¤°à¤¹à¥€", "à¤¸à¥à¤Ÿà¤¾à¤°à¥à¤Ÿ à¤¦à¤¿à¤•à¥à¤•à¤¤", 
      "à¤¸à¥à¤Ÿà¤¾à¤°à¥à¤Ÿ à¤¨à¤¹à¥€à¤‚ à¤¹à¥‹ à¤°à¤¹à¥€", "à¤¸à¥à¤Ÿà¤¾à¤°à¥à¤Ÿ à¤Ÿà¥à¤°à¤¬à¤²", "à¤¸à¥à¤Ÿà¤¾à¤°à¥à¤Ÿ",
      "self problem", "à¤¸à¥‡à¤²à¥à¤« à¤ªà¥à¤°à¥‰à¤¬à¥à¤²à¤®", "chalu nahi ho rahi",
      "starting issue", "starting trouble", "à¤¶à¥à¤°à¥‚ à¤¨à¤¹à¥€à¤‚"
    ],
    "Self/Starter motor problem": [
      "starter", "self", "à¤¸à¥‡à¤²à¥à¤«", "à¤¸à¥à¤Ÿà¤¾à¤°à¥à¤Ÿà¤°",
      "starter motor", "self motor"
    ],
    "Battery problem": [
      "battery", "à¤¬à¥ˆà¤Ÿà¤°à¥€", "dead", "à¤–à¤¤à¥à¤®", "discharge",
      "charge nahi", "à¤šà¤¾à¤°à¥à¤œ à¤¨à¤¹à¥€à¤‚"
    ],
    "Alternator not Working": ["alternator", "à¤…à¤²à¥à¤Ÿà¤°à¤¨à¥‡à¤Ÿà¤°"],
    "Error Code in Machine display": ["error code", "display error"],
    "Fuel Gauge not show/in correct level show": ["fuel gauge", "à¤«à¥à¤¯à¥‚à¤² à¤—à¥‡à¤œ"],
    "Fuel Motor not Working": ["fuel motor"],
    "Hour meter not working": ["hour meter", "à¤®à¥€à¤Ÿà¤°"],
    "Light glowing problem": ["light glow", "à¤²à¤¾à¤‡à¤Ÿ à¤œà¤² à¤°à¤¹à¥€"],
    "Pump water motor": ["water pump motor"],
    "Relay fault": ["relay", "à¤°à¤¿à¤²à¥‡"],
    "Reverse forward switch broken": ["reverse switch", "switch à¤Ÿà¥‚à¤Ÿà¤¾"],
    "speed/rpm meter not working": ["rpm", "speed meter", "à¤†à¤°à¤ªà¥€à¤à¤®"],
    "Switch Fault": ["switch", "à¤¸à¥à¤µà¤¿à¤š"],
    "Warnings/Alarm": ["warning", "alarm", "à¤šà¥‡à¤¤à¤¾à¤µà¤¨à¥€"],
    "Wiper motor not working": ["wiper", "à¤µà¤¾à¤‡à¤ªà¤°"],
    "Wiring problem": ["wiring", "wire", "à¤µà¤¾à¤¯à¤°à¤¿à¤‚à¤—", "à¤¤à¤¾à¤°"],
    "Light not working": ["light", "à¤²à¤¾à¤‡à¤Ÿ"],
    "Rope wire broken": ["rope wire", "à¤¤à¤¾à¤° à¤Ÿà¥‚à¤Ÿà¤¾"],
    "Stop Cable fault": ["stop cable", "à¤•à¥‡à¤¬à¤²"]
  }
},

  "Engine": {
    keywords: ["engine", "à¤‡à¤‚à¤œà¤¨", "smoke", "overheat", "à¤§à¥à¤†", "à¤—à¤°à¤®", 
    "à¤‡à¤‚à¤¡à¤¿à¤¯à¤¨", "motor", "à¤®à¥‹à¤Ÿà¤°", "power", "à¤ªà¤¾à¤µà¤°"],
    priority: 8,
    subTitles: {
    "Starting trouble": [
      "start", "à¤¸à¥à¤Ÿà¤¾à¤°à¥à¤Ÿ", "à¤¶à¥à¤°à¥‚", "chalu nahi", "à¤šà¤¾à¤²à¥‚ à¤¨à¤¹à¥€à¤‚",
      "self", "à¤¸à¥‡à¤²à¥à¤«", "starter", "à¤¸à¥à¤Ÿà¤¾à¤°à¥à¤Ÿà¤°", "kick",
      "start problem", "start à¤¨à¤¹à¥€à¤‚", "à¤¶à¥à¤°à¥‚ à¤¨à¤¹à¥€à¤‚",
      "starting", "à¤¸à¥à¤Ÿà¤¾à¤°à¥à¤Ÿà¤¿à¤‚à¤—", "dikkat", "à¤¦à¤¿à¤•à¥à¤•à¤¤",
      "hone mein", "à¤¹à¥‹à¤¨à¥‡ à¤®à¥‡à¤‚", "shuru hone"
    ],
    "Engine Over heating": [
      "overheat", "à¤—à¤°à¤®", "heat", "à¤—à¤°à¥à¤®à¥€", "hot",
      "à¤—à¤°à¤®à¥€", "à¤¤à¤¾à¤ªà¤®à¤¾à¤¨", "temperature", "hit",
      "à¤¹à¤¿à¤Ÿ", "à¤—à¤°à¥à¤® à¤¹à¥‹", "garam ho", "overheat ho"
    ],
    "Smoke problem": [
      "smoke", "à¤§à¥à¤†", "à¤§à¥à¤‚à¤†", "dhuan", "à¤•à¤¾à¤²à¤¾ à¤§à¥à¤†",
      "black smoke", "white smoke", "à¤¸à¤«à¥‡à¤¦ à¤§à¥à¤†"
    ],
    "Abnormal Noise": [
      "noise", "sound", "à¤†à¤µà¤¾à¤œ", "à¤¶à¥‹à¤°", "awaaz",
      "à¤–à¤¡à¤¼à¤–à¤¡à¤¼", "à¤†à¤µà¤¾à¤œ à¤†", "sound aa"
    ],
    "Engine Lugg down": [
      "lugg down", "power kam", "à¤ªà¤¾à¤µà¤° à¤•à¤®", "à¤¤à¤¾à¤•à¤¤ à¤¨à¤¹à¥€à¤‚",
      "slow", "à¤§à¥€à¤°à¥‡", "à¤•à¤®à¤œà¥‹à¤°", "weak"
    ],
    "Air problem": ["air", "à¤¹à¤µà¤¾", "à¤¹à¤µà¤¾ à¤•à¥€"],
    "coolant leak": ["coolant leak", "à¤ªà¤¾à¤¨à¥€ à¤²à¥€à¤•", "water leak"],
    "Engine seal leak": ["seal leak", "à¤¸à¥€à¤² à¤²à¥€à¤•"],
    "Fan belt broken": ["fan belt", "belt", "à¤¬à¥‡à¤²à¥à¤Ÿ"],
    "FIP issue": ["fip", "à¤à¤«à¤†à¤ˆà¤ªà¥€"],
    "Fuel consumption high": [
      "fuel à¤œà¥à¤¯à¤¾à¤¦à¤¾", "diesel à¤œà¥à¤¯à¤¾à¤¦à¤¾", "fuel consumption",
      "à¤–à¤ªà¤¤ à¤œà¥à¤¯à¤¾à¤¦à¤¾", "mileage kam"
    ],
    "Leakages engine": ["engine leak", "à¤‡à¤‚à¤œà¤¨ à¤²à¥€à¤•", "oil leak"],
    "missing problem": ["missing", "à¤®à¤¿à¤¸à¤¿à¤‚à¤—"],
    "Oil consumption high": ["oil à¤œà¥à¤¯à¤¾à¤¦à¤¾", "oil consumption"],
    "Radiator leak": ["radiator", "à¤°à¥‡à¤¡à¤¿à¤à¤Ÿà¤°"],
    "swing motor problem": ["swing motor", "à¤¸à¥à¤µà¤¿à¤‚à¤— à¤®à¥‹à¤Ÿà¤°"],
    "Engine mounting problem": ["mounting", "à¤®à¤¾à¤‰à¤‚à¤Ÿà¤¿à¤‚à¤—"],
    "Accelerator cable problem": ["accelerator", "cable", "à¤•à¥‡à¤¬à¤²"]
  }
},

  "Fabrication part": {
    keywords: ["fabrication", "crack", "boom", "bucket", "chassis", "à¤«à¥ˆà¤¬à¥à¤°à¤¿à¤•à¥‡à¤¶à¤¨", "à¤•à¥à¤°à¥ˆà¤•"],
    priority: 5,
    subTitles: {
      "Boom cracked": ["boom crack", "boom à¤«à¤Ÿà¥€"],
      "Bucket cracked": ["bucket crack", "bucket à¤«à¤Ÿà¥€"],
      "Bucket issue": ["bucket", "à¤¬à¤•à¥‡à¤Ÿ"],
      "Chassis cracked": ["chassis crack", "chassis à¤«à¤Ÿà¥€"],
      "Dipper cracked": ["dipper crack", "dipper à¤«à¤Ÿà¥€"],
      "Fuel Tank Leakage": ["fuel tank leak", "à¤Ÿà¥ˆà¤‚à¤• à¤²à¥€à¤•"],
      "Hydraulic Tank leakage": ["hydraulic tank", "à¤¹à¤¾à¤‡à¤¡à¥à¤°à¥‹à¤²à¤¿à¤• à¤Ÿà¥ˆà¤‚à¤•"],
      "Inner leg Cracked/Bend": ["inner leg", "leg crack"],
      "King post problem/cracked": ["king post", "à¤ªà¥‹à¤¸à¥à¤Ÿ"],
      "Loader arm bend": ["loader arm bend", "arm à¤®à¥à¤¡à¤¼à¤¾"],
      "Loader arm cracked": ["loader arm crack", "arm à¤«à¤Ÿà¤¾"],
      "Pin broken": ["pin broken", "à¤ªà¤¿à¤¨ à¤Ÿà¥‚à¤Ÿà¤¾"],
      "Teeth broken": ["teeth broken", "à¤¦à¤¾à¤‚à¤¤ à¤Ÿà¥‚à¤Ÿà¤¾"],
      "Tipping lever cracked": ["tipping lever"],
      "Tippnig link problem": ["tipping link"],
      "Tank leak/crack": ["tank", "à¤Ÿà¥ˆà¤‚à¤•"],
      "Stabilizer Pad problem": ["stabilizer", "à¤¸à¥à¤Ÿà¥‡à¤¬à¤²à¤¾à¤‡à¤œà¤°"]
    }
  },

  "Transmission/Axle components": {
    keywords: ["transmission", "gear", "brake", "axle", "à¤Ÿà¥à¤°à¤¾à¤‚à¤¸à¤®à¤¿à¤¶à¤¨", "à¤—à¤¿à¤¯à¤°", "à¤¬à¥à¤°à¥‡à¤•"],
    priority: 6,
    subTitles: {
      "Abnormal sound Transmission/Axle": ["sound", "noise", "à¤†à¤µà¤¾à¤œ"],
      "Barring problem": ["barring", "à¤¬à¥ˆà¤°à¤¿à¤‚à¤—"],
      "Brake problem": ["brake", "à¤¬à¥à¤°à¥‡à¤•"],
      "Gear box problem": ["gear box", "gearbox", "à¤—à¤¿à¤¯à¤° à¤¬à¥‰à¤•à¥à¤¸"],
      "Gear hard": ["gear hard", "gear à¤¸à¤–à¥à¤¤"],
      "Oil leak from transmission": ["oil leak", "à¤¤à¥‡à¤² à¤²à¥€à¤•"],
      "Reverse forward issue": ["reverse", "forward", "à¤°à¤¿à¤µà¤°à¥à¤¸"],
      "Transmission overheat": ["transmission à¤—à¤°à¤®", "overheat"]
    }
  },

  "Hose": {
    keywords: ["hose", "pipe", "à¤¹à¥‹à¤¸", "à¤ªà¤¾à¤‡à¤ª"],
    priority: 4,
    subTitles: {
      "Hose O ring Cut": ["o ring", "oring", "à¤“ à¤°à¤¿à¤‚à¤—"],
      "Hose cut": ["hose cut", "à¤¹à¥‹à¤¸ à¤•à¤Ÿà¤¾"],
      "Hose leakages": ["hose leak", "à¤¹à¥‹à¤¸ à¤²à¥€à¤•"]
    }
  },

  "Hydraulic": {
    keywords: ["hydraulic", "à¤¹à¤¾à¤‡à¤¡à¥à¤°à¥‹à¤²à¤¿à¤•", "pressure", "pump", "à¤ªà¥à¤°à¥‡à¤¶à¤°", "à¤ªà¤‚à¤ª"],
    priority: 7,
    subTitles: {
      "Abnormal sound": ["sound", "noise", "à¤†à¤µà¤¾à¤œ"],
      "Control Valve leakage": ["control valve", "valve leak"],
      "EVB seal leak": ["evb", "à¤ˆà¤µà¥€à¤¬à¥€"],
      "Hydra clamp issue": ["hydra clamp"],
      "Hydraulic gauge leakage": ["gauge leak"],
      "Hydraulic pump broken": ["pump broken", "pump à¤Ÿà¥‚à¤Ÿà¤¾"],
      "Hydraulic pump leak": ["pump leak", "à¤ªà¤‚à¤ª à¤²à¥€à¤•"],
      "Hydraulic pump Noise": ["pump noise", "pump à¤†à¤µà¤¾à¤œ"],
      "Joy Stick Leakage": ["joystick", "joy stick"],
      "LVB seal leak": ["lvb"],
      "Machine performance low/Slow working": ["slow", "à¤§à¥€à¤°à¥‡", "à¤•à¤® speed", "power kam"],
      "Oil cooler leak": ["oil cooler"],
      "Pressure down": ["pressure", "à¤ªà¥à¤°à¥‡à¤¶à¤°", "à¤•à¤®"],
      "Rotary Coupling leakage": ["rotary coupling"],
      "spool seal leak": ["spool"],
      "Swing Motor leakage": ["swing motor leak"],
      "Swing Motor not braking": ["swing motor brake"],
      "Travel Pedal leakage": ["travel pedal"]
    }
  },

  "Ram/Cylinder": {
    keywords: ["ram", "cylinder", "rod", "à¤¸à¤¿à¤²à¥‡à¤‚à¤¡à¤°", "à¤°à¥‰à¤¡"],
    priority: 5,
    subTitles: {
      "Boom ram seal leak": ["boom ram", "boom à¤¸à¥€à¤²"],
      "bucket ram seal leak": ["bucket ram", "bucket à¤¸à¥€à¤²"],
      "Cylinder welding leak": ["cylinder weld", "welding"],
      "Dipper ram seal leak": ["dipper ram", "dipper à¤¸à¥€à¤²"],
      "Dozer Cylinder leak": ["dozer cylinder"],
      "Dozer ram seal leak": ["dozer ram"],
      "kpc/selw cylinder seal leak": ["kpc", "selw"],
      "Lift ram seal leak": ["lift ram"],
      "Ram leak": ["ram leak", "à¤°à¤¾à¤® à¤²à¥€à¤•"],
      "Rod bend": ["rod bend", "rod à¤®à¥à¤¡à¤¼à¤¾", "à¤°à¥‰à¤¡ à¤®à¥à¤¡à¤¼à¤¾"],
      "Rod broken": ["rod broken", "rod à¤Ÿà¥‚à¤Ÿà¤¾", "à¤°à¥‰à¤¡ à¤Ÿà¥‚à¤Ÿà¤¾"],
      "Rod scratch": ["rod scratch", "rod à¤–à¤°à¥‹à¤‚à¤š"],
      "Slew ram seal leak": ["slew ram"],
      "Stabilizer ram seal leak": ["stabilizer ram"],
      "Steering ram seal leak": ["steering ram"]
    }
  },

  "Service": {
    keywords: ["service", "à¤¸à¤°à¥à¤µà¤¿à¤¸", "servicing"],
    priority: 3,
    subTitles: {
      "Actual Service": ["actual service", "regular service"],
      "Service Visit": ["service visit", "visit"]
    }
  },

  "Tyre/Battery": {
    keywords: ["tyre", "tire", "battery", "puncture", "à¤Ÿà¤¾à¤¯à¤°", "à¤¬à¥ˆà¤Ÿà¤°à¥€", "à¤ªà¤‚à¤•à¥à¤šà¤°"],
    priority: 6,
    subTitles: {
      "Battery problem": ["battery", "à¤¬à¥ˆà¤Ÿà¤°à¥€", "dead"],
      "Tube joint opened": ["tube joint", "tube à¤–à¥à¤²à¤¾"],
      "Tube puncture": ["tube puncture", "à¤Ÿà¥à¤¯à¥‚à¤¬ à¤ªà¤‚à¤•à¥à¤šà¤°"],
      "Tyre burst": ["burst", "à¤«à¤Ÿà¤¾", "à¤«à¥‚à¤Ÿà¤¾"],
      "Tyre cut": ["tyre cut", "tire cut", "à¤Ÿà¤¾à¤¯à¤° à¤•à¤Ÿà¤¾"],
      "Tyre rubber breaking": ["rubber break", "rubber à¤Ÿà¥‚à¤Ÿ à¤°à¤¹à¤¾"]
    }
  },

  "Under Carriage": {
    keywords: ["under carriage", "track", "roller", "idler", "sprocket", "à¤Ÿà¥à¤°à¥ˆà¤•", "à¤°à¥‹à¤²à¤°"],
    priority: 4,
    subTitles: {
      "Idler wheel leakage": ["idler leak", "à¤†à¤‡à¤¡à¤²à¤° à¤²à¥€à¤•"],
      "Idler wheel noise": ["idler noise", "idler à¤†à¤µà¤¾à¤œ"],
      "Ring gear Crack": ["ring gear", "à¤—à¤¿à¤¯à¤° à¤•à¥à¤°à¥ˆà¤•"],
      "Roller Bent": ["roller bend", "à¤°à¥‹à¤²à¤° à¤®à¥à¤¡à¤¼à¤¾"],
      "Roller leakage": ["roller leak", "à¤°à¥‹à¤²à¤° à¤²à¥€à¤•"],
      "Sprocket Wear": ["sprocket", "à¤¸à¥à¤ªà¥à¤°à¥‰à¤•à¥‡à¤Ÿ"],
      "Track gear Box noise": ["track gear noise"],
      "Track Motor leak": ["track motor", "à¤Ÿà¥à¤°à¥ˆà¤• à¤®à¥‹à¤Ÿà¤°"],
      "Track Shoe bend/Broken": ["track shoe", "shoe à¤Ÿà¥‚à¤Ÿà¤¾"],
      "Track tension yoke,spring broken": ["tension", "spring", "yoke"]
    }
  },

  "PDI": {
    keywords: ["pdi", "à¤ªà¥€à¤¡à¥€à¤†à¤ˆ"],
    priority: 3,
    subTitles: {
      "PDI": ["pdi"]
    }
  },

  "Installation": {
    keywords: ["installation", "install", "à¤‡à¤‚à¤¸à¥à¤Ÿà¤¾à¤²à¥‡à¤¶à¤¨"],
    priority: 3,
    subTitles: {
      "Installation visit": ["installation", "install"]
    }
  },

  "General Visit": {
    keywords: ["visit", "general", "monthly", "à¤µà¤¿à¤œà¤¿à¤Ÿ"],
    priority: 2,
    subTitles: {
      "ASC Visit": ["asc"],
      "BW Visit": ["bw"],
      "General Visit": ["general visit", "visit"],
      "Monthly Visit": ["monthly", "à¤®à¤¹à¥€à¤¨à¥‡"],
      "Number plate fitment": ["number plate", "plate"],
      "Accidental": ["accident", "à¤à¤•à¥à¤¸à¥€à¤¡à¥‡à¤‚à¤Ÿ"]
    }
  },

  "Livelink": {
    keywords: ["livelink", "live link", "à¤²à¤¾à¤‡à¤µà¤²à¤¿à¤‚à¤•"],
    priority: 3,
    subTitles: {
      "Livelink not working": ["livelink", "live link"],
      "Alert": ["alert", "à¤…à¤²à¤°à¥à¤Ÿ"]
    }
  },

  "ECU problem": {
    keywords: ["ecu", "à¤ˆà¤¸à¥€à¤¯à¥‚"],
    priority: 5,
    subTitles: {}
  },

  "Campaign": {
    keywords: ["campaign", "fsi", "à¤•à¥ˆà¤®à¥à¤ªà¥‡à¤¨"],
    priority: 3,
    subTitles: {
      "Campaign Visit": ["campaign"],
      "FSI": ["fsi", "à¤à¤«à¤à¤¸à¤†à¤ˆ"]
    }
  }
};

/* =======================
   IMPROVED HINDI TO ENGLISH TRANSLITERATION
======================= */
const hindiToEnglishMap = {
  // Common words
  'à¤à¤¸à¥€': 'AC',
  'à¤à¤¸à¥€': 'AC',
  'à¤ à¤¸à¥€': 'AC',
  'à¤‡à¤‚à¤œà¤¨': 'engine',
  'à¤¨à¤¹à¥€à¤‚': 'nahi',
  'à¤šà¤²': 'chal',
  'à¤°à¤¹à¥€': 'rahi',
  'à¤°à¤¹à¤¾': 'raha',
  'à¤¹à¥ˆ': 'hai',
  'à¤•à¤¾à¤®': 'kaam',
  'à¤•à¤°': 'kar',
  'à¤•à¤°à¤¤à¥€': 'karti',
  'à¤•à¤°à¤¤à¤¾': 'karta',
  'à¤•à¤°à¤¤à¥‡': 'karte',
  'à¤•à¤°à¤¨à¥€': 'karni',
  'à¤•à¤°à¤¨à¤¾': 'karna',
  'à¤¹à¥‹': 'ho',
  'à¤ à¤‚à¤¡à¤¾': 'thanda',
  'à¤ à¤‚à¤¡à¥€': 'thandi',
  'à¤ à¤‚à¤¡': 'thand',
  'à¤•à¥‚à¤²à¤¿à¤‚à¤—': 'cooling',
  'à¤¬à¤¾à¤¤': 'baat',
  'à¤•à¥à¤¯à¥‹à¤‚': 'kyu',
  'à¤²à¥‡à¤•à¤¿à¤¨': 'lekin',
  'à¤šà¤¾à¤²à¥‚': 'chalu',
  'à¤¬à¤‚à¤¦': 'band',
  'à¤—à¤°à¤®': 'garam',
  'à¤¬à¥à¤°à¥‡à¤•': 'brake',
  'à¤Ÿà¤¾à¤¯à¤°': 'tyre',
  'à¤¬à¥ˆà¤Ÿà¤°à¥€': 'battery',
  'à¤¹à¤¾à¤‡à¤¡à¥à¤°à¥‹à¤²à¤¿à¤•': 'hydraulic',
  'à¤®à¤¶à¥€à¤¨': 'machine',
  'à¤ªà¥à¤°à¥‰à¤¬à¥à¤²à¤®': 'problem',
  'à¤¦à¤¿à¤•à¥à¤•à¤¤': 'dikkat',
  'à¤–à¤°à¤¾à¤¬': 'kharab',
  'à¤µà¤¾à¤°à¤‚à¤Ÿà¥€': 'warranty',
  'à¤¸à¤°à¥à¤µà¤¿à¤¸': 'service',
  
  // Names
  'à¤°à¤¾à¤®': 'Ram',
  'à¤¶à¥à¤¯à¤¾à¤®': 'Shyam',
  'à¤®à¥‹à¤¹à¤¨': 'Mohan',
  'à¤¸à¥‹à¤¹à¤¨': 'Sohan',
  'à¤°à¤µà¤¿': 'Ravi',
  'à¤µà¤¿à¤œà¤¯': 'Vijay',
  'à¤°à¤¾à¤œ': 'Raj',
  'à¤•à¥à¤®à¤¾à¤°': 'Kumar',
  'à¤¸à¤¿à¤‚à¤¹': 'Singh',
  'à¤¶à¤°à¥à¤®à¤¾': 'Sharma',
  'à¤µà¤°à¥à¤®à¤¾': 'Verma',
  'à¤—à¥à¤ªà¥à¤¤à¤¾': 'Gupta',
  'à¤…à¤‚à¤¶à¥': 'Anshu',


  // Starting/Power Issues
  'à¤¸à¥à¤Ÿà¤¾à¤°à¥à¤Ÿ': 'start',
  'à¤¸à¥à¤Ÿà¤¾à¤°à¥à¤Ÿà¤¿à¤‚à¤—': 'starting',
  'à¤¶à¥à¤°à¥‚': 'shuru',
  'à¤šà¤¾à¤²à¥‚': 'chalu',
  'à¤ªà¤¾à¤µà¤°': 'power',
  'à¤¤à¤¾à¤•à¤¤': 'power',
  
  // Heating/Temperature
  'à¤¹à¤¿à¤Ÿ': 'heat',
  'à¤—à¤°à¤®': 'garam',
  'à¤—à¤°à¥à¤®': 'garam',
  'à¤“à¤µà¤°à¤¹à¥€à¤Ÿ': 'overheat',
  'à¤¤à¤¾à¤ªà¤®à¤¾à¤¨': 'temperature',
  
  // Problems/Issues
  'à¤¦à¤¿à¤•à¥à¤•à¤¤': 'dikkat',
  'à¤ªà¤°à¥‡à¤¶à¤¾à¤¨à¥€': 'problem',
  'à¤–à¤°à¤¾à¤¬à¥€': 'kharab',
  'à¤¸à¤®à¤¸à¥à¤¯à¤¾': 'problem',
  'à¤‡à¤¶à¥‚': 'issue',
  
  // Actions
  'à¤°à¤¹à¥€': 'rahi',
  'à¤°à¤¹à¤¾': 'raha',
  'à¤¹à¥‹à¤¨à¥‡': 'hone',
  'à¤¹à¥‹': 'ho',
  'à¤†': 'aa',
  'à¤œà¤¾': 'ja',
  'à¤ªà¤¾': 'pa',
  
  // Common phrases
  'à¤®à¥‡à¤‚': 'mein',
  'à¤¸à¥‡': 'se',
  'à¤•à¥‹': 'ko',
  'à¤•à¤¾': 'ka',
  'à¤•à¥€': 'ki',
  'à¤•à¥‡': 'ke',
};

function transliterateHindiToEnglish(text) {
  if (!text) return text;
  
  let result = text;
  
  // First pass: exact word replacements
  for (const [hindi, english] of Object.entries(hindiToEnglishMap)) {
    const regex = new RegExp(hindi, 'gi');
    result = result.replace(regex, english);
  }
  
  // Second pass: remove remaining Devanagari characters that couldn't be transliterated
  // but keep the ASCII parts
  result = result
    .split(' ')
    .map(word => {
      // If word has both Hindi and English, try to extract English
      if (/[a-zA-Z]/.test(word) && /[\u0900-\u097F]/.test(word)) {
        // Extract ASCII part
        return word.replace(/[\u0900-\u097F]/g, '').trim();
      }
      // If pure Hindi and not in map, keep as is (might be transliterated later)
      if (/[\u0900-\u097F]/.test(word)) {
        return word;
      }
      return word;
    })
    .filter(word => word.length > 0)
    .join(' ');
  
  return result.trim();
}

/* =======================
   SMART FOLLOW-UP QUESTIONS
======================= */
const smartFollowUpQuestions = {
  chassis_unknown: [
    "Koi baat nahi. Aap machine kab se use kar rahe hain?",
    "Machine ka model batayein? JCB 3DX hai ya koi aur?",
    "Machine ki koi aur pehchan batayein jaise registration number?"
  ],
  
  problem_unclear: [
    "Machine kab se band hai?",
    "Kya machine bilkul band hai ya thodi bahut chal rahi hai?",
    "Pichli baar machine kab theek thi?",
    "Machine mein koi aawaz aa rahi hai?",
    "Kya koi smoke ya dhuan aa raha hai?",
    "Kya machine start ho rahi hai?",
    "Engine, hydraulic, AC, electrical ya tyre mein se kya problem hai?"
  ],

  timeline: [
    "Yeh problem kab se hai?",
    "Kya yeh achanak hua ya dheere dheere?",
    "Pichli servicing kab hui thi?"
  ],

  severity: [
    "Kya machine bilkul band hai ya kuch kaam kar rahi hai?",
    "Kya machine chalane mein khatraa hai?",
    "Kya machine se koi leak ho raha hai?"
  ],

  ac_specific: [
    "AC bilkul nahi chal rahi ya sirf thanda nahi kar rahi?",
    "AC chalu hoti hai lekin thanda nahi karti?",
    "Kya AC on hone par koi awaaz aati hai?"
  ]
};

/* =======================
   ENHANCED COMPLAINT DETECTION WITH PRIORITY
======================= */
function detectComplaintIntent(text, previousContext = {}) {
  if (!text) return null;

  const textLower = text.toLowerCase();
  const matches = [];
  const confidenceScores = {};

  console.log("ðŸ” ANALYZING TEXT FOR COMPLAINT:", textLower);

  // Special AC detection - very high priority
  const acPatterns = [
    /\bac\b/gi,
    /\bà¤à¤¸à¥€\b/gi,
    /\bà¤à¤¸à¥€\b/gi,
    /\bà¤\.à¤¸à¥€\b/gi,
    /\bà¤\s+à¤¸à¥€\b/gi,
    /\bcooling\b/gi,
    /\bà¤•à¥‚à¤²à¤¿à¤‚à¤—\b/gi,
    /\bà¤ à¤‚à¤¡à¤¾\b/gi,
    /\bà¤ à¤‚à¤¡à¥€\b/gi,
    /\bà¤ à¤‚à¤¡\b/gi,
    /\bthanda\b/gi,
    /\bthand\b/gi
  ];

  let hasACMention = false;
  for (const pattern of acPatterns) {
    if (pattern.test(text)) {
      hasACMention = true;
      console.log("   âœ… AC pattern matched:", pattern);
      break;
    }
  }

  // If AC mentioned, give it top priority
  if (hasACMention) {
    console.log("ðŸŽ¯ AC DETECTED - High Priority Match!");
    matches.push("AC System");
    confidenceScores["AC System"] = 100;
  }

  // Check against all other complaint categories
  for (const [title, data] of Object.entries(complaintMap)) {
    if (title === "AC System" && hasACMention) continue;

    let matchScore = 0;
    let matchedKeywords = [];
    const priority = data.priority || 1;

    // Check main keywords
    for (const keyword of data.keywords) {
      const regex = new RegExp(`\\b${keyword}\\b`, 'gi');
      if (regex.test(text)) {
        matchScore += (2 * priority);
        matchedKeywords.push(keyword);
      }
    }

    // Check sub-title keywords
    if (data.subTitles) {
      for (const [subTitle, subKeywords] of Object.entries(data.subTitles)) {
        for (const subKeyword of subKeywords) {
          const regex = new RegExp(`\\b${subKeyword}\\b`, 'gi');
          if (regex.test(text)) {
            matchScore += (3 * priority);
            matchedKeywords.push(subKeyword);
          }
        }
      }
    }

    if (matchScore > 0 && title !== "AC System") {
      matches.push(title);
      confidenceScores[title] = matchScore;
    }
  }

  if (matches.length === 0) {
    console.log("   âŒ No complaint categories matched");
    return null;
  }

  // Sort by confidence score
  matches.sort((a, b) => confidenceScores[b] - confidenceScores[a]);

  const topScore = confidenceScores[matches[0]];
  const confidence = topScore >= 100 ? 0.99 : 
                     topScore >= 50 ? 0.95 : 
                     topScore >= 20 ? 0.85 : 
                     topScore >= 10 ? 0.75 : 0.6;

  console.log("ðŸ” Complaint Detection Results:");
  console.log("   Matches:", matches);
  console.log("   Scores:", confidenceScores);
  console.log("   Top Match:", matches[0], "Score:", topScore, "Confidence:", confidence);

  return {
    primary: matches[0],
    secondary: matches.slice(1, 3),
    confidence: confidence,
    matchedKeywords: matches.map(m => ({
      title: m,
      score: confidenceScores[m]
    }))
  };
}

/* =======================
   ENHANCED SUB-COMPLAINT DETECTION
======================= */
function detectSubComplaint(mainComplaint, text) {
  if (!mainComplaint || !complaintMap[mainComplaint]) return null;

  const subTitles = complaintMap[mainComplaint].subTitles;
  if (!subTitles || Object.keys(subTitles).length === 0) {
    return { subTitle: "Other", confidence: 1.0 };
  }

  const textLower = text.toLowerCase();
  let bestMatch = null;
  let highestScore = 0;

  console.log(`ðŸ” Detecting sub-complaint for: ${mainComplaint}`);
  console.log(`   Text to analyze: "${textLower}"`);

  // ========== SPECIAL HANDLING FOR AC SYSTEM ==========
  if (mainComplaint === "AC System") {
    const notWorkingPatterns = [
      /à¤¨à¤¹à¥€à¤‚\s+à¤šà¤²/gi, /band\b/gi, /à¤¬à¤‚à¤¦\b/gi, /à¤•à¤¾à¤®\s+à¤¨à¤¹à¥€à¤‚/gi,
      /work\s+à¤¨à¤¹à¥€à¤‚/gi, /à¤šà¤¾à¤²à¥‚\s+à¤¨à¤¹à¥€à¤‚/gi, /start\s+à¤¨à¤¹à¥€à¤‚/gi,
      /on\s+à¤¨à¤¹à¥€à¤‚/gi, /kaam\s+nahi/gi, /chalu\s+nahi/gi
    ];

    const coolingPatterns = [
      /à¤ à¤‚à¤¡à¤¾\s+à¤¨à¤¹à¥€à¤‚/gi, /à¤ à¤‚à¤¡à¥€\s+à¤¨à¤¹à¥€à¤‚/gi, /à¤ à¤‚à¤¡\s+à¤¨à¤¹à¥€à¤‚/gi,
      /à¤•à¥‚à¤²à¤¿à¤‚à¤—\s+à¤¨à¤¹à¥€à¤‚/gi, /cool\s+à¤¨à¤¹à¥€à¤‚/gi, /cooling\s+à¤¨à¤¹à¥€à¤‚/gi,
      /thanda\s+nahi/gi, /thand\s+nahi/gi, /à¤—à¤°à¤®\b/gi,
      /garam\b/gi, /heat\b/gi, /à¤šà¤¾à¤²à¥‚\s+à¤¹à¥ˆ\s+à¤²à¥‡à¤•à¤¿à¤¨/gi,
      /chalu\s+hai\s+lekin/gi, /on\s+hai\s+lekin/gi,
      /chal\s+rahi\s+lekin/gi, /à¤šà¤²\s+à¤°à¤¹à¥€\s+à¤²à¥‡à¤•à¤¿à¤¨/gi
    ];

    let coolingScore = 0, notWorkingScore = 0;

    for (const pattern of coolingPatterns) {
      if (pattern.test(textLower)) {
        coolingScore += 10;
        console.log(`   âœ… Cooling pattern matched: ${pattern}`);
      }
    }

    for (const pattern of notWorkingPatterns) {
      if (pattern.test(textLower)) {
        notWorkingScore += 10;
        console.log(`   âœ… Not working pattern matched: ${pattern}`);
      }
    }

    console.log(`   Cooling Score: ${coolingScore}, Not Working Score: ${notWorkingScore}`);

    if (coolingScore > notWorkingScore) {
      console.log("   âœ… AC NOT COOLING detected");
      return { subTitle: "AC not Cooling", confidence: 0.95 };
    }
    
    if (notWorkingScore > 0) {
      console.log("   âœ… AC NOT WORKING detected");
      return { subTitle: "AC not Working", confidence: 0.95 };
    }

    console.log("   âš ï¸ AC mentioned but no specific sub-complaint, defaulting to 'AC not Cooling'");
    return { subTitle: "AC not Cooling", confidence: 0.7 };
  }

  // ========== SPECIAL HANDLING FOR ENGINE ==========
  if (mainComplaint === "Engine") {
    const startingPatterns = [
      /\bstart\b/gi, /à¤¸à¥à¤Ÿà¤¾à¤°à¥à¤Ÿ/gi, /à¤¶à¥à¤°à¥‚/gi, /\bchalu\s+nahi/gi,
      /à¤šà¤¾à¤²à¥‚\s+à¤¨à¤¹à¥€à¤‚/gi, /\bself\b/gi, /à¤¸à¥‡à¤²à¥à¤«/gi, /\bstarter\b/gi,
      /à¤¸à¥à¤Ÿà¤¾à¤°à¥à¤Ÿà¤°/gi, /\bdikkat\b/gi, /à¤¦à¤¿à¤•à¥à¤•à¤¤/gi, /à¤¹à¥‹à¤¨à¥‡\s+à¤®à¥‡à¤‚/gi,
      /\bhone\s+mein/gi, /\bstarting\b/gi, /à¤¸à¥à¤Ÿà¤¾à¤°à¥à¤Ÿà¤¿à¤‚à¤—/gi,
      /\bkick\b/gi, /start\s+problem/gi, /start\s+à¤¨à¤¹à¥€à¤‚/gi
    ];

    const heatingPatterns = [
      /\bheat\b/gi, /\bhit\b/gi, /à¤¹à¤¿à¤Ÿ/gi, /\bgaram\b/gi,
      /à¤—à¤°à¤®/gi, /à¤—à¤°à¥à¤®/gi, /\boverheat/gi, /à¤“à¤µà¤°à¤¹à¥€à¤Ÿ/gi,
      /à¤¤à¤¾à¤ªà¤®à¤¾à¤¨/gi, /\bhot\b/gi, /à¤—à¤°à¥à¤®à¥€/gi, /à¤—à¤°à¤®à¥€/gi,
      /à¤—à¤°à¥à¤®\s+à¤¹à¥‹/gi, /garam\s+ho/gi
    ];

    const smokePatterns = [
      /\bsmoke\b/gi, /à¤§à¥à¤†/gi, /à¤§à¥à¤‚à¤†/gi, /\bdhuan\b/gi,
      /à¤•à¤¾à¤²à¤¾\s+à¤§à¥à¤†/gi, /black\s+smoke/gi, /white\s+smoke/gi,
      /à¤¸à¤«à¥‡à¤¦\s+à¤§à¥à¤†/gi
    ];

    const noisePatterns = [
      /\bnoise\b/gi, /\bsound\b/gi, /à¤†à¤µà¤¾à¤œ/gi, /à¤¶à¥‹à¤°/gi,
      /\bawaaz\b/gi, /à¤–à¤¡à¤¼à¤–à¤¡à¤¼/gi, /à¤†à¤µà¤¾à¤œ\s+à¤†/gi, /sound\s+aa/gi
    ];

    let startingScore = 0, heatingScore = 0, smokeScore = 0, noiseScore = 0;

    for (const pattern of startingPatterns) {
      if (pattern.test(textLower)) {
        startingScore += 15;
        console.log(`   âœ… Starting pattern matched: ${pattern}`);
      }
    }

    for (const pattern of heatingPatterns) {
      if (pattern.test(textLower)) {
        heatingScore += 15;
        console.log(`   âœ… Heating pattern matched: ${pattern}`);
      }
    }

    for (const pattern of smokePatterns) {
      if (pattern.test(textLower)) {
        smokeScore += 15;
        console.log(`   âœ… Smoke pattern matched: ${pattern}`);
      }
    }

    for (const pattern of noisePatterns) {
      if (pattern.test(textLower)) {
        noiseScore += 12;
        console.log(`   âœ… Noise pattern matched: ${pattern}`);
      }
    }

    console.log(`   Starting: ${startingScore}, Heating: ${heatingScore}, Smoke: ${smokeScore}, Noise: ${noiseScore}`);

    if (startingScore >= 15) {
      console.log("   âœ… STARTING TROUBLE detected");
      return { subTitle: "Starting trouble", confidence: 0.95 };
    }
    if (heatingScore >= 15) {
      console.log("   âœ… ENGINE OVERHEATING detected");
      return { subTitle: "Engine Over heating", confidence: 0.95 };
    }
    if (smokeScore >= 15) {
      console.log("   âœ… SMOKE PROBLEM detected");
      return { subTitle: "Smoke problem", confidence: 0.95 };
    }
    if (noiseScore >= 12) {
      console.log("   âœ… ABNORMAL NOISE detected");
      return { subTitle: "Abnormal Noise", confidence: 0.90 };
    }
  }

  // ========== SPECIAL HANDLING FOR HYDRAULIC ==========
  if (mainComplaint === "Hydraulic") {
    const pressurePatterns = [
      /\bpressure\b/gi, /à¤ªà¥à¤°à¥‡à¤¶à¤°/gi, /\bà¤•à¤®\b/gi, /\blow\b/gi,
      /pressure\s+down/gi, /pressure\s+kam/gi, /à¤•à¤®\s+pressure/gi
    ];

    const leakPatterns = [
      /\bleak\b/gi, /à¤²à¥€à¤•/gi, /\bleakage\b/gi, /oil\s+leak/gi,
      /à¤¤à¥‡à¤²\s+à¤²à¥€à¤•/gi, /pump\s+leak/gi, /à¤ªà¤‚à¤ª\s+à¤²à¥€à¤•/gi
    ];

    const slowPatterns = [
      /\bslow\b/gi, /à¤§à¥€à¤°à¥‡/gi, /à¤§à¥€à¤®à¥€/gi, /\bslowly\b/gi,
      /à¤•à¤®\s+speed/gi, /power\s+kam/gi, /à¤¤à¤¾à¤•à¤¤\s+à¤¨à¤¹à¥€à¤‚/gi,
      /performance\s+low/gi
    ];

    const noisePatterns = [
      /\bnoise\b/gi, /\bsound\b/gi, /à¤†à¤µà¤¾à¤œ/gi, /à¤¶à¥‹à¤°/gi,
      /pump\s+noise/gi, /pump\s+à¤†à¤µà¤¾à¤œ/gi
    ];

    let pressureScore = 0, leakScore = 0, slowScore = 0, noiseScore = 0;

    for (const pattern of pressurePatterns) {
      if (pattern.test(textLower)) {
        pressureScore += 15;
        console.log(`   âœ… Pressure pattern matched: ${pattern}`);
      }
    }

    for (const pattern of leakPatterns) {
      if (pattern.test(textLower)) {
        leakScore += 15;
        console.log(`   âœ… Leak pattern matched: ${pattern}`);
      }
    }

    for (const pattern of slowPatterns) {
      if (pattern.test(textLower)) {
        slowScore += 15;
        console.log(`   âœ… Slow working pattern matched: ${pattern}`);
      }
    }

    for (const pattern of noisePatterns) {
      if (pattern.test(textLower)) {
        noiseScore += 12;
        console.log(`   âœ… Noise pattern matched: ${pattern}`);
      }
    }

    console.log(`   Pressure: ${pressureScore}, Leak: ${leakScore}, Slow: ${slowScore}, Noise: ${noiseScore}`);

    if (pressureScore >= 15) {
      console.log("   âœ… PRESSURE DOWN detected");
      return { subTitle: "Pressure down", confidence: 0.95 };
    }
    if (slowScore >= 15) {
      console.log("   âœ… SLOW WORKING detected");
      return { subTitle: "Machine performance low/Slow working", confidence: 0.95 };
    }
    if (leakScore >= 15) {
      // Check for specific leak types
      if (/pump/gi.test(textLower)) {
        console.log("   âœ… HYDRAULIC PUMP LEAK detected");
        return { subTitle: "Hydraulic pump leak", confidence: 0.95 };
      }
      console.log("   âœ… GENERAL LEAK detected");
      return { subTitle: "Hydraulic pump leak", confidence: 0.85 };
    }
    if (noiseScore >= 12) {
      if (/pump/gi.test(textLower)) {
        console.log("   âœ… PUMP NOISE detected");
        return { subTitle: "Hydraulic pump Noise", confidence: 0.95 };
      }
      console.log("   âœ… ABNORMAL SOUND detected");
      return { subTitle: "Abnormal sound", confidence: 0.90 };
    }
  }

  // ========== SPECIAL HANDLING FOR ELECTRICAL ==========
  if (mainComplaint === "Electrical Complaint") {
    const batteryPatterns = [
      /\bbattery\b/gi, /à¤¬à¥ˆà¤Ÿà¤°à¥€/gi, /\bdead\b/gi, /à¤–à¤¤à¥à¤®/gi,
      /\bdischarge\b/gi, /charge\s+nahi/gi, /à¤šà¤¾à¤°à¥à¤œ\s+à¤¨à¤¹à¥€à¤‚/gi,
      /battery\s+down/gi, /battery\s+à¤–à¤¤à¥à¤®/gi
    ];

    const startingPatterns = [
      /\bstart\b/gi, /à¤¸à¥à¤Ÿà¤¾à¤°à¥à¤Ÿ/gi, /\bself\b/gi, /à¤¸à¥‡à¤²à¥à¤«/gi,
      /\bstarter\b/gi, /à¤¸à¥à¤Ÿà¤¾à¤°à¥à¤Ÿà¤°/gi, /start\s+problem/gi,
      /start\s+à¤¨à¤¹à¥€à¤‚/gi, /à¤šà¤¾à¤²à¥‚\s+à¤¨à¤¹à¥€à¤‚/gi
    ];

    const lightPatterns = [
      /\blight\b/gi, /à¤²à¤¾à¤‡à¤Ÿ/gi, /light\s+not\s+working/gi,
      /à¤²à¤¾à¤‡à¤Ÿ\s+à¤¨à¤¹à¥€à¤‚/gi, /light\s+glow/gi, /à¤²à¤¾à¤‡à¤Ÿ\s+à¤œà¤²/gi
    ];

    const wiringPatterns = [
      /\bwiring\b/gi, /à¤µà¤¾à¤¯à¤°à¤¿à¤‚à¤—/gi, /\bwire\b/gi, /à¤¤à¤¾à¤°/gi,
      /wire\s+problem/gi, /wiring\s+issue/gi
    ];

    let batteryScore = 0, startingScore = 0, lightScore = 0, wiringScore = 0;

    for (const pattern of batteryPatterns) {
      if (pattern.test(textLower)) {
        batteryScore += 15;
        console.log(`   âœ… Battery pattern matched: ${pattern}`);
      }
    }

    for (const pattern of startingPatterns) {
      if (pattern.test(textLower)) {
        startingScore += 15;
        console.log(`   âœ… Starting pattern matched: ${pattern}`);
      }
    }

    for (const pattern of lightPatterns) {
      if (pattern.test(textLower)) {
        lightScore += 15;
        console.log(`   âœ… Light pattern matched: ${pattern}`);
      }
    }

    for (const pattern of wiringPatterns) {
      if (pattern.test(textLower)) {
        wiringScore += 12;
        console.log(`   âœ… Wiring pattern matched: ${pattern}`);
      }
    }

    console.log(`   Battery: ${batteryScore}, Starting: ${startingScore}, Light: ${lightScore}, Wiring: ${wiringScore}`);

    if (batteryScore >= 15) {
      console.log("   âœ… BATTERY PROBLEM detected");
      return { subTitle: "Battery problem", confidence: 0.95 };
    }
    if (startingScore >= 15) {
      console.log("   âœ… STARTING TROUBLE detected");
      return { subTitle: "Starting trouble", confidence: 0.95 };
    }
    if (lightScore >= 15) {
      if (/glow/gi.test(textLower)) {
        console.log("   âœ… LIGHT GLOWING PROBLEM detected");
        return { subTitle: "Light glowing problem", confidence: 0.95 };
      }
      console.log("   âœ… LIGHT NOT WORKING detected");
      return { subTitle: "Light not working", confidence: 0.95 };
    }
    if (wiringScore >= 12) {
      console.log("   âœ… WIRING PROBLEM detected");
      return { subTitle: "Wiring problem", confidence: 0.90 };
    }
  }

  // ========== SPECIAL HANDLING FOR TYRE/BATTERY ==========
  if (mainComplaint === "Tyre/Battery") {
    const puncturePatterns = [
      /\bpuncture\b/gi, /à¤ªà¤‚à¤•à¥à¤šà¤°/gi, /tube\s+puncture/gi,
      /à¤Ÿà¥à¤¯à¥‚à¤¬\s+à¤ªà¤‚à¤•à¥à¤šà¤°/gi, /à¤«à¥‚à¤Ÿà¤¾/gi, /à¤«à¤Ÿà¤¾/gi
    ];

    const burstPatterns = [
      /\bburst\b/gi, /à¤«à¤Ÿà¤¾/gi, /à¤«à¥‚à¤Ÿà¤¾/gi, /tyre\s+burst/gi,
      /à¤Ÿà¤¾à¤¯à¤°\s+à¤«à¤Ÿà¤¾/gi, /à¤Ÿà¤¾à¤¯à¤°\s+à¤«à¥‚à¤Ÿà¤¾/gi
    ];

    const batteryPatterns = [
      /\bbattery\b/gi, /à¤¬à¥ˆà¤Ÿà¤°à¥€/gi, /\bdead\b/gi, /à¤–à¤¤à¥à¤®/gi,
      /battery\s+problem/gi, /battery\s+down/gi
    ];

    const cutPatterns = [
      /\bcut\b/gi, /à¤•à¤Ÿà¤¾/gi, /tyre\s+cut/gi, /à¤Ÿà¤¾à¤¯à¤°\s+à¤•à¤Ÿà¤¾/gi
    ];

    let punctureScore = 0, burstScore = 0, batteryScore = 0, cutScore = 0;

    for (const pattern of puncturePatterns) {
      if (pattern.test(textLower)) {
        punctureScore += 15;
        console.log(`   âœ… Puncture pattern matched: ${pattern}`);
      }
    }

    for (const pattern of burstPatterns) {
      if (pattern.test(textLower)) {
        burstScore += 15;
        console.log(`   âœ… Burst pattern matched: ${pattern}`);
      }
    }

    for (const pattern of batteryPatterns) {
      if (pattern.test(textLower)) {
        batteryScore += 15;
        console.log(`   âœ… Battery pattern matched: ${pattern}`);
      }
    }

    for (const pattern of cutPatterns) {
      if (pattern.test(textLower)) {
        cutScore += 12;
        console.log(`   âœ… Cut pattern matched: ${pattern}`);
      }
    }

    console.log(`   Puncture: ${punctureScore}, Burst: ${burstScore}, Battery: ${batteryScore}, Cut: ${cutScore}`);

    if (batteryScore >= 15) {
      console.log("   âœ… BATTERY PROBLEM detected");
      return { subTitle: "Battery problem", confidence: 0.95 };
    }
    if (punctureScore >= 15) {
      console.log("   âœ… TUBE PUNCTURE detected");
      return { subTitle: "Tube puncture", confidence: 0.95 };
    }
    if (burstScore >= 15) {
      console.log("   âœ… TYRE BURST detected");
      return { subTitle: "Tyre burst", confidence: 0.95 };
    }
    if (cutScore >= 12) {
      console.log("   âœ… TYRE CUT detected");
      return { subTitle: "Tyre cut", confidence: 0.90 };
    }
  }

  // ========== SPECIAL HANDLING FOR TRANSMISSION/AXLE ==========
  if (mainComplaint === "Transmission/Axle components") {
    const brakePatterns = [
      /\bbrake\b/gi, /à¤¬à¥à¤°à¥‡à¤•/gi, /brake\s+problem/gi,
      /à¤¬à¥à¤°à¥‡à¤•\s+à¤¨à¤¹à¥€à¤‚/gi, /brake\s+fail/gi
    ];

    const gearPatterns = [
      /\bgear\b/gi, /à¤—à¤¿à¤¯à¤°/gi, /gear\s+problem/gi, /à¤—à¤¿à¤¯à¤°\s+à¤¬à¥‰à¤•à¥à¤¸/gi,
      /gear\s+hard/gi, /gear\s+à¤¸à¤–à¥à¤¤/gi, /gearbox/gi
    ];

    const reversePatterns = [
      /\breverse\b/gi, /à¤°à¤¿à¤µà¤°à¥à¤¸/gi, /\bforward\b/gi,
      /reverse\s+forward/gi, /à¤†à¤—à¥‡\s+à¤ªà¥€à¤›à¥‡/gi
    ];

    const noisePatterns = [
      /\bnoise\b/gi, /\bsound\b/gi, /à¤†à¤µà¤¾à¤œ/gi, /à¤¶à¥‹à¤°/gi
    ];

    let brakeScore = 0, gearScore = 0, reverseScore = 0, noiseScore = 0;

    for (const pattern of brakePatterns) {
      if (pattern.test(textLower)) {
        brakeScore += 15;
        console.log(`   âœ… Brake pattern matched: ${pattern}`);
      }
    }

    for (const pattern of gearPatterns) {
      if (pattern.test(textLower)) {
        gearScore += 15;
        console.log(`   âœ… Gear pattern matched: ${pattern}`);
      }
    }

    for (const pattern of reversePatterns) {
      if (pattern.test(textLower)) {
        reverseScore += 15;
        console.log(`   âœ… Reverse/Forward pattern matched: ${pattern}`);
      }
    }

    for (const pattern of noisePatterns) {
      if (pattern.test(textLower)) {
        noiseScore += 12;
        console.log(`   âœ… Noise pattern matched: ${pattern}`);
      }
    }

    console.log(`   Brake: ${brakeScore}, Gear: ${gearScore}, Reverse: ${reverseScore}, Noise: ${noiseScore}`);

    if (brakeScore >= 15) {
      console.log("   âœ… BRAKE PROBLEM detected");
      return { subTitle: "Brake problem", confidence: 0.95 };
    }
    if (gearScore >= 15) {
      if (/hard/gi.test(textLower) || /à¤¸à¤–à¥à¤¤/gi.test(textLower)) {
        console.log("   âœ… GEAR HARD detected");
        return { subTitle: "Gear hard", confidence: 0.95 };
      }
      console.log("   âœ… GEAR BOX PROBLEM detected");
      return { subTitle: "Gear box problem", confidence: 0.95 };
    }
    if (reverseScore >= 15) {
      console.log("   âœ… REVERSE FORWARD ISSUE detected");
      return { subTitle: "Reverse forward issue", confidence: 0.95 };
    }
    if (noiseScore >= 12) {
      console.log("   âœ… ABNORMAL SOUND detected");
      return { subTitle: "Abnormal sound Transmission/Axle", confidence: 0.90 };
    }
  }

  // ========== SPECIAL HANDLING FOR RAM/CYLINDER ==========
  if (mainComplaint === "Ram/Cylinder") {
    const leakPatterns = [
      /\bleak\b/gi, /à¤²à¥€à¤•/gi, /seal\s+leak/gi, /à¤¸à¥€à¤²\s+à¤²à¥€à¤•/gi,
      /ram\s+leak/gi, /à¤°à¤¾à¤®\s+à¤²à¥€à¤•/gi
    ];

    const bendPatterns = [
      /\bbend\b/gi, /à¤®à¥à¤¡à¤¼à¤¾/gi, /rod\s+bend/gi, /à¤°à¥‰à¤¡\s+à¤®à¥à¤¡à¤¼à¤¾/gi,
      /bent/gi
    ];

    const brokenPatterns = [
      /\bbroken\b/gi, /à¤Ÿà¥‚à¤Ÿà¤¾/gi, /rod\s+broken/gi, /à¤°à¥‰à¤¡\s+à¤Ÿà¥‚à¤Ÿà¤¾/gi,
      /à¤Ÿà¥‚à¤Ÿ\s+à¤—à¤¯à¤¾/gi
    ];

    let leakScore = 0, bendScore = 0, brokenScore = 0;

    for (const pattern of leakPatterns) {
      if (pattern.test(textLower)) {
        leakScore += 15;
        console.log(`   âœ… Leak pattern matched: ${pattern}`);
      }
    }

    for (const pattern of bendPatterns) {
      if (pattern.test(textLower)) {
        bendScore += 15;
        console.log(`   âœ… Bend pattern matched: ${pattern}`);
      }
    }

    for (const pattern of brokenPatterns) {
      if (pattern.test(textLower)) {
        brokenScore += 15;
        console.log(`   âœ… Broken pattern matched: ${pattern}`);
      }
    }

    console.log(`   Leak: ${leakScore}, Bend: ${bendScore}, Broken: ${brokenScore}`);

    if (brokenScore >= 15) {
      console.log("   âœ… ROD BROKEN detected");
      return { subTitle: "Rod broken", confidence: 0.95 };
    }
    if (bendScore >= 15) {
      console.log("   âœ… ROD BEND detected");
      return { subTitle: "Rod bend", confidence: 0.95 };
    }
    if (leakScore >= 15) {
      // Check for specific ram types
      if (/boom/gi.test(textLower)) {
        console.log("   âœ… BOOM RAM SEAL LEAK detected");
        return { subTitle: "Boom ram seal leak", confidence: 0.95 };
      }
      if (/bucket/gi.test(textLower)) {
        console.log("   âœ… BUCKET RAM SEAL LEAK detected");
        return { subTitle: "bucket ram seal leak", confidence: 0.95 };
      }
      if (/dipper/gi.test(textLower)) {
        console.log("   âœ… DIPPER RAM SEAL LEAK detected");
        return { subTitle: "Dipper ram seal leak", confidence: 0.95 };
      }
      console.log("   âœ… RAM LEAK detected");
      return { subTitle: "Ram leak", confidence: 0.85 };
    }
  }

  // ========== REGULAR SUB-COMPLAINT DETECTION FOR ALL CATEGORIES ==========
  for (const [subTitle, keywords] of Object.entries(subTitles)) {
    let score = 0;
    let matchedCount = 0;

    for (const keyword of keywords) {
      const regex = new RegExp(`\\b${keyword}\\b`, 'gi');
      if (regex.test(textLower)) {
        score += (keyword.length * 2);
        matchedCount++;
        console.log(`   âœ… Keyword matched for "${subTitle}": ${keyword}`);
      }
    }

    console.log(`   Sub-title: ${subTitle}, Score: ${score}, Matches: ${matchedCount}`);

    if (score > highestScore) {
      highestScore = score;
      bestMatch = subTitle;
    }
  }

  if (bestMatch) {
    const confidence = highestScore >= 20 ? 0.95 : 
                      highestScore >= 10 ? 0.85 : 0.7;
    console.log(`   âœ… Best match: ${bestMatch} (confidence: ${confidence})`);
    return { subTitle: bestMatch, confidence: confidence };
  }

  console.log("   âš ï¸ No specific sub-complaint detected, using 'Other'");
  return { subTitle: "Other", confidence: 0.5 };
}

/* =======================
   SMART QUESTION SELECTOR
======================= */
function getSmartFollowUp(context) {
  const { step, attemptCount, lastIntent, customerData, confusionType } = context;

  if (step === 'ask_identifier' && attemptCount >= 2) {
    return smartFollowUpQuestions.chassis_unknown[attemptCount % smartFollowUpQuestions.chassis_unknown.length];
  }

  if (step === 'ask_complaint' && attemptCount >= 1) {
    return smartFollowUpQuestions.problem_unclear[attemptCount % smartFollowUpQuestions.problem_unclear.length];
  }

  if (lastIntent === 'AC System' && attemptCount === 0) {
    return smartFollowUpQuestions.ac_specific[0];
  }

  if (lastIntent && attemptCount === 0) {
    return smartFollowUpQuestions.timeline[0];
  }

  return null;
}

/* =======================
   GENERATE SUB-COMPLAINT QUESTION
======================= */
function generateSubComplaintQuestion(mainComplaint) {
  const data = complaintMap[mainComplaint];
  if (!data || !data.subTitles || Object.keys(data.subTitles).length === 0) {
    return null;
  }

  const questions = {
    "AC System": "AC mein exactly kya problem hai? AC bilkul nahi chal rahi hai ya AC chalu hai lekin thanda nahi kar rahi?",
    "Engine": "Engine mein exactly kya problem hai? Overheating, smoke, noise ya start mein dikkat?",
    "Hydraulic": "Hydraulic mein kya issue hai? Pressure kam hai, leak hai ya machine slow chal rahi hai?",
    "Electrical Complaint": "Electrical mein kya problem hai? Battery, starter, light ya wiring?",
    "Tyre/Battery": "Tyre puncture hai, phatta hai ya battery ki problem hai?",
    "Transmission/Axle components": "Gear mein problem hai, brake mein ya reverse forward mein?",
    "Ram/Cylinder": "Ram ya cylinder mein leak hai, rod bend hai ya kuch aur?",
    "Hose": "Hose cut hai ya leak hai?",
    "Under Carriage": "Track, roller ya idler mein problem hai?",
    "Body Work": "Body mein kya problem hai? Crack, leak ya noise?",
    "Cabin": "Cabin mein door, glass, seat ya aur kuch?",
    "Fabrication part": "Kaunsa part crack hua hai? Boom, bucket, chassis ya aur kuch?",
    "Attachment": "Attachment mein kya problem hai?"
  };

  return questions[mainComplaint] || `${mainComplaint} mein exactly kya problem hai? Thoda detail mein batayein.`;
}

/* =======================
   UTILITY FUNCTIONS
======================= */
function detectBranchAndOutlet(city) {
  if (!city) return { branch: "NA", outlet: "NA", cityCode: "NA" };
  const normalized = city.toLowerCase().trim();
  const result = cityToBranchMap[normalized];
  return result || { branch: "NA", outlet: "NA", cityCode: "NA" };
}

async function fetchCustomerFromExternal({ phone, chassisNo }) {
  try {
    let apiUrl = null;

    if (phone && phone.length === 10) {
      apiUrl = `${EXTERNAL_API_BASE}/get_machine_by_phone_no.php?phone_no=${phone}`;
    } else if (chassisNo && chassisNo.length >= 4) {
      apiUrl = `${EXTERNAL_API_BASE}/get_machine_by_machine_no.php?machine_no=${chassisNo}`;
    }

    if (!apiUrl) {
      console.log("âš ï¸  No valid identifier for external API");
      return null;
    }

    console.log(`ðŸŒ Calling external API: ${apiUrl}`);

    const response = await axios.get(apiUrl, {
      timeout: API_TIMEOUT,
      headers: API_HEADERS,
      validateStatus: (status) => status < 500,
    });

    if (response.status !== 200) {
      console.log(`âš ï¸  External API returned status: ${response.status}`);
      return null;
    }

    const apiResponse = response.data;

    if (!apiResponse || apiResponse.status !== 1 || !apiResponse.data) {
      console.log("âš ï¸  External API returned invalid response");
      return null;
    }

    const customerData = apiResponse.data;

    const normalized = {
      chassisNo: customerData.machine_no || chassisNo || "Unknown",
      phone: customerData.customer_phone_no || phone || "Unknown",
      name: customerData.customer_name || "Unknown",
      city: customerData.city || "Unknown",
      model: customerData.machine_model || "Unknown",
      subModel: customerData.sub_model || "NA",
      machineType: customerData.machine_type || "Unknown",
      businessPartnerCode: customerData.business_partner_code || "NA",
      purchaseDate:
        customerData.purchase_date || customerData.installation_date || "NA",
      installationDate: customerData.installation_date || "NA",
      job_close_lat: customerData.job_close_lat || "0.000000",
      job_close_lng: customerData.job_close_lng || "0.000000",
      job_open_lat: customerData.job_open_lat || "0.000000",
      job_open_lng: customerData.job_open_lng || "0.000000",
      source: "EXTERNAL_API",
    };

    if (normalized.chassisNo === "Unknown" && normalized.phone === "Unknown") {
      console.log("âš ï¸  External API data missing both chassis and phone");
      return null;
    }

    console.log("âœ… External API returned valid customer data:", normalized);
    return normalized;
  } catch (error) {
    if (error.code === "ECONNABORTED") {
      console.error("â±ï¸  External API timeout:", error.message);
    } else if (error.code === "ECONNREFUSED") {
      console.error("ðŸ”Œ External API connection refused:", error.message);
    } else {
      console.error("âŒ External API error:", error.message);
    }
    return null;
  }
}

async function submitComplaintToExternal(complaintData) {
  try {
    const enhancedData = {
      ...complaintData,
      job_close_lat: complaintData.job_close_lat || "0.000000",
      job_close_lng: complaintData.job_close_lng || "0.000000",
      job_open_lat: complaintData.job_open_lat || "0.000000",
      job_open_lng: complaintData.job_open_lng || "0.000000",
      complaint_details: transliterateHindiToEnglish(complaintData.complaint_details || "")
    };

    console.log(
      `ðŸŒ Submitting complaint to external API: ${COMPLAINT_API_URL}`,
    );
    console.log(
      "ðŸ“¦ Enhanced complaint payload:",
      JSON.stringify(enhancedData, null, 2),
    );

    const response = await axios.post(COMPLAINT_API_URL, enhancedData, {
      timeout: API_TIMEOUT,
      headers: {
        "Content-Type": "application/json",
        JCBSERVICEAPI: "MakeInJcb",
      },
      validateStatus: (status) => status < 500,
    });

    console.log(`ðŸ“¨ External API response status: ${response.status}`);
    console.log(
      "ðŸ“¨ External API response data:",
      JSON.stringify(response.data, null, 2),
    );

    if (response.status !== 200) {
      console.log(
        `âš ï¸  External complaint API returned non-200 status: ${response.status}`,
      );
      return {
        success: false,
        error: `HTTP ${response.status}`,
        data: response.data,
      };
    }

    const apiResponse = response.data;

    if (!apiResponse || apiResponse.status !== 1) {
      console.log(
        "âš ï¸  External API rejected complaint:",
        apiResponse?.message || "Unknown error",
      );
      return {
        success: false,
        error: apiResponse?.message || "External API rejected complaint",
        data: apiResponse,
      };
    }

    let sapId = null;
    if (apiResponse.data) {
      sapId =
        apiResponse.data.complaint_sap_id ||
        apiResponse.data.sap_id ||
        apiResponse.data.complaintSapId ||
        apiResponse.data.id ||
        null;
    }

    console.log("âœ… External complaint API accepted submission successfully");
    if (sapId) {
      console.log(`âœ… SAP ID returned: ${sapId}`);
    }

    return {
      success: true,
      data: apiResponse,
      sapId: sapId,
    };
  } catch (error) {
    if (error.code === "ECONNABORTED") {
      console.error("â±ï¸  External complaint API timeout:", error.message);
      return { success: false, error: "Request timeout" };
    } else if (error.code === "ECONNREFUSED") {
      console.error(
        "ðŸ”Œ External complaint API connection refused:",
        error.message,
      );
      return { success: false, error: "Connection refused" };
    } else if (error.response) {
      console.error(
        "âŒ External complaint API error response:",
        error.response.status,
        error.response.data,
      );
      return {
        success: false,
        error: `Server error: ${error.response.status}`,
        data: error.response.data,
      };
    } else if (error.request) {
      console.error("âŒ No response from external complaint API");
      return { success: false, error: "No response from server" };
    } else {
      console.error("âŒ External complaint API error:", error.message);
      return { success: false, error: error.message };
    }
  }
}

function cleanSpeech(text) {
  if (!text) return "";
  return text
    .toLowerCase()
    .replace(/[à¥¤.,!?]/g, "")
    .replace(/\s+/g, " ")
    .trim();
}

function normalizeText(text) {
  if (!text) return "";
  return text.toLowerCase().replace(/\s+/g, " ").trim();
}

function safeAscii(text) {
  if (!text) return "Unknown";
  
  const transliterated = transliterateHindiToEnglish(text);
  
  const cleaned = transliterated
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g, "")
    .replace(/[^\x00-\x7F]/g, " ")
    .replace(/\s+/g, " ")
    .trim();
  
  return cleaned || "Unknown";
}

function getCallerName(call, customerData) {
  const spokenName = extractName(call.temp.complaintGivenByName);
  if (spokenName) {
    const asciiName = safeAscii(spokenName);
    if (asciiName && asciiName !== "Unknown" && asciiName.length >= 2) {
      return asciiName;
    }
  }

  if (customerData?.name && customerData.name !== "Unknown") {
    return safeAscii(customerData.name);
  }

  return "Not Provided";
}

function formatDateForExternal(date) {
  if (!date) return "";
  if (typeof date === "string" && /^\d{4}-\d{2}-\d{2}$/.test(date)) {
    return date;
  }

  const d = new Date(date);
  if (isNaN(d.getTime())) return "";

  const yyyy = d.getFullYear();
  const mm = String(d.getMonth() + 1).padStart(2, "0");
  const dd = String(d.getDate()).padStart(2, "0");

  return `${yyyy}-${mm}-${dd}`;
}

function detectMachineType(text) {
  if (!text) return null;

  if (text.includes("warranty") || text.includes("à¤µà¤¾à¤°à¤‚à¤Ÿà¥€")) {
    return "Warranty";
  }
  if (text.includes("care") || text.includes("à¤•à¥‡à¤¯à¤°") || text.includes("à¤•à¥‡à¤°à¤²à¤¾")) {
    if (text.includes("engine") || text.includes("à¤‡à¤‚à¤œà¤¨") || text.includes("à¤‡à¤‚à¤¡à¤¿à¤¯à¤¨")) {
      return "Engine Care";
    }
    return "JCB Care";
  }
  if (text.includes("demo") || text.includes("à¤¡à¥‡à¤®à¥‹")) {
    return "Demo";
  }

  return null;
}

function detectMachineStatus(text) {
  if (!text) return null;

  if (
    text.includes("breakdown") ||
    text.includes("break down") ||
    text.includes("à¤–à¤°à¤¾à¤¬") ||
    text.includes("à¤¬à¤‚à¤¦") ||
    text.includes("à¤¬à¥à¤°à¥‡à¤•à¤¡à¤¾à¤‰à¤¨")
  ) {
    return "Break Down";
  }

  if (
    text.includes("running") ||
    text.includes("à¤šà¤² à¤°à¤¹à¤¾") ||
    text.includes("à¤šà¤¾à¤²à¥‚") ||
    text.includes("chal rahi")
  ) {
    if (
      text.includes("problem") ||
      text.includes("dikkat") ||
      text.includes("à¤¦à¤¿à¤•à¥à¤•à¤¤") ||
      text.includes("à¤ªà¥à¤°à¥‰à¤¬à¥à¤²à¤®")
    ) {
      return "Running With Problem";
    }
    return "Running OK";
  }

  return null;
}

function ask(twiml, text, call) {
  call.temp.lastQuestion = text;

  const gather = twiml.gather({
    input: "speech",
    language: "hi-IN",
    speechTimeout: "auto",
    timeout: 6,
    actionOnEmptyResult: true,
    action: "/voice/process",
    method: "POST",
  });

  gather.say({ voice: "Polly.Aditi", language: "hi-IN" }, text);
}

/* =======================
   SAVE COMPLAINT
======================= */
async function saveComplaint(twiml, call, CallSid) {
  let customerData = call.temp.customerData;

  if (!customerData) {
    console.log("âš ï¸  Customer data not in session, fetching from database...");
    try {
      const customer = await Customer.findById(call.temp.customerId);
      if (!customer) {
        console.error("âŒ Customer not found in database");
        twiml.say(
          { voice: "Polly.Aditi", language: "hi-IN" },
          "Technical error. Aapko agent se connect kiya ja raha hai.",
        );
        twiml.dial(process.env.HUMAN_AGENT_NUMBER);
        call.step = "done";
        return;
      }

      customerData = {
        chassisNo: customer.chassisNo,
        phone: customer.phone,
        name: customer.name,
        city: customer.city,
        model: customer.model,
        subModel: customer.subModel || "NA",
        machineType: customer.machineType,
        businessPartnerCode: customer.businessPartnerCode || "NA",
        purchaseDate: customer.purchaseDate || "NA",
        installationDate: customer.installationDate || "NA",
      };
      console.log("âœ… Customer data retrieved from database");
    } catch (error) {
      console.error("âŒ Error fetching customer:", error.message);
      twiml.say(
        { voice: "Polly.Aditi", language: "hi-IN" },
        "Technical error. Aapko agent se connect kiya ja raha hai.",
      );
      twiml.dial(process.env.HUMAN_AGENT_NUMBER);
      call.step = "done";
      return;
    }
  }

  const branchOutlet = detectBranchAndOutlet(customerData.city);

  const installationDate =
    formatDateForExternal(customerData.installationDate) ||
    formatDateForExternal(customerData.purchaseDate) ||
    "";
  
  const callerNameFinal = getCallerName(call, customerData);

  const callerPhoneFinal =
    call.temp.complaintGivenByPhone &&
    /^\d{10}$/.test(call.temp.complaintGivenByPhone)
      ? call.temp.complaintGivenByPhone
      : customerData.phone;

  const complaintDetailsEnglish = safeAscii(
    call.temp.rawComplaint || call.temp.englishComplaint || ""
  );

  const finalSubTitle = call.temp.complaintSubTitle && 
                        call.temp.complaintSubTitle !== "Other" 
                        ? call.temp.complaintSubTitle 
                        : "Other";

  console.log("ðŸ” Final processed data:");
  console.log("   Caller Name:", callerNameFinal);
  console.log("   Caller Phone:", callerPhoneFinal);
  console.log("   Complaint Title:", call.temp.complaintTitle);
  console.log("   Subtitle:", finalSubTitle);
  console.log("   Details (English):", complaintDetailsEnglish);
  console.log("   Details (Raw):", call.temp.rawComplaint);

  const complaintApiData = {
    machine_no: customerData.chassisNo || "Unknown",
    customer_name: safeAscii(customerData.name),
    caller_name: callerNameFinal,
    contact_person: callerNameFinal,
    caller_no: callerPhoneFinal,
    machine_model: customerData.machineType || "Unknown",
    sub_model: customerData.model || "NA",
    installation_date: installationDate,
    machine_type: call.temp.machineType || "Warranty",
    complain_by: "Customer",
    machine_status: call.temp.machineStatus || "Unknown",
    job_location: call.temp.jobLocation || "Onsite",
    branch: branchOutlet.branch,
    outlet: branchOutlet.outlet,
    city_id: branchOutlet.cityCode,
    complaint_details: complaintDetailsEnglish,
    complaint_title: call.temp.complaintTitle || "NA",
    sub_title: finalSubTitle,
    business_partner_code: customerData.businessPartnerCode || "NA",
    // job_close_lat: customerData.job_close_lat || "0.000000",
    // job_close_lng: customerData.job_close_lng || "0.000000",
    // job_open_lat: customerData.job_open_lat || "0.000000",
    // job_open_lng: customerData.job_open_lng || "0.000000",
    complaint_sap_id: "NA",
  };

  console.log("ðŸŒ Submitting complaint to external API...");
  const externalResult = await submitComplaintToExternal(complaintApiData);

  let sapId = null;
  if (externalResult.success) {
    sapId = externalResult.sapId;
    if (sapId) {
      console.log(
        `âœ… External API submission successful with SAP ID: ${sapId}`,
      );
    } else {
      console.log("âœ… External API submission successful (no SAP ID returned)");
    }
  } else {
    console.error(
      `âŒ External API submission failed: ${externalResult.error || "Unknown error"}`,
    );
    console.log("âš ï¸  Continuing with local database save...");
  }

  const complaintDbData = {
    customerId: call.temp.customerId,
    machineNo: customerData.chassisNo || "Unknown",
    chassisNo: customerData.chassisNo || "Unknown",
    customerName: safeAscii(customerData.name),
    registeredPhone: customerData.phone || "Unknown",
    machineModel: customerData.model || "Unknown",
    subModel: customerData.subModel || "NA",
    machineType: call.temp.machineType || "Warranty",
    purchaseDate: customerData.purchaseDate || "NA",
    installationDate: customerData.installationDate || "NA",
    businessPartnerCode: customerData.businessPartnerCode || "NA",
    complaintGivenByName: callerNameFinal,
    complaintGivenByPhone: callerPhoneFinal,
    machineStatus: call.temp.machineStatus || "Unknown",
    jobLocation: call.temp.jobLocation || "Onsite",
    branch: branchOutlet.branch,
    outlet: branchOutlet.outlet,
    city_id: branchOutlet.cityCode,
    description_raw: complaintDetailsEnglish,
    complaintTitle: call.temp.complaintTitle || "NA",
    complaintSubTitle: finalSubTitle,
    complaintSapId: sapId || null,
    callSid: CallSid,
    source: "IVR_VOICE_BOT",
    complainBy: "Customer",
  };

  try {
    console.log("ðŸ’¾ Saving complaint to local database...");
    const savedComplaint = await Complaint.create(complaintDbData);
    console.log(
      `âœ… Complaint saved to database with ID: ${savedComplaint._id}`,
    );
  } catch (dbError) {
    console.error("âŒ Failed to save complaint to database:", dbError.message);
  }

  call.step = "done";
  
  if (sapId) {
    twiml.say(
      { voice: "Polly.Aditi", language: "hi-IN" },
      `Dhanyavaad. Aapki complaint successfully register ho gayi hai. Complaint number ${sapId} hai. Hamari team jaldi hi aapko contact karegi.`,
    );
  } else {
    twiml.say(
      { voice: "Polly.Aditi", language: "hi-IN" },
      "Dhanyavaad. Aapki complaint register ho gayi hai. Hamari team jaldi hi aapko contact karegi.",
    );
  }
  
  twiml.hangup();
}

/* =======================
   INCOMING CALL HANDLER
======================= */
router.post("/", async (req, res) => {
  const { CallSid, From } = req.body;
  const twiml = new VoiceResponse();

  await CallSession.findOneAndUpdate(
    { callSid: CallSid },
    {
      callSid: CallSid,
      from: From,
      step: "ivr_menu",
      temp: { retries: 0, attemptCount: 0, confusionCount: 0 },
    },
    { upsert: true, new: true },
  );

  const gather = twiml.gather({
    input: "dtmf",
    numDigits: 1,
    timeout: 5,
    action: "/voice/process",
    method: "POST",
  });

  gather.say(
    { voice: "Polly.Aditi", language: "hi-IN" },
    "Rajesh JCB motors mein aapka swagat hai. Complaint register karne ke liye ek dabayien. Human agent se baat karne ke liye do dabayien.",
  );

  res.type("text/xml").send(twiml.toString());
});

/* =======================
   CALL PROCESSING HANDLER (ENHANCED WITH ADVANCED NLU)
======================= */
router.post("/process", async (req, res) => {
  const twiml = new VoiceResponse();
  const { CallSid, Digits, SpeechResult } = req.body;

  const call = await CallSession.findOne({ callSid: CallSid });
  if (!call) {
    twiml.say("Technical error.");
    twiml.hangup();
    return res.type("text/xml").send(twiml.toString());
  }

  // Initialize tracking
  if (!call.temp.attemptCount) call.temp.attemptCount = 0;
  if (!call.temp.confusionCount) call.temp.confusionCount = 0;

  if (!SpeechResult && !Digits) {
    ask(twiml, call.temp.lastQuestion || "Kripya apna jawab bolein.", call);
    await call.save();
    return res.type("text/xml").send(twiml.toString());
  }

  if (call.step === "ivr_menu") {
    if (Digits === "2") {
      twiml.say(
        { voice: "Polly.Aditi", language: "hi-IN" },
        "Aapko agent se connect kiya ja raha hai. Kripya pratiksha karein."
      );
      twiml.dial(process.env.HUMAN_AGENT_NUMBER);
      return res.type("text/xml").send(twiml.toString());
    }

    if (Digits === "1") {
      call.step = "ask_identifier";
      ask(
        twiml,
        "Kripya apni machine ka chassis number ya registered mobile number boliye.",
        call,
      );
      await call.save();
      return res.type("text/xml").send(twiml.toString());
    }

    ask(twiml, "Kripya ek ya do dabayien.", call);
    await call.save();
    return res.type("text/xml").send(twiml.toString());
  }

  const rawSpeech = normalizeText(cleanSpeech(SpeechResult || ""));
  const transliteratedSpeech = transliterateHindiToEnglish(rawSpeech);
  const combinedSpeech = `${rawSpeech} ${transliteratedSpeech}`.toLowerCase();

  console.log("ðŸŽ¤ RAW SPEECH    :", SpeechResult);
  console.log("ðŸ§¹ CLEANED      :", rawSpeech);
  console.log("ðŸ”¤ TRANSLITERATED:", transliteratedSpeech);
  console.log("ðŸ”— COMBINED     :", combinedSpeech);

  // ====== ADVANCED INTENT DETECTION ======
  const userIntent = detectIntent(rawSpeech);
  console.log("ðŸŽ¯ USER INTENT:", userIntent);

  // Handle correction intent
  if (userIntent === 'correction') {
    console.log("ðŸ”„ User is correcting their answer");
    
    if (call.step === 'confirm_complaint' || call.step === 'ask_sub_complaint') {
      call.step = 'ask_complaint';
      call.temp.retries = 0;
      call.temp.confusionCount = 0;
      ask(twiml, "Theek hai. Machine mein exactly kya problem hai? Kripya clearly batayein.", call);
      await call.save();
      return res.type("text/xml").send(twiml.toString());
    }
    
    if (call.step === 'ask_complaint_given_by_name') {
      ask(twiml, "Theek hai. Apna sahi naam batayein.", call);
      await call.save();
      return res.type("text/xml").send(twiml.toString());
    }
    
    if (call.step === 'ask_complaint_given_by_phone') {
      ask(twiml, "Theek hai. Apna sahi phone number batayein.", call);
      await call.save();
      return res.type("text/xml").send(twiml.toString());
    }
  }

  // Handle escalation intent
  if (userIntent === 'escalation') {
    console.log("ðŸ“ž User wants to talk to agent");
    twiml.say(
      { voice: "Polly.Aditi", language: "hi-IN" },
      "Theek hai. Aapko agent se connect kar raha hoon."
    );
    twiml.dial(process.env.HUMAN_AGENT_NUMBER);
    await call.save();
    return res.type("text/xml").send(twiml.toString());
  }

  // Handle uncertainty
  if (userIntent === 'uncertainty') {
    console.log("â“ User doesn't know/remember");
    
    if (call.step === 'ask_identifier') {
      const smartQ = getSmartFollowUp({
        step: 'ask_identifier',
        attemptCount: call.temp.attemptCount || 0
      });
      ask(twiml, smartQ || "Koi baat nahi. Machine ka koi aur detail batayein jo yaad ho.", call);
      call.temp.attemptCount = (call.temp.attemptCount || 0) + 1;
      await call.save();
      return res.type("text/xml").send(twiml.toString());
    }
  }

  // Reset confusion on valid intent
  if (userIntent === 'affirmative' || userIntent === 'negative') {
    call.temp.confusionCount = 0;
  }

  switch (call.step) {
    case "ask_identifier": {
      // Enhanced phone extraction
      const phone = extractPhoneNumber(rawSpeech);
      
      // Enhanced chassis extraction
      let chassis = rawSpeech.replace(/\s+/g, "").toUpperCase();
      if (/[\u0900-\u097F]/.test(chassis)) {
        chassis = transliteratedSpeech.replace(/\s+/g, "").toUpperCase();
      }

      console.log("ðŸ” Identifier extraction:");
      console.log("   Phone:", phone || "N/A");
      console.log("   Chassis:", chassis.length >= 4 ? chassis : "N/A");

      const externalData = await fetchCustomerFromExternal({
        phone: phone,
        chassisNo: chassis.length >= 4 ? chassis : null,
      });

      if (!externalData) {
        call.temp.retries = (call.temp.retries || 0) + 1;

        if (call.temp.retries >= 3) {
          twiml.say(
            { voice: "Polly.Aditi", language: "hi-IN" },
            "Humein details verify nahi ho pa rahi. Aapko agent se connect kiya ja raha hai.",
          );
          twiml.dial(process.env.HUMAN_AGENT_NUMBER);
          await call.save();
          return res.type("text/xml").send(twiml.toString());
        }

        const smartQ = getSmartFollowUp({
          step: 'ask_identifier',
          attemptCount: call.temp.retries
        });
        
        ask(twiml, smartQ || "Record nahi mila. Kripya chassis number ya mobile number dobara boliye.", call);
        break;
      }

      let customer = null;
      try {
        customer = await Customer.findOne({
          $or: [
            { chassisNo: externalData.chassisNo },
            { phone: externalData.phone },
          ],
        });

        if (customer) {
          customer.chassisNo = externalData.chassisNo;
          customer.phone = externalData.phone;
          customer.name = externalData.name;
          customer.city = externalData.city;
          customer.model = externalData.model;
          customer.subModel = externalData.subModel;
          customer.machineType = externalData.machineType;
          customer.businessPartnerCode = externalData.businessPartnerCode;
          customer.purchaseDate = externalData.purchaseDate;
          customer.installationDate = externalData.installationDate;
          customer.source = externalData.source;
          customer.lastUpdated = new Date();
          await customer.save();
          console.log("âœ… Existing customer updated from API:", customer._id);
        } else {
          customer = await Customer.create({
            chassisNo: externalData.chassisNo,
            phone: externalData.phone,
            name: externalData.name,
            city: externalData.city,
            model: externalData.model,
            subModel: externalData.subModel,
            machineType: externalData.machineType,
            businessPartnerCode: externalData.businessPartnerCode,
            purchaseDate: externalData.purchaseDate,
            installationDate: externalData.installationDate,
            source: externalData.source,
          });
          console.log("âœ… New customer created from API:", customer._id);
        }
      } catch (saveError) {
        console.error("âŒ Failed to save/update customer:", saveError.message);
        twiml.say(
          { voice: "Polly.Aditi", language: "hi-IN" },
          "Technical error. Aapko agent se connect kiya ja raha hai.",
        );
        twiml.dial(process.env.HUMAN_AGENT_NUMBER);
        await call.save();
        return res.type("text/xml").send(twiml.toString());
      }

      call.temp.customerId = customer._id.toString();
      call.temp.customerData = {
        chassisNo: externalData.chassisNo,
        phone: externalData.phone,
        name: externalData.name,
        city: externalData.city,
        model: externalData.model,
        subModel: externalData.subModel,
        machineType: externalData.machineType,
        businessPartnerCode: externalData.businessPartnerCode,
        purchaseDate: externalData.purchaseDate,
        installationDate: externalData.installationDate,
      };
      call.temp.retries = 0;
      call.step = "ask_complaint_given_by_name";

      ask(
        twiml,
        `Aapka record mil gaya. ${safeAscii(externalData.name)} ji, Kripya apna pura naam btaiye?`,
        call,
      );
      break;
    }

    case "ask_complaint_given_by_name": {
      // Use advanced name extraction
      const extractedName = extractName(rawSpeech);
      
      console.log("ðŸ‘¤ Name extraction:");
      console.log("   Raw:", rawSpeech);
      console.log("   Extracted:", extractedName);
      
      if (!extractedName || extractedName.length < 2) {
        call.temp.retries = (call.temp.retries || 0) + 1;
        
        if (call.temp.retries >= 2) {
          call.temp.complaintGivenByName = call.temp.customerData?.name || "Customer";
          call.temp.retries = 0;
          call.step = "ask_complaint_given_by_phone";
          ask(twiml, "Apna 10 digit contact number btaiye.", call);
          break;
        }
        
        ask(twiml, "Kripya apna poora naam clearly btaiye. Sirf naam bolein.", call);
        break;
      }
      
      call.temp.complaintGivenByName = extractedName;
      call.temp.retries = 0;
      call.step = "ask_complaint_given_by_phone";
      ask(twiml, "Apna 10 digit contact number btaiye.", call);
      break;
    }

    case "ask_complaint_given_by_phone": {
      // Use advanced phone extraction
      const phone = extractPhoneNumber(rawSpeech);

      console.log("ðŸ“ž Phone extraction:");
      console.log("   Raw:", rawSpeech);
      console.log("   Extracted:", phone);

      if (!phone) {
        call.temp.retries = (call.temp.retries || 0) + 1;
        
        if (call.temp.retries >= 2) {
          call.temp.complaintGivenByPhone = call.temp.customerData?.phone || "Unknown";
          call.temp.retries = 0;
          call.step = "ask_machine_type";
          ask(
            twiml,
            "Machine ka type batayein. Warranty hai, JCB Care hai, Engine Care hai ya demo machine hai?",
            call,
          );
          break;
        }
        
        ask(twiml, "Kripya 10 digit ka phone number clearly boliye. Ek ek number bolein.", call);
        break;
      }

      call.temp.complaintGivenByPhone = phone;
      call.temp.retries = 0;
      call.step = "ask_machine_type";
      ask(
        twiml,
        "Machine ka type batayein. Warranty hai, JCB Care hai, Engine Care hai ya demo machine hai?",
        call,
      );
      break;
    }

    case "ask_machine_type": {
      const machineType = detectMachineType(combinedSpeech);

      if (!machineType) {
        call.temp.retries = (call.temp.retries || 0) + 1;

        if (call.temp.retries >= 2) {
          call.temp.machineType = "Warranty";
          call.temp.retries = 0;
          call.step = "ask_machine_status";
          ask(
            twiml,
            "Machine break down hai ya problem ke saath chal rahi hai?",
            call,
          );
          break;
        }

        ask(
          twiml,
          "Kripya clearly boliye: warranty, JCB care, engine care ya demo.",
          call,
        );
        break;
      }

      call.temp.machineType = machineType;
      call.temp.retries = 0;
      call.step = "ask_machine_status";
      ask(
        twiml,
        "Machine break down hai ya problem ke saath chal rahi hai?",
        call,
      );
      break;
    }

    case "ask_machine_status": {
      const machineStatus = detectMachineStatus(combinedSpeech);

      if (!machineStatus) {
        call.temp.retries = (call.temp.retries || 0) + 1;

        if (call.temp.retries >= 2) {
          call.temp.machineStatus = "Running With Problem";
          call.temp.retries = 0;
          call.step = "ask_job_location";
          ask(twiml, "Machine kahan hai? Site par hai ya workshop mein?", call);
          break;
        }

        ask(
          twiml,
          "Kripya clearly boliye: break down hai ya problem ke saath chal rahi hai.",
          call,
        );
        break;
      }

      call.temp.machineStatus = machineStatus;
      call.temp.retries = 0;
      call.step = "ask_job_location";
      ask(twiml, "Machine kahan hai? Site par hai ya workshop mein?", call);
      break;
    }

    case "ask_job_location": {
      let jobLocation = "Onsite";

      if (
        combinedSpeech.includes("workshop") ||
        combinedSpeech.includes("à¤µà¤°à¥à¤•à¤¶à¥‰à¤ª") ||
        combinedSpeech.includes("garage")
      ) {
        jobLocation = "Work Shop";
      }

      call.temp.jobLocation = jobLocation;
      call.step = "ask_complaint";
      call.temp.retries = 0;
      ask(twiml, "Machine ki complaint batayein. Kya problem hai?", call);
      break;
    }

    case "ask_complaint": {
      call.temp.rawComplaint = rawSpeech;
      call.temp.englishComplaint = transliteratedSpeech;

      console.log("ðŸ“ Complaint captured:");
      console.log("   Raw:", call.temp.rawComplaint);
      console.log("   Transliterated:", call.temp.englishComplaint);

      const intent = detectComplaintIntent(combinedSpeech);

      if (!intent) {
        call.temp.retries = (call.temp.retries || 0) + 1;

        if (call.temp.retries >= 2) {
          const smartQ = getSmartFollowUp({
            step: 'ask_complaint',
            attemptCount: call.temp.retries
          });
          
          ask(twiml, smartQ || "Kripya engine, tyre, AC, hydraulic ya electrical ka problem batayein.", call);
          break;
        }

        ask(
          twiml,
          "Kripya complaint clear batayein. Engine, hydraulic, AC, electrical ya tyre?",
          call,
        );
        break;
      }

      call.temp.retries = 0;
      call.temp.detectedIntentPrimary = intent.primary;
      call.temp.detectedIntentConfidence = intent.confidence;

      console.log("ðŸŽ¯ Detected intent:", intent.primary, "Confidence:", intent.confidence);

      if (intent.confidence >= 0.95) {
        call.temp.complaintTitle = intent.primary;

        const subQuestion = generateSubComplaintQuestion(intent.primary);
        
        if (subQuestion) {
          call.step = "ask_sub_complaint";
          call.temp.subRetries = 0;
          ask(twiml, subQuestion, call);
        } else {
          call.temp.complaintSubTitle = "Other";
          await saveComplaint(twiml, call, CallSid);
        }
      } else if (intent.confidence >= 0.80) {
        call.step = "confirm_complaint";
        ask(
          twiml,
          `${intent.primary} ka issue hai, sahi? Haan ya nahi bolein.`,
          call,
        );
      } else {
        call.step = "confirm_complaint";
        ask(
          twiml,
          `Aap keh rahe hain ${intent.primary} ka issue hai, sahi? Haan ya nahi bolein.`,
          call,
        );
      }
      break;
    }

    case "confirm_complaint": {
      const isYes = userIntent === 'affirmative' || 
        combinedSpeech.includes("haan") ||
        combinedSpeech.includes("à¤¹à¤¾à¤‚") ||
        combinedSpeech.includes("à¤¹à¤¾à¤") ||
        combinedSpeech.includes("yes") ||
        combinedSpeech.includes("ji") ||
        combinedSpeech.includes("sahi") ||
        combinedSpeech.includes("correct") ||
        combinedSpeech.includes("theek");

      const isNo = userIntent === 'negative' ||
        combinedSpeech.includes("nahi") ||
        combinedSpeech.includes("à¤¨à¤¹à¥€à¤‚") ||
        combinedSpeech.includes("no") ||
        combinedSpeech.includes("galat") ||
        combinedSpeech.includes("wrong");

      if (isYes) {
        const title = call.temp.detectedIntentPrimary;
        call.temp.complaintTitle = title;

        const subQuestion = generateSubComplaintQuestion(title);
        
        if (subQuestion) {
          call.step = "ask_sub_complaint";
          call.temp.subRetries = 0;
          ask(twiml, subQuestion, call);
        } else {
          call.temp.complaintSubTitle = "Other";
          await saveComplaint(twiml, call, CallSid);
        }
        break;
      }

      if (isNo) {
        call.step = "ask_complaint";
        call.temp.retries = 0;
        ask(twiml, "Theek hai, kripya complaint dobara clearly batayein. Machine mein kya problem hai?", call);
        break;
      }

      ask(twiml, "Kripya haan ya nahi bolein.", call);
      break;
    }

    case "ask_sub_complaint": {
      const title = call.temp.complaintTitle;
      
      if (!complaintMap[title] || !complaintMap[title].subTitles) {
        call.temp.complaintSubTitle = "Other";
        await saveComplaint(twiml, call, CallSid);
        break;
      }

      call.temp.subRetries = call.temp.subRetries || 0;

      const subResult = detectSubComplaint(title, combinedSpeech);

      if (!subResult || subResult.confidence < 0.6) {
        call.temp.subRetries += 1;

        if (call.temp.subRetries >= 2) {
          call.temp.complaintSubTitle = "Other";
          console.log("âš ï¸  Sub-complaint detection failed after retries, using 'Other'");
          await saveComplaint(twiml, call, CallSid);
          break;
        }

        const subQuestion = generateSubComplaintQuestion(title);
        ask(twiml, subQuestion + " Thoda aur clear batayein.", call);
        break;
      }

      call.temp.complaintSubTitle = subResult.subTitle;
      console.log("âœ… Sub-complaint detected:", subResult.subTitle);
      await saveComplaint(twiml, call, CallSid);
      break;
    }
  }

  await call.save();
  res.type("text/xml").send(twiml.toString());
});

export default router;