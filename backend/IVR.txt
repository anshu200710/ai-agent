import express from "express";
import twilio from "twilio";
import axios from "axios";
import Complaint from "../models/Complaint.js";
import {
  extractPhoneNumberV2,
  extractChassisNumberV2,
  extractNameV2,
  extractPincodeV2,
  extractLocationAddressV2,
  extractTimeV2,
  isValidPhone,
  isValidChassis,
  isValidName,
  isValidAddress,
  isValidPincode
} from '../utils/improved_extraction.js';

const router = express.Router();
const VoiceResponse = twilio.twiml.VoiceResponse;

const activeCalls = new Map();

/* ======================= EXTERNAL API CONFIG ======================= */
const EXTERNAL_API_BASE = "http://gprs.rajeshmotors.com/jcbServiceEnginerAPIv7";
const COMPLAINT_API_URL = "http://gprs.rajeshmotors.com/jcbServiceEnginerAPIv7/ai_call_complaint.php";
//const EXTERNAL_API_BASE = "http://192.168.0.90/jcbServiceEnginerAPIv7";
//const COMPLAINT_API_URL = "http://192.168.0.90/jcbServiceEnginerAPIv7/ai_call_complaint.php";
const API_TIMEOUT = 20000;
const API_HEADERS = { JCBSERVICEAPI: "MakeInJcb" };

/* ======================= AFFIRMATIVE KEYWORDS ======================= */
const affirmativeKeywords = [
  '‡§π‡§æ‡§®', '‡§π‡§æ‡§Ç', '‡§π‡§æ‡§Å', '‡§π‡§Æ', '‡§ú‡•Ä', '‡§∏‡§π‡•Ä', '‡§†‡•Ä‡§ï', '‡§¨‡§ø‡§≤‡•ç‡§ï‡•Å‡§≤', '‡§†‡•Ä‡§ï ‡§π‡•à', '‡§∏‡§π‡•Ä ‡§π‡•à',
  '‡§ú‡•Ä ‡§π‡§æ‡§Ç', '‡§ú‡•Ä ‡§π‡§æ‡§Å', '‡§π‡§æ‡§Ç ‡§ú‡•Ä', '‡§π‡§æ‡§Å ‡§ú‡•Ä', '‡§¨‡§ø‡§≤‡•ç‡§ï‡•Å‡§≤ ‡§∏‡§π‡•Ä', '‡§ú‡•Ä ‡§∏‡§∞', '‡§ú‡•Ä ‡§Æ‡•à‡§°‡§Æ',
  '‡§Ö‡§ö‡•ç‡§õ‡§æ', '‡§ì‡§ï‡•á', '‡§ï‡§∞‡•ã', '‡§ï‡•Ä‡§ú‡§ø‡§è', '‡§†‡•Ä‡§ï ‡§∞‡§π‡•á‡§ó‡§æ', '‡§ö‡§≤‡•á‡§ó‡§æ', '‡§π‡•ã ‡§ó‡§Ø‡§æ',
  'yes', 'yep', 'yeah', 'yup', 'sure', 'correct', 'right', 'ok', 'okay',
  'fine', 'good', 'ji', 'sahi', 'theek', 'thik', 'bilkul', 'haan', 'han',
  'absolutely', 'definitely', 'affirmative'
];

/* ======================= NEGATIVE KEYWORDS ======================= */
const negativeKeywords = [
  '‡§®‡§π‡•Ä‡§Ç', '‡§®‡§π‡•Ä', '‡§®‡§æ', '‡§®‡§æ‡§π', '‡§®', '‡§®‡§æ‡§Ø', '‡§ó‡§≤‡§§', '‡§ó‡§≤‡§§ ‡§π‡•à', '‡§ê‡§∏‡•Ä ‡§®‡§π‡•Ä‡§Ç',
  '‡§Ø‡•á ‡§®‡§π‡•Ä‡§Ç', '‡§Ø‡§π ‡§®‡§π‡•Ä‡§Ç', '‡§®‡§ï‡§æ‡§∞', '‡§Æ‡§§', '‡§Æ‡§§ ‡§ï‡§∞‡•ã', '‡§∞‡§π‡§®‡•á ‡§¶‡•ã', '‡§ú‡§∞‡•Ç‡§∞‡§§ ‡§®‡§π‡•Ä‡§Ç',
  '‡§†‡•Ä‡§ï ‡§®‡§π‡•Ä‡§Ç', '‡§∏‡§π‡•Ä ‡§®‡§π‡•Ä‡§Ç', '‡§¨‡§ø‡§≤‡•ç‡§ï‡•Å‡§≤ ‡§®‡§π‡•Ä‡§Ç',
  'no', 'nope', 'nah', 'na', 'not', 'dont', "don't", 'never', 'negative',
  'wrong', 'incorrect', 'galat', 'nai', 'nei'
];

/* ======================= UNCERTAINTY KEYWORDS ======================= */
const uncertaintyKeywords = [
  '‡§™‡§§‡§æ ‡§®‡§π‡•Ä‡§Ç', '‡§™‡§§‡§æ ‡§®‡§π‡•Ä', '‡§™‡§§‡§æ ‡§®', '‡§Æ‡•Å‡§ù‡•á ‡§™‡§§‡§æ ‡§®‡§π‡•Ä‡§Ç', '‡§Æ‡•Å‡§ù‡•á ‡§®‡§π‡•Ä‡§Ç ‡§™‡§§‡§æ',
  '‡§™‡§§‡§æ ‡§®‡§à‡§Ç', '‡§™‡§§‡§æ ‡§®‡§à', '‡§Æ‡§æ‡§≤‡•Ç‡§Æ ‡§®‡§π‡•Ä‡§Ç', '‡§Æ‡§æ‡§≤‡•Ç‡§Æ ‡§®‡§π‡•Ä', '‡§®‡§π‡•Ä‡§Ç ‡§Æ‡§æ‡§≤‡•Ç‡§Æ',
  '‡§Æ‡§æ‡§≤‡•Ç‡§Æ ‡§®‡§à‡§Ç', '‡§ú‡§æ‡§®‡§ï‡§æ‡§∞‡•Ä ‡§®‡§π‡•Ä‡§Ç',
  '‡§Ø‡§æ‡§¶ ‡§®‡§π‡•Ä‡§Ç', '‡§Ø‡§æ‡§¶ ‡§®‡§π‡•Ä', '‡§®‡§π‡•Ä‡§Ç ‡§Ø‡§æ‡§¶', '‡§Ø‡§æ‡§¶ ‡§®', '‡§Ø‡§æ‡§¶ ‡§®‡§à‡§Ç',
  '‡§≠‡•Ç‡§≤ ‡§ó‡§Ø‡§æ', '‡§≠‡•Ç‡§≤ ‡§ó‡§Ø‡•Ä', '‡§≠‡•Ç‡§≤ ‡§ó‡§è', '‡§≠‡•Ç‡§≤ ‡§ó‡§à', '‡§Ø‡§æ‡§¶ ‡§®‡§π‡•Ä‡§Ç ‡§Ü ‡§∞‡§π‡§æ',
  '‡§∏‡§Æ‡§ù ‡§®‡§π‡•Ä‡§Ç', '‡§∏‡§Æ‡§ù ‡§®‡§π‡•Ä', '‡§®‡§π‡•Ä‡§Ç ‡§∏‡§Æ‡§ù ‡§Ü ‡§∞‡§π‡§æ', '‡§∏‡§Æ‡§ù ‡§®‡§π‡•Ä‡§Ç ‡§Ü‡§Ø‡§æ',
  '‡§∏‡§Æ‡§ù ‡§®‡§à‡§Ç ‡§Ü‡§Ø‡§æ', '‡§∏‡§Æ‡§ù ‡§Æ‡•á‡§Ç ‡§®‡§π‡•Ä‡§Ç ‡§Ü‡§Ø‡§æ',
  '‡§ú‡§æ‡§®‡§§‡§æ ‡§®‡§π‡•Ä‡§Ç', '‡§ú‡§æ‡§®‡§§‡§æ ‡§®‡§π‡•Ä', '‡§ú‡§æ‡§®‡§§‡•Ä ‡§®‡§π‡•Ä‡§Ç', '‡§Æ‡•à‡§Ç ‡§®‡§π‡•Ä‡§Ç ‡§ú‡§æ‡§®‡§§‡§æ',
  '‡§Æ‡•à‡§Ç ‡§®‡§π‡•Ä‡§Ç ‡§ú‡§æ‡§®‡§§‡•Ä', '‡§π‡§Æ‡•á‡§Ç ‡§®‡§π‡•Ä‡§Ç ‡§™‡§§‡§æ', '‡§ï‡•ã‡§à ‡§µ‡§ø‡§ö‡§æ‡§∞ ‡§®‡§π‡•Ä‡§Ç', '‡§ï‡•ã‡§à ‡§Ü‡§á‡§°‡§ø‡§Ø‡§æ ‡§®‡§π‡•Ä‡§Ç',
  '‡§Ö‡§Ç‡§¶‡§æ‡§ú‡§æ ‡§®‡§π‡•Ä‡§Ç', '‡§ï‡•ç‡§≤‡•Ç ‡§®‡§π‡•Ä‡§Ç',
  'dont know', 'do not know', "don't know", 'dunno', 'no idea', 'no clue',
  'not sure', 'uncertain', 'forget', 'forgot', 'forgotten', "can't remember",
  'cant remember', 'not certain', 'confused'
];

/* ======================= CONTROL KEYWORDS ======================= */
const repeatKeywords = [
  'repeat', 'dobara', 'fir se', 'phir se', 'kya', 'kya kaha',
  'dubara', 'again', 'once more', 'samjha nahi'
];

const pauseKeywords = [
  'ruko', 'ruk', 'ek minute', 'ek min', 'i mean', 'matlab',
  'ruk jao', 'hold', 'thoda ruk'
];

function isRepeatRequest(text) {
  if (!text) return false;
  const lower = text.toLowerCase();
  return repeatKeywords.some(k => lower.includes(k));
}

function isPauseRequest(text) {
  if (!text) return false;
  const lower = text.toLowerCase();
  return pauseKeywords.some(k => lower.includes(k));
}

/* ======================= MACHINE TYPE KEYWORDS ======================= */
const machineTypeKeywords = {
  'Warranty': [
    '‡§µ‡§æ‡§∞‡§Ç‡§ü‡•Ä', 'warranty', '‡§µ‡§æ‡§∞‡•á‡§Ç‡§ü‡•Ä', '‡§µ‡•â‡§∞‡§Ç‡§ü‡•Ä', '‡§ó‡§æ‡§∞‡§Ç‡§ü‡•Ä', 'guarantee',
    'free', '‡§´‡•ç‡§∞‡•Ä', '‡§Æ‡•Å‡§´‡•ç‡§§', 'warranty mein', 'warranty ‡§Æ‡•á‡§Ç'
  ],
  'JCB Care': [
    '‡§ú‡•Ä‡§∏‡•Ä‡§¨‡•Ä ‡§ï‡•á‡§Ø‡§∞', 'jcb care', '‡§ï‡•á‡§Ø‡§∞', 'care', 'jcb ‡§ï‡•á‡§Ø‡§∞', '‡§ú‡•á‡§∏‡•Ä‡§¨‡•Ä ‡§ï‡•á‡§Ø‡§∞',
    'annual', 'yearly', '‡§∏‡§æ‡§≤', '‡§µ‡§æ‡§∞‡•ç‡§∑‡§ø‡§ï'
  ],
  'Engine Care': [
    '‡§á‡§Ç‡§ú‡§® ‡§ï‡•á‡§Ø‡§∞', 'engine care', '‡§á‡§Ç‡§ú‡•Ä‡§® ‡§ï‡•á‡§Ø‡§∞', 'engine ‡§ï‡§æ ‡§ï‡•á‡§Ø‡§∞',
    'engine protection', '‡§á‡§Ç‡§ú‡§® ‡§™‡•ç‡§∞‡•ã‡§ü‡•á‡§ï‡•ç‡§∂‡§®'
  ],
  'Demo': [
    '‡§°‡•á‡§Æ‡•ã', 'demo', '‡§°‡•á‡§Æ‡•ã ‡§Æ‡§∂‡•Ä‡§®', 'demonstration', 'test machine',
    '‡§ü‡•á‡§∏‡•ç‡§ü', '‡§™‡§∞‡•Ä‡§ï‡•ç‡§∑‡§£'
  ],
  'BHL': [
    '‡§¨‡•Ä‡§è‡§ö‡§è‡§≤', 'bhl', 'backhoe', '‡§¨‡•à‡§ï‡§π‡•ã', 'back hoe', 'backhoe loader'
  ]
};

/* ======================= MACHINE STATUS KEYWORDS ======================= */
const machineStatusKeywords = {
  'Breakdown': [
    '‡§¨‡•ç‡§∞‡•á‡§ï‡§°‡§æ‡§â‡§®', 'breakdown', 'break down', '‡§¨‡•ç‡§∞‡•á‡§ï ‡§°‡§æ‡§â‡§®', '‡§¨‡•ç‡§∞‡•á‡§ï-‡§°‡§æ‡§â‡§®',
    '‡§¨‡§ø‡§≤‡•ç‡§ï‡•Å‡§≤ ‡§¨‡§Ç‡§¶', '‡§™‡•Ç‡§∞‡•Ä ‡§§‡§∞‡§π ‡§¨‡§Ç‡§¶', 'completely down', 'totally down',
    '‡§¨‡§Ç‡§¶ ‡§π‡•à', '‡§¨‡§Ç‡§¶ ‡§π‡•ã ‡§ó‡§Ø‡§æ', '‡§¨‡§Ç‡§¶ ‡§π‡•ã ‡§ó‡§à', '‡§¨‡§Ç‡§¶ ‡§™‡§°‡§º‡§æ', '‡§¨‡§Ç‡§¶ ‡§™‡§°‡§º‡•Ä',
    '‡§™‡•Ç‡§∞‡§æ ‡§¨‡§Ç‡§¶', '‡§°‡§æ‡§â‡§® ‡§π‡•à', 'down ‡§π‡•à', '‡§™‡•Ç‡§∞‡•Ä ‡§§‡§∞‡§π ‡§°‡§æ‡§â‡§®',
    '‡§¨‡§ø‡§≤‡•ç‡§ï‡•Å‡§≤ ‡§ï‡§æ‡§Æ ‡§®‡§π‡•Ä‡§Ç', 'bilkul kaam nahi', '‡§ï‡§æ‡§Æ ‡§π‡•Ä ‡§®‡§π‡•Ä‡§Ç ‡§ï‡§∞ ‡§∞‡§π‡§æ',
    '‡§¨‡§ø‡§≤‡•ç‡§ï‡•Å‡§≤ ‡§ö‡§≤ ‡§®‡§π‡•Ä‡§Ç', 'bilkul chal nahi', '‡§ö‡§≤ ‡§π‡•Ä ‡§®‡§π‡•Ä‡§Ç ‡§∞‡§π‡§æ',
    '‡§∂‡•Å‡§∞‡•Ç ‡§®‡§π‡•Ä‡§Ç ‡§π‡•ã ‡§∞‡§π‡§æ', '‡§∏‡•ç‡§ü‡§æ‡§∞‡•ç‡§ü ‡§®‡§π‡•Ä‡§Ç ‡§π‡•ã ‡§∞‡§π‡§æ', '‡§ö‡§æ‡§≤‡•Ç ‡§®‡§π‡•Ä‡§Ç ‡§π‡•ã ‡§∞‡§π‡§æ',
    'start nahi ho raha', 'chalu nahi ho raha',
    '‡§ñ‡§∞‡§æ‡§¨ ‡§π‡•ã ‡§ó‡§Ø‡§æ', '‡§ñ‡§∞‡§æ‡§¨ ‡§π‡•ã ‡§ó‡§à', '‡§†‡§™‡•ç‡§™ ‡§π‡•à', '‡§†‡§™‡•ç‡§™ ‡§π‡•ã ‡§ó‡§Ø‡§æ',
    '‡§Æ‡§∞ ‡§ó‡§Ø‡§æ', '‡§°‡•á‡§°', 'dead', 'stopped completely',
    '‡§ï‡§æ‡§Æ ‡§®‡§π‡•Ä‡§Ç ‡§ï‡§∞‡§§‡§æ', '‡§ï‡§æ‡§Æ ‡§®‡§π‡•Ä‡§Ç ‡§ï‡§∞‡§§‡•Ä', 'work nahi karta'
  ],
  'Running With Problem': [
    '‡§ö‡§≤ ‡§∞‡§π‡§æ ‡§π‡•à ‡§≤‡•á‡§ï‡§ø‡§®', '‡§ö‡§≤ ‡§∞‡§π‡•Ä ‡§π‡•à ‡§≤‡•á‡§ï‡§ø‡§®', 'chal raha hai lekin',
    '‡§ö‡§≤ ‡§∞‡§π‡§æ ‡§π‡•à ‡§™‡§∞', '‡§ö‡§≤ ‡§∞‡§π‡•Ä ‡§π‡•à ‡§™‡§∞', '‡§ö‡§≤ ‡§§‡•ã ‡§∞‡§π‡§æ ‡§π‡•à',
    '‡§ï‡§æ‡§Æ ‡§ï‡§∞ ‡§∞‡§π‡§æ ‡§π‡•à ‡§≤‡•á‡§ï‡§ø‡§®', '‡§ï‡§æ‡§Æ ‡§§‡•ã ‡§ï‡§∞ ‡§∞‡§π‡§æ ‡§π‡•à',
    '‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§ï‡•á ‡§∏‡§æ‡§• ‡§ö‡§≤', 'problem ‡§ï‡•á ‡§∏‡§æ‡§• ‡§ö‡§≤', '‡§¶‡§ø‡§ï‡•ç‡§ï‡§§ ‡§ï‡•á ‡§∏‡§æ‡§• ‡§ö‡§≤',
    'running with problem', 'working with issue', 'working but',
    '‡§Ü‡§Ç‡§∂‡§ø‡§ï ‡§∞‡•Ç‡§™ ‡§∏‡•á', 'partially working', '‡§•‡•ã‡§°‡§º‡§æ ‡§ï‡§æ‡§Æ ‡§ï‡§∞',
    '‡§ï‡§Æ ‡§∏‡•á ‡§ï‡§Æ ‡§ï‡§æ‡§Æ ‡§ï‡§∞', '‡§†‡•Ä‡§ï ‡§∏‡•á ‡§ï‡§æ‡§Æ ‡§®‡§π‡•Ä‡§Ç ‡§≤‡•á‡§ï‡§ø‡§® ‡§ö‡§≤',
    '‡§™‡•ç‡§∞‡•â‡§¨‡•ç‡§≤‡§Æ ‡§π‡•à ‡§™‡§∞ ‡§ö‡§≤', 'issue ‡§π‡•à but running', '‡§¶‡§ø‡§ï‡•ç‡§ï‡§§ ‡§π‡•à ‡§≤‡•á‡§ï‡§ø‡§® on'
  ]
};

/* ======================= JOB LOCATION KEYWORDS ======================= */
const jobLocationKeywords = {
  'Workshop': [
    '‡§µ‡§∞‡•ç‡§ï‡§∂‡•â‡§™', 'workshop', '‡§µ‡§∞‡•ç‡§ï‡§∂‡§æ‡§™', 'work shop', '‡§µ‡§∞‡•ç‡§ï ‡§∂‡•â‡§™',
    '‡§∂‡•â‡§™', 'shop', '‡§¶‡•Å‡§ï‡§æ‡§®', '‡§ó‡•à‡§∞‡•á‡§ú', 'garage', '‡§ó‡§∞‡§æ‡§ú',
    '‡§µ‡§∞‡•ç‡§ï‡§∂‡•â‡§™ ‡§Æ‡•á‡§Ç', 'workshop ‡§Æ‡•á‡§Ç', 'workshop mein', 'shop ‡§Æ‡•á‡§Ç',
    '‡§∂‡•â‡§™ ‡§Æ‡•á‡§Ç', '‡§ó‡•à‡§∞‡•á‡§ú ‡§Æ‡•á‡§Ç', '‡§ó‡§∞‡§æ‡§ú ‡§Æ‡•á‡§Ç',
    '‡§ò‡§∞ ‡§™‡§∞', '‡§ò‡§∞', '‡§ò‡§∞ ‡§Æ‡•á‡§Ç', 'home', '‡§π‡•ã‡§Æ', '‡§Ö‡§Ç‡§¶‡§∞', 'indoor',
    '‡§ó‡•ã‡§¶‡§æ‡§Æ', '‡§∂‡•á‡§°', 'shed', 'warehouse',
    'service center', '‡§∏‡§∞‡•ç‡§µ‡§ø‡§∏ ‡§∏‡•á‡§Ç‡§ü‡§∞', 'repair shop',
    '‡§∞‡§ø‡§™‡•á‡§Ø‡§∞ ‡§∂‡•â‡§™', '‡§Æ‡§∞‡§Æ‡•ç‡§Æ‡§§ ‡§ï‡•Ä ‡§¶‡•Å‡§ï‡§æ‡§®'
  ],
  'Onsite': [
    '‡§∏‡§æ‡§á‡§ü', 'site', '‡§∏‡§æ‡§á‡§ü ‡§™‡§∞', '‡§∏‡§æ‡§à‡§ü', '‡§∏‡§æ‡§à‡§ü ‡§™‡§∞', 'site ‡§™‡§∞',
    '‡§ñ‡•á‡§§', '‡§ñ‡•á‡§§ ‡§Æ‡•á‡§Ç', 'field', '‡§´‡•Ä‡§≤‡•ç‡§°', '‡§Æ‡•à‡§¶‡§æ‡§®',
    '‡§ú‡§ó‡§π', '‡§ú‡§ó‡§π ‡§™‡§∞', '‡§¨‡§æ‡§π‡§∞', 'outdoor',
    '‡§ï‡§æ‡§Æ ‡§ï‡•Ä ‡§ú‡§ó‡§π', 'work site', '‡§µ‡§∞‡•ç‡§ï ‡§∏‡§æ‡§á‡§ü', 'location', '‡§≤‡•ã‡§ï‡•á‡§∂‡§®',
    '‡§ú‡§π‡§æ‡§Ç ‡§ï‡§æ‡§Æ ‡§π‡•ã ‡§∞‡§π‡§æ', 'construction', '‡§ï‡§Ç‡§∏‡•ç‡§ü‡•ç‡§∞‡§ï‡•ç‡§∂‡§®',
    '‡§®‡§ø‡§∞‡•ç‡§Æ‡§æ‡§£', 'project', '‡§™‡•ç‡§∞‡•ã‡§ú‡•á‡§ï‡•ç‡§ü',
    'road', '‡§∞‡•ã‡§°', '‡§∏‡§°‡§º‡§ï', 'highway', '‡§π‡§æ‡§à‡§µ‡•á'
  ]
};

/* ======================= COMPREHENSIVE COMPLAINT MAP ======================= */
const complaintMap = {
  "Body Work": {
    keywords: ["body", "bodywork", "bushing", "leakage", "drum", "noise", "vibration", "water", "pipe", "color", "decal", "sticker", "‡§™‡•á‡§ü‡§ø‡§Ç‡§ó", "‡§∂‡§∞‡•Ä‡§∞", "‡§∂‡§∞‡•Ä‡§∞ ‡§ï‡§æ‡§Æ", "‡§¨‡§æ‡§°‡•Ä", "‡§¨‡•â‡§°‡•Ä", "body work", "‡§¨‡•â‡§°‡•Ä‡§µ‡§∞‡•ç‡§ï", "‡§¨‡•â‡§°‡•Ä ‡§µ‡§∞‡•ç‡§ï"],
    priority: 5,
    subTitles: {
      "Select Body Work": ["body", "‡§¨‡•â‡§°‡•Ä"],
      "Bushing Work": ["bushing", "‡§¨‡•Å‡§∂‡§ø‡§Ç‡§ó", "‡§¨‡•Å‡§∂‡§ø‡§ó", "‡§¨‡•Å‡§∏‡§ø‡§Ç‡§ó"],
      "Leakage from Drum": ["leakage", "drum", "leak", "‡§≤‡•Ä‡§ï‡•á‡§ú", "‡§≤‡•Ä‡§ï", "‡§°‡•ç‡§∞‡§Æ"],
      "Noise from Drum": ["noise", "drum", "‡§Ü‡§µ‡§æ‡§ú", "‡§°‡•ç‡§∞‡§Æ"],
      "Vibration fault in Drum": ["vibration", "‡§ï‡§Ç‡§™‡§®", "‡§ï‡§Ç‡§™‡§§‡•Ä", "‡§ï‡§Æ‡•ç‡§™‡§®"],
      "Water Sprinkle Pipe fault": ["water", "pipe", "‡§™‡§æ‡§á‡§™", "‡§™‡§æ‡§à‡§™", "‡§™‡§æ‡§á‡§™‡•ç‡§∏"],
      "Other": ["other", "‡§Ö‡§®‡•ç‡§Ø"]
    }
  },

  "Cabin": {
    keywords: ["cabin", "cab", "door", "glass", "window", "bonnet", "seat", "roof", "fan", "‡§ï‡•á‡§¨‡§ø‡§®", "‡§∏‡•Ä‡§ü", "‡§¶‡§∞‡§µ‡§æ‡§ú‡§æ", "‡§∂‡•Ä‡§∂‡§æ", "‡§ï‡•à‡§¨‡§ø‡§®", "‡§ï‡•à‡§¨‡•Ä‡§®", "‡§ï‡•á‡§¨‡•Ä‡§®", "‡§ñ‡§ø‡§°‡§º‡§ï‡•Ä", "‡§õ‡§§", "‡§´‡•à‡§®"],
    priority: 6,
    subTitles: {
      "Select Cabin": ["cabin", "‡§ï‡•à‡§¨‡§ø‡§®"],
      "bonnet crack": ["bonnet", "‡§¨‡•ã‡§®‡•á‡§ü", "‡§¨‡•ã‡§®‡§ø‡§ü"],
      "Cab Door Fault": ["door", "‡§¶‡§∞‡§µ‡§æ‡§ú‡§æ", "‡§¶‡§∞‡§µ‡§æ‡§ú‡§º‡§æ", "‡§¶‡§∞‡§µ‡§æ‡§ú", "‡§°‡•ç‡§Ø‡•ã‡§¢‡•Ä"],
      "Cabin glass cracked": ["glass", "‡§∂‡•Ä‡§∂‡§æ", "‡§ó‡•ç‡§≤‡§æ‡§∏", "‡§∂‡•Ä‡§∂‡•á"],
      "Cabin Glass removed": ["removed", "‡§π‡§ü‡§æ", "‡§π‡§ü‡§æ‡§Ø‡§æ", "‡§®‡§ø‡§ï‡§≤‡§æ"],
      "Door/window lock inoperative": ["lock", "‡§≤‡•â‡§ï", "‡§≤‡•ã‡§ï", "‡§§‡§æ‡§≤‡§æ"],
      "Fan not working": ["fan", "‡§™‡§Ç‡§ñ‡§æ", "‡§´‡•à‡§®", "‡§™‡§Ç‡§ñ‡•á"],
      "mounting problem": ["mounting", "‡§Æ‡§æ‡§â‡§Ç‡§ü‡§ø‡§Ç‡§ó", "‡§Æ‡§æ‡§â‡§Ç‡§ü‡§ø‡§ó", "‡§≤‡§ó‡§æ‡§®‡§æ"],
      "Operator Seat problems": ["seat", "‡§∏‡•Ä‡§ü", "‡§∏‡•Ä‡§ü‡•ç‡§∏", "‡§Ü‡§∏‡§®"],
      "Roof cracked": ["roof", "‡§õ‡§§", "‡§õ‡§§‡§∞‡•Ä"],
      "Other": ["other", "‡§Ö‡§®‡•ç‡§Ø"]
    }
  },

  "Electrical Complaint": {
    keywords: ["electrical", "electric", "light", "battery", "alternator", "starter", "switch", "relay", "wiring", "error code", "‡§¨‡§ø‡§ú‡§≤‡•Ä", "‡§≤‡§æ‡§á‡§ü", "‡§¨‡•à‡§ü‡§∞‡•Ä", "‡§§‡§æ‡§∞", "‡§á‡§≤‡•á‡§ï‡•ç‡§ü‡•ç‡§∞‡§ø‡§ï‡•ç‡§∏", "‡§á‡§≤‡•á‡§ï‡•ç‡§ü‡•ç‡§∞‡•Ä‡§ï‡§≤", "‡§¨‡§ø‡§ú‡§≤‡•Ä‡§Ø", "‡§≤‡§æ‡§à‡§ü", "‡§¨‡•à‡§ü‡•ç‡§∞‡•Ä", "‡§¨‡§ø‡§ú‡§≤‡•Ä ‡§ï‡•Ä ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ", "‡§µ‡§ø‡§¶‡•ç‡§Ø‡•Å‡§§"],
    priority: 8,
    subTitles: {
      "Select Electrical Complaint": ["electrical", "‡§¨‡§ø‡§ú‡§≤‡•Ä"],
      "Alternator not Working": ["alternator", "‡§Ü‡§≤‡•ç‡§ü‡§∞‡§®‡•á‡§ü‡§∞", "‡§ë‡§≤‡•ç‡§ü‡§∞‡§®‡•á‡§ü‡§∞", "‡§Ü‡§≤‡•ç‡§ü‡§∞"],
      "Error Code in Machine display": ["error", "code", "error code", "error ‡§ï‡•ã‡§°", "‡§è‡§∞‡§∞ ‡§ï‡•ã‡§°"],
      "Fuel Gauge not show": ["gauge", "fuel gauge", "‡§ó‡•á‡§ú", "‡§´‡•ç‡§Ø‡•Ç‡§≤ ‡§ó‡•á‡§ú"],
      "Fuel Motor not Working": ["fuel motor", "‡§´‡•ç‡§Ø‡•Ç‡§≤ ‡§Æ‡•ã‡§ü‡§∞"],
      "Hour meter not working": ["hour meter", "‡§Ü‡§µ‡§∞ ‡§Æ‡•Ä‡§ü‡§∞", "‡§ò‡§Ç‡§ü‡§æ ‡§Æ‡•Ä‡§ü‡§∞"],
      "Light glowing problem": ["light", "‡§≤‡§æ‡§á‡§ü", "‡§≤‡§æ‡§à‡§ü", "‡§∞‡•ã‡§∂‡§®‡•Ä"],
      "Relay fault": ["relay", "‡§∞‡§ø‡§≤‡•á", "‡§∞‡§ø‡§≤‡•à"],
      "Self/Starter motor problem": ["self", "starter", "‡§∏‡•á‡§≤‡•ç‡§´", "‡§∏‡•ç‡§ü‡§æ‡§∞‡•ç‡§ü‡§∞", "‡§∏‡•ç‡§ü‡§æ‡§∞‡•ç‡§ü‡§∞ ‡§Æ‡•ã‡§ü‡§∞"],
      "Starting trouble": ["start", "‡§∂‡•Å‡§∞‡•Ç", "‡§∏‡•ç‡§ü‡§æ‡§∞‡•ç‡§ü", "‡§∏‡•ç‡§ü‡§æ‡§∞‡•ç‡§ü‡§ø‡§ó"],
      "Switch Fault": ["switch", "‡§∏‡•ç‡§µ‡§ø‡§ö", "‡§∏‡•ç‡§µ‡•Ä‡§ö", "‡§∏‡•ç‡§µ‡§ø‡§ö‡•ç‡§ö"],
      "Wiper motor not working": ["wiper", "‡§µ‡§æ‡§á‡§™‡§∞", "‡§µ‡•á‡§™‡§∞"],
      "Wiring problem": ["wiring", "‡§§‡§æ‡§∞", "‡§µ‡§æ‡§Ø‡§∞‡§ø‡§Ç‡§ó", "‡§µ‡§æ‡§Ø‡§∞‡•Ä‡§ó", "‡§§‡§æ‡§∞‡•ã‡§Ç"],
      "Other": ["other", "‡§Ö‡§®‡•ç‡§Ø"]
    }
  },

  "Engine": {
    keywords: ["engine", "motor", "start", "smoke", "overheat", "noise", "power", "oil", "leakage", "seal leak", "fan belt", "‡§á‡§Ç‡§ú‡§®", "‡§Æ‡•ã‡§ü‡§∞", "‡§∂‡•Å‡§∞‡•Ç", "‡§ß‡•Å‡§Ü", "‡§ó‡§∞‡•ç‡§Æ‡•Ä", "‡§Ü‡§µ‡§æ‡§ú", "‡§á‡§Ç‡§°‡§ø‡§Ø‡§®", "‡§Æ‡•ã‡§ü‡§∞‡•ç‡§∏", "‡§á‡§Ç‡§ú‡§ø‡§®", "‡§á‡§Ç‡§ú‡•Ä‡§®", "‡§Æ‡•ã‡§ü‡§∞‡•ç‡§∏", "‡§á‡§Ç‡§ú‡§ø‡§® ‡§ï‡•Ä ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ", "‡§Æ‡•ã‡§ü‡§∞ ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ", "‡§∏‡•ç‡§ü‡§æ‡§∞‡•ç‡§ü ‡§®‡§π‡•Ä‡§Ç", "‡§ö‡§≤‡§®‡§æ", "‡§ö‡§≤ ‡§®‡§π‡•Ä‡§Ç ‡§∞‡§π‡§æ", "‡§ö‡§æ‡§≤‡•Ç", "‡§ö‡§æ‡§≤"],
    priority: 10,
    subTitles: {
      "Select Engine": ["engine", "‡§á‡§Ç‡§ú‡§®"],
      "Abnormal Noise": ["noise", "‡§Ü‡§µ‡§æ‡§ú", "sound", "‡§∂‡•ã‡§∞", "‡§ñ‡§∞‡•ç‡§∞", "‡§ñ‡§°‡§º‡§ñ‡§°‡§º", "‡§Ü‡§µ‡§ú‡§º", "‡§∏‡•ã‡§Ç‡§°"],
      "Air problem": ["air", "‡§π‡§µ‡§æ", "‡§è‡§Ø‡§∞", "‡§è‡§∞"],
      "coolant leak": ["coolant", "‡§ï‡•Ç‡§≤‡•á‡§Ç‡§ü", "‡§ï‡•Ç‡§≤‡•á‡§®‡•ç‡§ü", "‡§†‡§Ç‡§°‡§ï"],
      "Engine accessories": ["accessories", "‡§è‡§ï‡•ç‡§∏‡•á‡§∏‡§∞‡•Ä‡§ú"],
      "Engine Lugg down": ["lugg", "down", "‡§≤‡§ó", "‡§≤‡§°‡§º"],
      "Engine Over heating": ["overheat", "‡§ó‡§∞‡•ç‡§Æ", "‡§ó‡§∞‡§Æ", "‡§ì‡§µ‡§∞‡§π‡•Ä‡§ü", "‡§ì‡§µ‡§∞ ‡§π‡•Ä‡§ü"],
      "Engine seal leak": ["seal", "leak", "‡§≤‡•Ä‡§ï", "‡§∏‡•Ä‡§≤"],
      "Fan belt broken": ["fan", "belt", "‡§´‡•à‡§®", "‡§¨‡•á‡§≤‡•ç‡§ü"],
      "Fuel consumption high": ["fuel", "consumption", "‡§´‡•ç‡§Ø‡•Ç‡§≤", "‡§ï‡§Ç‡§ú‡§Æ‡•ç‡§™‡§∂‡§®"],
      "Leakages engine": ["leakage", "‡§≤‡•Ä‡§ï‡•á‡§ú", "‡§≤‡•Ä‡§ï", "‡§≤‡•Ä‡§ï‡•á‡§•"],
      "Oil consumption high": ["oil", "consumption", "‡§§‡•á‡§≤", "‡§ï‡§Ç‡§ú‡§Æ‡•ç‡§™‡§∂‡§®"],
      "Radiator leak": ["radiator", "‡§∞‡•á‡§°‡§ø‡§è‡§ü‡§∞", "‡§∞‡•á‡§°‡§ø‡§è‡§ü‡§∞ ‡§∏‡•á ‡§≤‡•Ä‡§ï"],
      "Smoke problem": ["smoke", "dhuan", "‡§ß‡•Å‡§Ü", "‡§∏‡•ç‡§Æ‡•ã‡§ï", "‡§ß‡•Å‡§Ç‡§Ü"],
      "Engine mounting problem": ["mounting", "‡§Æ‡§æ‡§â‡§Ç‡§ü‡§ø‡§Ç‡§ó", "‡§Æ‡§æ‡§â‡§Ç‡§ü"],
      "Accelerator cable problem": ["accelerator", "‡§è‡§ï‡•ç‡§∏‡•á‡§≤‡§∞‡•á‡§ü‡§∞"],
      "Starting trouble": ["start", "starting", "‡§∂‡•Å‡§∞‡•Ç", "‡§∏‡•ç‡§ü‡§æ‡§∞‡•ç‡§ü", "‡§∏‡•ç‡§ü‡§æ‡§∞‡•ç‡§ü ‡§®‡§π‡•Ä‡§Ç"],
      "Other": ["other", "‡§Ö‡§®‡•ç‡§Ø"]
    }
  },

  "Fabrication part": {
    keywords: ["fabrication", "boom", "bucket", "chassis", "dipper", "crack", "leak", "fuel tank", "hydraulic tank", "‡§ü‡•Ç‡§ü‡§æ", "‡§´‡§ü‡§æ", "‡§ï‡•ç‡§∞‡•à‡§ï", "‡§´‡•à‡§¨‡•ç‡§∞‡§ø‡§ï‡•á‡§∂‡§®", "‡§´‡•à‡§¨‡§ø‡§ï‡•á‡§∂‡§®", "‡§ï‡•ç‡§∞‡•à‡§ï‡•ç‡§∏", "‡§¨‡•Ç‡§Æ", "‡§¨‡§ï‡•á‡§ü", "‡§ö‡•á‡§∏‡§ø‡§∏"],
    priority: 6,
    subTitles: {
      "Select Fabrication part": ["fabrication", "‡§´‡•à‡§¨‡•ç‡§∞‡§ø‡§ï‡•á‡§∂‡§®"],
      "Boom cracked": ["boom", "crack", "‡§¨‡•Ç‡§Æ", "‡§ï‡•ç‡§∞‡•à‡§ï"],
      "Bucket cracked": ["bucket", "crack", "‡§¨‡§ï‡•á‡§ü", "‡§ï‡•ç‡§∞‡•à‡§ï"],
      "Bucket issue": ["bucket", "‡§¨‡§ï‡•á‡§ü", "‡§¨‡§æ‡§≤‡§ü‡•Ä"],
      "Chassis cracked": ["chassis", "‡§ö‡•á‡§∏‡§ø‡§∏", "‡§ö‡•á‡§∏‡•Ä"],
      "Dipper cracked": ["dipper", "‡§°‡§ø‡§™‡§∞", "‡§°‡§ø‡§™‡•ç‡§™‡§∞"],
      "Fuel Tank Leakage": ["fuel tank", "leak", "‡§´‡•ç‡§Ø‡•Ç‡§≤ ‡§ü‡•à‡§Ç‡§ï", "‡§ü‡•à‡§Ç‡§ï"],
      "Hydraulic Tank leakage": ["hydraulic tank", "‡§π‡§æ‡§á‡§°‡•ç‡§∞‡•ã‡§≤‡§ø‡§ï ‡§ü‡•à‡§Ç‡§ï"],
      "King post problem": ["king post", "‡§ï‡§ø‡§Ç‡§ó ‡§™‡•ã‡§∏‡•ç‡§ü"],
      "Loader arm": ["loader arm", "‡§≤‡•ã‡§°‡§∞ ‡§Ü‡§∞‡•ç‡§Æ", "‡§≤‡•ã‡§°‡§∞"],
      "Pin broken": ["pin", "‡§™‡§ø‡§®"],
      "Teeth broken": ["teeth", "‡§¶‡§æ‡§Ç‡§§"],
      "Other": ["other", "‡§Ö‡§®‡•ç‡§Ø"]
    }
  },

  "Transmission/Axle components": {
    keywords: ["transmission", "gear", "axle", "brake", "oil leak", "overheat", "‡§ü‡•ç‡§∞‡§æ‡§Ç‡§∏‡§Æ‡§ø‡§∂‡§®", "‡§ó‡§ø‡§Ø‡§∞", "‡§¨‡•ç‡§∞‡•á‡§ï", "‡§ü‡•ç‡§∞‡§æ‡§®‡•ç‡§∏‡§Æ‡§ø‡§∂‡§®", "‡§ü‡•ç‡§∞‡§æ‡§Ç‡§∏‡§Æ‡•Ä‡§∂‡§®", "‡§ó‡•Ä‡§Ø‡§∞", "‡§¨‡•ç‡§∞‡•á‡§ï‡•ç‡§∏"],
    priority: 7,
    subTitles: {
      "Select Transmission/Axle": ["transmission", "‡§ü‡•ç‡§∞‡§æ‡§Ç‡§∏‡§Æ‡§ø‡§∂‡§®"],
      "Abnormal sound Transmission": ["sound", "noise", "‡§Ü‡§µ‡§æ‡§ú"],
      "Brake problem": ["brake", "‡§¨‡•ç‡§∞‡•á‡§ï", "‡§¨‡•ç‡§∞‡•á‡§ï‡•ç‡§∏"],
      "Gear box problem": ["gear", "gearbox", "‡§ó‡§ø‡§Ø‡§∞", "‡§ó‡•Ä‡§Ø‡§∞"],
      "Gear hard": ["gear hard", "‡§ó‡§ø‡§Ø‡§∞ ‡§∏‡§ñ‡•ç‡§§"],
      "Oil leak from transmission": ["oil leak", "‡§§‡•á‡§≤ ‡§≤‡•Ä‡§ï"],
      "Reverse forward issue": ["reverse", "‡§∞‡§ø‡§µ‡§∞‡•ç‡§∏"],
      "Transmission overheat": ["overheat", "‡§ó‡§∞‡•ç‡§Æ‡•Ä"],
      "Other": ["other", "‡§Ö‡§®‡•ç‡§Ø"]
    }
  },

  "Hose": {
    keywords: ["hose", "hose leak", "hose cut", "o ring", "‡§π‡•ã‡§ú‡§º", "‡§π‡•ã‡§ú", "‡§π‡•ã‡§ú‡§º‡•á", "‡§™‡§æ‡§á‡§™", "‡§ü‡•ç‡§Ø‡•Ç‡§¨"],
    priority: 4,
    subTitles: {
      "Select Hose": ["hose", "‡§π‡•ã‡§ú‡§º"],
      "Hose O ring Cut": ["o ring", "‡§ì ‡§∞‡§ø‡§Ç‡§ó"],
      "Hose cut": ["hose cut", "‡§π‡•ã‡§ú‡§º ‡§ï‡§ü‡§æ"],
      "Hose leakages": ["leak", "leakage", "‡§≤‡•Ä‡§ï‡•á‡§ú"],
      "Other": ["other", "‡§Ö‡§®‡•ç‡§Ø"]
    }
  },

  "Hydraulic": {
    keywords: ["hydraulic", "pressure", "pump", "valve", "seal leak", "performance", "oil cooler", "motion cable", "‡§™‡•ç‡§∞‡•á‡§∂‡§∞", "‡§¶‡§¨‡§æ‡§µ", "‡§™‡§Ç‡§™", "‡§π‡§æ‡§á‡§°‡•ç‡§∞‡•ã‡§≤‡§ø‡§ï", "‡§π‡§æ‡§á‡§°‡•ç‡§∞‡•ã‡§≤‡•Ä‡§ï", "‡§™‡•ç‡§∞‡•á‡§∂‡§∞ ‡§ï‡•Ä ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ", "‡§¶‡§¨‡§æ‡§µ ‡§Æ‡•á‡§Ç ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ", "‡§π‡§æ‡§á‡§°‡•ç‡§∞‡•ã", "‡§™‡§Ç‡§™ ‡§ï‡•Ä ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ"],
    priority: 8,
    subTitles: {
      "Select Hydraulic": ["hydraulic", "‡§π‡§æ‡§á‡§°‡•ç‡§∞‡•ã‡§≤‡§ø‡§ï"],
      "Abnormal sound": ["sound", "noise", "‡§Ü‡§µ‡§æ‡§ú"],
      "Control Valve leakage": ["valve", "‡§µ‡§æ‡§≤‡•ç‡§µ", "‡§µ‡•á‡§≤‡•ç‡§µ"],
      "EVB seal leak": ["seal leak", "‡§∏‡•Ä‡§≤"],
      "Hydra clamp issue": ["clamp", "‡§ï‡•ç‡§≤‡•à‡§Æ‡•ç‡§™"],
      "Hydraulic pump broken": ["pump broken", "‡§™‡§Ç‡§™ ‡§ü‡•Ç‡§ü‡§æ"],
      "Hydraulic pump leak": ["pump leak", "‡§™‡§Ç‡§™ ‡§≤‡•Ä‡§ï"],
      "Hydraulic pump Noise": ["pump noise", "‡§™‡§Ç‡§™ ‡§Ü‡§µ‡§æ‡§ú"],
      "LVB seal leak": ["seal leak", "‡§∏‡•Ä‡§≤ ‡§≤‡•Ä‡§ï"],
      "Machine performance low": ["performance low", "slow", "‡§ß‡•Ä‡§Æ‡§æ", "‡§™‡§∞‡§´‡•â‡§∞‡•ç‡§Æ‡•á‡§Ç‡§∏ ‡§ï‡§Æ"],
      "Oil cooler leak": ["cooler", "‡§ï‡•Ç‡§≤‡§∞"],
      "Pressure down": ["pressure down", "‡§¶‡§¨‡§æ‡§µ ‡§ï‡§Æ", "‡§¶‡§¨‡§æ‡§µ ‡§Æ‡•á‡§Ç ‡§ï‡§Æ‡•Ä"],
      "Swing Motor leakage": ["swing motor", "‡§∏‡•ç‡§µ‡§ø‡§Ç‡§ó ‡§Æ‡•ã‡§ü‡§∞"],
      "Swing Motor not braking": ["not braking", "‡§®‡§π‡•Ä‡§Ç ‡§∞‡•Å‡§ï ‡§∞‡§π‡§æ"],
      "Other": ["other", "‡§Ö‡§®‡•ç‡§Ø"]
    }
  },

  "Ram/Cylinder": {
    keywords: ["ram", "cylinder", "seal leak", "rod", "leak", "‡§∏‡§ø‡§≤‡§ø‡§Ç‡§°‡§∞", "‡§∞‡•â‡§°", "‡§∏‡§ø‡§≤‡•á‡§Ç‡§°‡§∞", "‡§∏‡§ø‡§≤‡§ø‡§®‡•ç‡§°‡§∞", "‡§∞‡•â‡§°‡•ç‡§∏", "‡§∏‡•Ä‡§≤"],
    priority: 6,
    subTitles: {
      "Select Ram/Cylinder": ["ram", "cylinder", "‡§∏‡§ø‡§≤‡§ø‡§Ç‡§°‡§∞"],
      "Boom ram seal leak": ["boom ram", "‡§¨‡•Ç‡§Æ ‡§∞‡•à‡§Æ"],
      "bucket ram seal leak": ["bucket ram", "‡§¨‡§ï‡•á‡§ü ‡§∞‡•à‡§Æ"],
      "Cylinder welding leak": ["cylinder", "‡§∏‡§ø‡§≤‡§ø‡§Ç‡§°‡§∞"],
      "Dipper ram seal leak": ["dipper ram", "‡§°‡§ø‡§™‡§∞ ‡§∞‡•à‡§Æ"],
      "Ram leak": ["ram leak", "‡§∞‡•à‡§Æ ‡§≤‡•Ä‡§ï"],
      "Rod bend": ["rod bend", "‡§∞‡•â‡§° ‡§Æ‡•Å‡§°‡§º‡§æ"],
      "Rod broken": ["rod broken", "‡§∞‡•â‡§° ‡§ü‡•Ç‡§ü‡§æ"],
      "Slew ram seal leak": ["slew ram", "‡§∏‡•ç‡§≤‡•Ç ‡§∞‡•à‡§Æ"],
      "Other": ["other", "‡§Ö‡§®‡•ç‡§Ø"]
    }
  },

  "Service": {
    keywords: ["service", "servicing", "maintenance", "checkup", "visit", "‡§∏‡§∞‡•ç‡§µ‡§ø‡§∏", "‡§Æ‡•á‡§Ç‡§ü‡•á‡§®‡•á‡§Ç‡§∏", "‡§∞‡§ñ‡§∞‡§ñ‡§æ‡§µ", "‡§∏‡§∞‡•ç‡§µ‡§ø‡§∏‡§ø‡§Ç‡§ó", "‡§∏‡§∞‡•ç‡§µ‡§ø‡§∏ ‡§ï‡•Ä", "‡§Æ‡•á‡§Ç‡§ü‡•á‡§®‡•á‡§Ç‡§∏ ‡§ï‡•Ä", "‡§Æ‡•á‡§Ç‡§ü‡•á‡§®‡•á‡§®‡•ç‡§∏"],
    priority: 3,
    subTitles: {
      "Actual Service": ["service", "actual", "‡§∏‡§∞‡•ç‡§µ‡§ø‡§∏"],
      "Service Visit": ["visit", "‡§µ‡§ø‡§ú‡§ø‡§ü"],
      "Other": ["other", "‡§Ö‡§®‡•ç‡§Ø"]
    }
  },

  "Tyre/Battery": {
    keywords: ["tyre", "tire", "battery", "tube", "puncture", "‡§ü‡§æ‡§Ø‡§∞", "‡§¨‡•à‡§ü‡§∞‡•Ä", "‡§™‡§Ç‡§ï‡•ç‡§ö‡§∞", "‡§ü‡•ç‡§Ø‡•Ç‡§¨", "‡§¨‡•à‡§ü‡•ç‡§∞‡•Ä", "‡§™‡§Ç‡§ï‡•ç‡§ö‡§∞ ‡§ï‡§æ", "‡§ü‡§æ‡§Ø‡§∞ ‡§ï‡•Ä"],
    priority: 7,
    subTitles: {
      "Select Tyre/Battery": ["tyre", "battery", "‡§ü‡§æ‡§Ø‡§∞"],
      "Battery problem": ["battery", "‡§¨‡•à‡§ü‡§∞‡•Ä", "‡§¨‡•à‡§ü‡•ç‡§∞‡•Ä"],
      "Tube joint opened": ["tube", "‡§ü‡•ç‡§Ø‡•Ç‡§¨"],
      "Tube puncture": ["puncture", "‡§™‡§Ç‡§ï‡•ç‡§ö‡§∞", "‡§™‡§Ç‡§ö‡§∞"],
      "Tyre burst": ["burst", "‡§´‡•Ç‡§≤‡§æ", "‡§´‡•Ç‡§≤‡§®‡§æ"],
      "Tyre cut": ["cut", "‡§ï‡§ü‡§æ", "‡§ï‡§ü‡•Ä"],
      "Tyre rubber breaking": ["rubber", "‡§∞‡§¨‡§∞"],
      "Other": ["other", "‡§Ö‡§®‡•ç‡§Ø"]
    }
  },

  "Under Carriage": {
    keywords: ["under carriage", "idler", "roller", "sprocket", "track", "gear", "‡§Ö‡§Ç‡§°‡§∞ ‡§ï‡•à‡§∞‡§ø‡§è‡§ú", "‡§Ü‡§á‡§°‡§≤‡§∞", "‡§∞‡•ã‡§≤‡§∞", "‡§∏‡•ç‡§™‡•ç‡§∞‡•ã‡§ï‡•á‡§ü", "‡§ü‡•ç‡§∞‡•à‡§ï"],
    priority: 5,
    subTitles: {
      "Select Under Carriage": ["carriage", "‡§ï‡•à‡§∞‡§ø‡§è‡§ú"],
      "Idler wheel leakage": ["idler", "‡§Ü‡§á‡§°‡§≤‡§∞"],
      "Idler wheel noise": ["idler noise", "‡§Ü‡§á‡§°‡§≤‡§∞ ‡§Ü‡§µ‡§æ‡§ú"],
      "Ring gear Crack": ["ring gear", "‡§∞‡§ø‡§Ç‡§ó ‡§ó‡§ø‡§Ø‡§∞"],
      "Roller Bent": ["roller", "‡§∞‡•ã‡§≤‡§∞"],
      "Roller leakage": ["leakage", "‡§≤‡•Ä‡§ï‡•á‡§ú"],
      "Sprocket Wear": ["sprocket", "‡§∏‡•ç‡§™‡•ç‡§∞‡•ã‡§ï‡•á‡§ü"],
      "Track Motor leak": ["track", "‡§ü‡•ç‡§∞‡•à‡§ï"],
      "Track Shoe bend": ["track shoe", "‡§ü‡•ç‡§∞‡•à‡§ï ‡§∂‡•Ç"],
      "Other": ["other", "‡§Ö‡§®‡•ç‡§Ø"]
    }
  },

  "PDI": {
    keywords: ["pdi", "pre delivery inspection", "‡§™‡•Ä‡§°‡•Ä‡§Ü‡§à", "‡§™‡•ç‡§∞‡•Ä ‡§°‡§ø‡§≤‡•Ä‡§µ‡§∞‡•Ä"],
    priority: 1,
    subTitles: {
      "PDI": ["pdi", "‡§™‡•Ä‡§°‡•Ä‡§Ü‡§à"]
    }
  },

  "Installation": {
    keywords: ["installation", "install", "‡§á‡§Ç‡§∏‡•ç‡§ü‡•â‡§≤‡•á‡§∂‡§®", "‡§á‡§Ç‡§∏‡•ç‡§ü‡§æ‡§≤‡•á‡§∂‡§®", "‡§á‡§Ç‡§∏‡•ç‡§ü‡§≤‡•á‡§∂‡§®"],
    priority: 2,
    subTitles: {
      "Installation visit": ["installation", "‡§á‡§Ç‡§∏‡•ç‡§ü‡•â‡§≤‡•á‡§∂‡§®"]
    }
  },

  "General Visit": {
    keywords: ["visit", "general", "asc", "bw", "monthly", "number plate", "accidental", "‡§µ‡§ø‡§ú‡§ø‡§ü", "‡§∏‡§æ‡§Æ‡§æ‡§®‡•ç‡§Ø"],
    priority: 1,
    subTitles: {
      "General Visit": ["general", "visit", "‡§µ‡§ø‡§ú‡§ø‡§ü"],
      "Monthly Visit": ["monthly", "‡§Æ‡§æ‡§∏‡§ø‡§ï"],
      "Number plate fitment": ["number plate", "‡§®‡§Ç‡§¨‡§∞ ‡§™‡•ç‡§≤‡•á‡§ü"],
      "Accidental": ["accidental", "accident", "‡§¶‡•Å‡§∞‡•ç‡§ò‡§ü‡§®‡§æ"]
    }
  },

  "Livelink": {
    keywords: ["livelink", "alert", "‡§≤‡§æ‡§á‡§µ‡§≤‡§ø‡§Ç‡§ï", "‡§è‡§≤‡§∞‡•ç‡§ü"],
    priority: 1,
    subTitles: {
      "Livelink not working": ["livelink not", "not working"],
      "Alert": ["alert", "‡§è‡§≤‡§∞‡•ç‡§ü"]
    }
  },

  "ECU problem": {
    keywords: ["ecu", "error code", "sensor", "‡§à‡§∏‡•Ä‡§Ø‡•Ç", "‡§à ‡§∏‡•Ä ‡§Ø‡•Ç", "‡§∏‡•á‡§Ç‡§∏‡§∞"],
    priority: 6,
    subTitles: {
      "ECU problem": ["ecu", "‡§à‡§∏‡•Ä‡§Ø‡•Ç"]
    }
  },

  "Campaign": {
    keywords: ["campaign", "fsi", "‡§ï‡•à‡§Ç‡§™‡•á‡§®", "‡§ï‡•à‡§Æ‡•ç‡§™‡•á‡§®", "‡§ï‡•à‡§Æ‡•ç‡§™‡•á‡§® ‡§ï‡•Ä"],
    priority: 1,
    subTitles: {
      "Campaign Visit": ["campaign", "‡§ï‡•à‡§Ç‡§™‡•á‡§®"],
      "FSI": ["fsi", "‡§è‡§´‡§è‡§∏‡§Ü‡§à"]
    }
  },

  "AC System": {
    keywords: ["ac", "a.c", "air conditioner", "cooling", "‡§†‡§Ç‡§°‡§æ", "‡§ï‡•Ç‡§≤‡§ø‡§Ç‡§ó", "‡§è‡§∏‡•Ä", "‡§è ‡§∏‡•Ä", "‡§è‡§∏‡•Ä ‡§ï‡•Ä", "‡§è‡§ï", "‡§è‡§ï‡§∏‡•Ä", "‡§è‡§Ø‡§∞ ‡§ï‡§Ç‡§°‡•Ä‡§∂‡§®‡§∞", "‡§ï‡•Ç‡§≤", "‡§†‡§Ç‡§°‡•Ä"],
    priority: 10,
    subTitles: {
      "AC not Working": ["not working", "‡§ï‡§æ‡§Æ ‡§®‡§π‡•Ä‡§Ç", "‡§®‡§π‡•Ä‡§Ç ‡§ö‡§≤", "‡§ñ‡§∞‡§æ‡§¨"],
      "AC not Cooling": ["not cooling", "‡§†‡§Ç‡§°‡§æ ‡§®‡§π‡•Ä‡§Ç", "‡§ï‡•Ç‡§≤‡§ø‡§Ç‡§ó ‡§®‡§π‡•Ä‡§Ç", "‡§†‡§Ç‡§° ‡§®‡§π‡•Ä‡§Ç"]
    }
  }
};

/* ======================= BRANCH, OUTLET & CITY CODE MAPPING ======================= */
const cityToBranchMap = {
  'ajmer': { branch: "AJMER", outlet: "AJMER", cityCode: "1" },
  '‡§Ö‡§ú‡§Æ‡•á‡§∞': { branch: "AJMER", outlet: "AJMER", cityCode: "1" },
  'kekri': { branch: "AJMER", outlet: "KEKRI", cityCode: "1" },
  '‡§ï‡•á‡§ï‡§°‡§º‡•Ä': { branch: "AJMER", outlet: "KEKRI", cityCode: "1" },

  'alwar': { branch: "ALWAR", outlet: "ALWAR", cityCode: "2" },
  '‡§Ö‡§≤‡§µ‡§∞': { branch: "ALWAR", outlet: "ALWAR", cityCode: "2" },
  'bharatpur': { branch: "ALWAR", outlet: "BHARATPUR", cityCode: "2" },
  '‡§≠‡§∞‡§§‡§™‡•Å‡§∞': { branch: "ALWAR", outlet: "BHARATPUR", cityCode: "2" },
  'bhiwadi': { branch: "ALWAR", outlet: "BHIWADI", cityCode: "2" },
  '‡§≠‡§ø‡§µ‡§æ‡§°‡§º‡•Ä': { branch: "ALWAR", outlet: "BHIWADI", cityCode: "2" },

  'bhilwara': { branch: "BHILWARA", outlet: "BHILWARA", cityCode: "3" },
  '‡§≠‡•Ä‡§≤‡§µ‡§æ‡§°‡§º‡§æ': { branch: "BHILWARA", outlet: "BHILWARA", cityCode: "3" },
  'nimbahera': { branch: "BHILWARA", outlet: "NIMBAHERA", cityCode: "3" },
  '‡§®‡§ø‡§Æ‡•ç‡§¨‡§æ‡§π‡•á‡§°‡§º‡§æ': { branch: "BHILWARA", outlet: "NIMBAHERA", cityCode: "3" },

  'jaipur': { branch: "JAIPUR", outlet: "JAIPUR", cityCode: "4" },
  '‡§ú‡§Ø‡§™‡•Å‡§∞': { branch: "JAIPUR", outlet: "JAIPUR", cityCode: "4" },
  'dausa': { branch: "JAIPUR", outlet: "DAUSA", cityCode: "4" },
  '‡§¶‡•å‡§∏‡§æ': { branch: "JAIPUR", outlet: "DAUSA", cityCode: "4" },
  'karauli': { branch: "JAIPUR", outlet: "KARAULI", cityCode: "4" },
  '‡§ï‡§∞‡•å‡§≤‡•Ä': { branch: "JAIPUR", outlet: "KARAULI", cityCode: "4" },
  'tonk': { branch: "JAIPUR", outlet: "TONK", cityCode: "4" },
  '‡§ü‡•ã‡§Ç‡§ï': { branch: "JAIPUR", outlet: "TONK", cityCode: "4" },

  'kota': { branch: "KOTA", outlet: "KOTA", cityCode: "5" },
  '‡§ï‡•ã‡§ü‡§æ': { branch: "KOTA", outlet: "KOTA", cityCode: "5" },
  'jhalawar': { branch: "KOTA", outlet: "JHALAWAR", cityCode: "5" },
  '‡§ù‡§æ‡§≤‡§æ‡§µ‡§æ‡§°‡§º': { branch: "KOTA", outlet: "JHALAWAR", cityCode: "5" },

  'sikar': { branch: "SIKAR", outlet: "SIKAR", cityCode: "6" },
  '‡§∏‡•Ä‡§ï‡§∞': { branch: "SIKAR", outlet: "SIKAR", cityCode: "6" },
  'sujangarh': { branch: "SIKAR", outlet: "SUJANGARH", cityCode: "6" },
  '‡§∏‡•Å‡§ú‡§æ‡§®‡§ó‡§¢‡§º': { branch: "SIKAR", outlet: "SUJANGARH", cityCode: "6" },
  'jhunjhunu': { branch: "SIKAR", outlet: "JHUNJHUNU", cityCode: "6" },
  '‡§ù‡•Å‡§Ç‡§ù‡•Å‡§®‡•Ç': { branch: "SIKAR", outlet: "JHUNJHUNU", cityCode: "6" },

  'udaipur': { branch: "UDAIPUR", outlet: "UDAIPUR", cityCode: "7" },
  '‡§â‡§¶‡§Ø‡§™‡•Å‡§∞': { branch: "UDAIPUR", outlet: "UDAIPUR", cityCode: "7" },
  'banswara': { branch: "UDAIPUR", outlet: "BANSWARA", cityCode: "7" },
  '‡§¨‡§æ‡§Ç‡§∏‡§µ‡§æ‡§°‡§º‡§æ': { branch: "UDAIPUR", outlet: "BANSWARA", cityCode: "7" },
  'dungarpur': { branch: "UDAIPUR", outlet: "DUNGARPUR", cityCode: "7" },
  '‡§°‡•Ç‡§Ç‡§ó‡§∞‡§™‡•Å‡§∞': { branch: "UDAIPUR", outlet: "DUNGARPUR", cityCode: "7" },
};

/* ======================= HELPER: Convert phone to spoken digits ======================= */
function phoneToSpokenDigits(phone) {
  if (!phone) return "";
  
  const digitMap = {
    '0': 'zero', '1': 'ek', '2': 'do', '3': 'teen', '4': 'char',
    '5': 'paanch', '6': 'chhe', '7': 'saat', '8': 'aath', '9': 'nau'
  };
  
  return phone.split('').map(d => digitMap[d] || d).join(', ');
}

/* ===========================
   VALIDATION FUNCTIONS
=========================== */

function rejectInvalid(text) {
  if (!text) return true;
  if (text.trim().length < 2) return true;
  if (isUncertain(text)) return true;
  if (isRepeatRequest(text)) return true;
  if (isPauseRequest(text)) return true;
  return false;
}

function isUncertain(text) {
  if (!text) return false;
  const textLower = text.toLowerCase();
  return uncertaintyKeywords.some(keyword =>
    new RegExp(`\\b${keyword}\\b`, 'i').test(textLower)
  );
}

function isAffirmative(text) {
  if (!text) return false;
  const textLower = text.toLowerCase().trim();

  const simpleChecks = ['‡§π‡§æ‡§Ç', '‡§π‡§æ‡§Å', '‡§π‡§æ‡§®', '‡§∏‡§π‡•Ä', '‡§†‡•Ä‡§ï', '‡§ú‡•Ä', 'yes', 'ok', '‡§¨‡§ø‡§≤‡•ç‡§ï‡•Å‡§≤'];
  for (const check of simpleChecks) {
    if (textLower.includes(check)) {
      console.log(`‚úÖ Affirmative detected: "${check}"`);
      return true;
    }
  }

  const found = affirmativeKeywords.some(keyword => {
    const keywordLower = keyword.toLowerCase();
    return textLower.includes(keywordLower);
  });

  if (found) {
    console.log(`‚úÖ Affirmative detected`);
  }

  return found;
}

function isNegative(text) {
  if (!text) return false;
  const textLower = text.toLowerCase().trim();

  const simpleChecks = ['‡§®‡§π‡•Ä‡§Ç', '‡§®‡§π‡•Ä', '‡§®‡§æ', '‡§ó‡§≤‡§§', 'no', '‡§®‡§æ‡§π'];
  for (const check of simpleChecks) {
    if (textLower.includes(check)) {
      console.log(`‚ùå Negative detected: "${check}"`);
      return true;
    }
  }

  const found = negativeKeywords.some(keyword => {
    const keywordLower = keyword.toLowerCase();
    return textLower.includes(keywordLower);
  });

  if (found) {
    console.log(`‚ùå Negative detected`);
  }

  return found;
}

function getSubComplaintQuestion(complaintType) {
  const questions = {
    "AC System": "AC mein exactly kya problem hai? Bilkul chal nahi raha hai, ya chal raha hai lekin thanda nahi kar raha?",
    "Engine": "Engine mein kya dikkat hai? Start nahi ho raha, ya overheat ho raha hai, ya dhuan aa raha hai, ya noise aa rahi hai?",
    "Brake": "Brake mein kya problem hai? Bilkul nahi lag raha, ya weak hai?",
    "Electrical Complaint": "Electrical mein kya problem hai? Start nahi ho raha, ya battery ki problem hai, ya light ki dikkat?",
    "Hydraulic": "‡§π‡§æ‡§á‡§°‡•ç‡§∞‡•ã‡§≤‡§ø‡§ï ‡§Æ‡•á‡§Ç ‡§ï‡•ç‡§Ø‡§æ ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§π‡•à? ‡§¶‡§¨‡§æ‡§µ ‡§ï‡§Æ ‡§π‡•à, ‡§Ø‡§æ ‡§ß‡•Ä‡§∞‡•á ‡§ï‡§æ‡§Æ ‡§ï‡§∞ ‡§∞‡§π‡§æ ‡§π‡•à, ‡§Ø‡§æ ‡§∞‡§ø‡§∏‡§æ‡§µ ‡§π‡•ã ‡§∞‡§π‡§æ ‡§π‡•à?",
    "Tyre/Battery": "Tyre ya battery mein kya problem hai? Battery dead hai, ya tyre puncture hai, ya tyre cut hai?",
    "Transmission/Axle components": "Transmission mein kya problem hai? Sound aa rahi hai, ya gear problem hai, ya brake issue?",
    "General Problem": "Machine mein aur detail mein kya problem hai?"
  };

  return questions[complaintType] || "Aur detail mein batayein ki exact kya problem hai?";
}

/* ======================= DETECTION FUNCTIONS ======================= */

function detectMachineType(text) {
  if (!text) return 'Warranty';
  const textLower = text.toLowerCase();

  for (const [type, keywords] of Object.entries(machineTypeKeywords)) {
    for (const keyword of keywords) {
      if (new RegExp(`\\b${keyword}\\b`, 'i').test(textLower)) {
        return type;
      }
    }
  }
  return 'Warranty';
}

function getMachineTypeByNumber(digit) {
  const machineTypeMap = {
    '1': 'Warranty',
    '2': 'JCB Care',
    '3': 'Engine Care',
    '4': 'Demo',
    '5': 'BHL'
  };
  return machineTypeMap[digit] || 'Warranty';
}

function getMachineStatusByNumber(digit) {
  const statusMap = {
    '1': 'Breakdown',
    '2': 'Running With Problem'
  };
  return statusMap[digit] || 'Running With Problem';
}

function detectMachineStatus(text) {
  if (!text) return 'Running With Problem';
  const textLower = text.toLowerCase();

  const breakdownKeywords = machineStatusKeywords['Breakdown'];
  for (const keyword of breakdownKeywords) {
    const escapedKeyword = keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    if (new RegExp(`(^|\\s)${escapedKeyword}(\\s|$)`, 'i').test(textLower)) {
      console.log(`‚úì Machine Status: Breakdown (matched: "${keyword}")`);
      return 'Breakdown';
    }
  }

  const runningKeywords = machineStatusKeywords['Running With Problem'];
  for (const keyword of runningKeywords) {
    if (textLower.includes(keyword.toLowerCase())) {
      console.log(`‚úì Machine Status: Running With Problem (matched: "${keyword}")`);
      return 'Running With Problem';
    }
  }

  console.log(`‚ö†Ô∏è Machine Status not clearly detected, using default: Running With Problem`);
  return 'Running With Problem';
}

function detectJobLocation(text) {
  if (!text) return 'Onsite';
  const textLower = text.toLowerCase();

  const workshopKeywords = jobLocationKeywords['Workshop'];
  for (const keyword of workshopKeywords) {
    const escapedKeyword = keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    if (new RegExp(`(^|\\s)${escapedKeyword}`, 'i').test(textLower)) {
      console.log(`‚úì Job Location: Workshop (matched: "${keyword}")`);
      return 'Workshop';
    }
  }

  const onsiteKeywords = jobLocationKeywords['Onsite'];
  for (const keyword of onsiteKeywords) {
    if (textLower.includes(keyword.toLowerCase())) {
      console.log(`‚úì Job Location: Onsite (matched: "${keyword}")`);
      return 'Onsite';
    }
  }

  console.log(`‚ö†Ô∏è Job Location not clearly detected, using default: Onsite`);
  return 'Onsite';
}

function detectComplaint(text) {
  if (!text) return null;
  const textLower = text.toLowerCase();

  let bestMatch = null;
  let highestScore = 0;

  const sortedComplaints = Object.entries(complaintMap).sort(
    (a, b) => (b[1].priority || 0) - (a[1].priority || 0)
  );

  for (const [category, config] of sortedComplaints) {
    let score = 0;

    for (const keyword of config.keywords) {
      const keywordLower = keyword.toLowerCase();
      if (textLower.includes(keywordLower)) {
        if (new RegExp(`\\b${keywordLower}\\b`, 'i').test(textLower)) {
          score += keyword.length * 2;
        } else {
          score += keyword.length;
        }
      }
    }

    if (score > highestScore) {
      highestScore = score;
      bestMatch = category;
    }
  }

  return {
    complaint: bestMatch,
    score: highestScore
  };
}

function detectSubComplaint(mainComplaint, text) {
  if (!mainComplaint || !complaintMap[mainComplaint]) {
    return { subTitle: "Other", confidence: 0.5 };
  }

  const subTitles = complaintMap[mainComplaint].subTitles;
  if (!subTitles || Object.keys(subTitles).length === 0) {
    return { subTitle: "Other", confidence: 1.0 };
  }

  const textLower = text.toLowerCase();
  let bestMatch = null;
  let highestScore = 0;

  for (const [subTitle, keywords] of Object.entries(subTitles)) {
    let score = 0;

    for (const keyword of keywords) {
      const keywordLower = keyword.toLowerCase();
      if (textLower.includes(keywordLower)) {
        if (new RegExp(`\\b${keywordLower}\\b`, 'i').test(textLower)) {
          score += keyword.length * 2;
        } else {
          score += keyword.length;
        }
      }
    }

    if (score > highestScore) {
      highestScore = score;
      bestMatch = subTitle;
    }
  }

  return {
    subTitle: bestMatch || "Other",
    confidence: highestScore > 0 ? Math.min(highestScore / 15, 1) : 0.5
  };
}

/* ======================= TEXT PROCESSING ======================= */

function cleanSpeech(text) {
  if (!text) return "";
  return text
    .toLowerCase()
    .replace(/[‡•§.,!?]/g, "")
    .replace(/\s+/g, " ")
    .trim();
}

function safeAscii(text) {
  if (!text) return "Unknown";
  return text.replace(/[^\w\s-]/g, '').trim() || "Unknown";
}

function detectBranchAndOutlet(city) {
  if (!city) return { branch: "NA", outlet: "NA", cityCode: "NA" };

  const normalized = city.toLowerCase().trim();
  return cityToBranchMap[normalized] || { branch: "NA", outlet: "NA", cityCode: "NA" };
}

function formatDateForExternal(date) {
  if (!date || date === "NA") return null;

  if (typeof date === "string" && /^\d{4}-\d{2}-\d{2}$/.test(date)) {
    return date;
  }

  const d = new Date(date);
  if (isNaN(d.getTime())) return null;

  const yyyy = d.getFullYear();
  const mm = String(d.getMonth() + 1).padStart(2, "0");
  const dd = String(d.getDate()).padStart(2, "0");

  return `${yyyy}-${mm}-${dd}`;
}

function askDTMF(twiml, text, numDigits = 1) {
  const gather = twiml.gather({
    input: "dtmf",
    numDigits: numDigits,
    timeout: 5,
    actionOnEmptyResult: true,
    action: "/voice/process",
    method: "POST",
  });

  gather.say({ voice: "Polly.Aditi", language: "hi-IN" }, text);
}

// Convert digits to Hindi words for readback
function digitsToHindi(digits) {
  const hindiDigits = {
    '0': '‡§∂‡•Ç‡§®‡•ç‡§Ø',
    '1': '‡§è‡§ï',
    '2': '‡§¶‡•ã',
    '3': '‡§§‡•Ä‡§®',
    '4': '‡§ö‡§æ‡§∞',
    '5': '‡§™‡§æ‡§Å‡§ö',
    '6': '‡§õ‡§π',
    '7': '‡§∏‡§æ‡§§',
    '8': '‡§Ü‡§†',
    '9': '‡§®‡•å'
  };
  return digits.split('').map(d => hindiDigits[d] || d).join(' ');
}

function ask(twiml, text) {
  const gather = twiml.gather({
    input: "speech dtmf",
    language: "hi-IN",
    speechTimeout: "auto",
    timeout: 8,
    actionOnEmptyResult: true,
    action: "/voice/process",
    method: "POST",
  });

  gather.say({ voice: "Polly.Aditi", language: "hi-IN" }, text);
}

function extractServiceDate(text) {
  if (!text) return null;

  const cleaned = text.toLowerCase();
  const today = new Date();

  // Handle relative dates first
  if (/\baaj\b|\btoday\b|\b‡§Ü‡§ú\b/i.test(cleaned)) {
    return today;
  }

  if (/\bkal\b|\btomorrow\b|\b‡§ï‡§≤\b/i.test(cleaned)) {
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);
    return tomorrow;
  }

  if (/\bparso\b|\b‡§™‡§∞‡§∏‡•ã‡§Ç\b|\b‡§™‡§∞‡§∏‡•ã\b/i.test(cleaned)) {
    const dayAfter = new Date(today);
    dayAfter.setDate(dayAfter.getDate() + 2);
    return dayAfter;
  }

  // Try to extract actual date (DD/MM or DD Month format)
  const months = {
    'january': 1, 'jan': 1, '‡§ú‡§®‡§µ‡§∞‡•Ä': 1,
    'february': 2, 'feb': 2, '‡§´‡§∞‡§µ‡§∞‡•Ä': 2,
    'march': 3, 'mar': 3, '‡§Æ‡§æ‡§∞‡•ç‡§ö': 3,
    'april': 4, 'apr': 4, '‡§Ö‡§™‡•ç‡§∞‡•à‡§≤': 4,
    'may': 5, '‡§Æ‡§à': 5,
    'june': 6, 'jun': 6, '‡§ú‡•Ç‡§®': 6,
    'july': 7, 'jul': 7, '‡§ú‡•Å‡§≤‡§æ‡§à': 7,
    'august': 8, 'aug': 8, '‡§Ö‡§ó‡§∏‡•ç‡§§': 8,
    'september': 9, 'sep': 9, '‡§∏‡§ø‡§§‡§Ç‡§¨‡§∞': 9,
    'october': 10, 'oct': 10, '‡§Ö‡§ï‡•ç‡§ü‡•Ç‡§¨‡§∞': 10,
    'november': 11, 'nov': 11, '‡§®‡§µ‡§Ç‡§¨‡§∞': 11,
    'december': 12, 'dec': 12, '‡§¶‡§ø‡§∏‡§Ç‡§¨‡§∞': 12
  };

  // Try DD/MM format - "13/2", "13-2"
  const dateMatch1 = cleaned.match(/(\d{1,2})[\/\-](\d{1,2})/);
  if (dateMatch1) {
    const day = parseInt(dateMatch1[1]);
    const month = parseInt(dateMatch1[2]);
    if (day >= 1 && day <= 31 && month >= 1 && month <= 12) {
      const date = new Date(today.getFullYear(), month - 1, day);
      // Make sure date is not in the past
      if (date >= today) {
        return date;
      }
      // If date is in the past, assume next year
      date.setFullYear(today.getFullYear() + 1);
      return date;
    }
  }

  // Try "DD Month" format - "13 february", "13 ‡§´‡§∞‡§µ‡§∞‡•Ä"
  const dateMatch2 = cleaned.match(/(\d{1,2})\s+(january|jan|february|feb|march|mar|april|apr|may|june|jun|july|jul|august|aug|september|sep|october|oct|november|nov|december|dec|‡§ú‡§®‡§µ‡§∞‡•Ä|‡§´‡§∞‡§µ‡§∞‡•Ä|‡§Æ‡§æ‡§∞‡•ç‡§ö|‡§Ö‡§™‡•ç‡§∞‡•à‡§≤|‡§Æ‡§à|‡§ú‡•Ç‡§®|‡§ú‡•Å‡§≤‡§æ‡§à|‡§Ö‡§ó‡§∏‡•ç‡§§|‡§∏‡§ø‡§§‡§Ç‡§¨‡§∞|‡§Ö‡§ï‡•ç‡§ü‡•Ç‡§¨‡§∞|‡§®‡§µ‡§Ç‡§¨‡§∞|‡§¶‡§ø‡§∏‡§Ç‡§¨‡§∞)/i);
  if (dateMatch2) {
    const day = parseInt(dateMatch2[1]);
    const monthName = dateMatch2[2].toLowerCase();
    const month = months[monthName];
    if (day >= 1 && day <= 31 && month) {
      const date = new Date(today.getFullYear(), month - 1, day);
      // Make sure date is not in the past
      if (date >= today) {
        return date;
      }
      // If date is in the past, assume next year
      date.setFullYear(today.getFullYear() + 1);
      return date;
    }
  }

  return null;
}

/* ======================= EXTERNAL API CALLS ======================= */

async function fetchCustomerFromExternal({ phone, chassisNo }) {
  try {
    let apiUrl = null;

    if (phone && isValidPhone(phone)) {
      apiUrl = `${EXTERNAL_API_BASE}/get_machine_by_phone_no.php?phone_no=${phone}`;
    } else if (chassisNo && isValidChassis(chassisNo)) {
      apiUrl = `${EXTERNAL_API_BASE}/get_machine_by_machine_no.php?machine_no=${chassisNo}`;
    }

    if (!apiUrl) {
      console.log("‚ö†Ô∏è No valid identifier for external API");
      return null;
    }

    console.log(`üåê Fetching from API: ${apiUrl}`);

    const response = await axios.get(apiUrl, {
      timeout: API_TIMEOUT,
      headers: API_HEADERS,
      validateStatus: (status) => status < 500,
    });

    if (
      response.status !== 200 ||
      !response.data ||
      response.data.status !== 1 ||
      !response.data.data
    ) {
      console.log("‚ö†Ô∏è API returned invalid response");
      return null;
    }

    const customerData = response.data.data;

    const normalized = {
      chassisNo: customerData.machine_no || chassisNo || "Unknown",
      phone: customerData.customer_phone_no || phone || "Unknown",
      name: customerData.customer_name || "Unknown",
      city: customerData.city || "Unknown",
      model: customerData.machine_model || "Unknown",
      subModel: customerData.sub_model || "NA",
      machineType: customerData.machine_type || "Unknown",
      businessPartnerCode: customerData.business_partner_code || "NA",
      purchaseDate: customerData.purchase_date || "NA",
      installationDate: customerData.installation_date || "NA",
    };

    console.log("‚úÖ Customer data fetched successfully");
    return normalized;

  } catch (error) {
    console.error("‚ùå API Fetch Error:", error.message);
    return null;
  }
}

/* ======================= HINDI TO ENGLISH TRANSLATION - COMPREHENSIVE ======================= */
async function translateHindiToEnglish(text) {
  if (!text || typeof text !== 'string') return text;
  
  // Check if text contains Hindi characters
  const hindiRegex = /[\u0900-\u097F]/;
  if (!hindiRegex.test(text)) {
    return text; // Already in English or no Hindi detected
  }

  try {
    console.log(`üî§ Translating to English: "${text.substring(0, 50)}..."`);
    
    // Comprehensive Hindi-to-English dictionary
    const hindiToEnglishDict = {
      // Common words
      '‡§®‡§Æ‡§∏‡•ç‡§§‡•á': 'Hello',
      '‡§ß‡§®‡•ç‡§Ø‡§µ‡§æ‡§¶': 'Thank You',
      '‡§ï‡•É‡§™‡§Ø‡§æ': 'Please',
      '‡§Æ‡•á‡§∞‡§æ': 'My',
      '‡§Æ‡•á‡§∞‡•Ä': 'My',
      '‡§®‡§æ‡§Æ': 'Name',
      '‡§Æ‡§∂‡•Ä‡§®': 'Machine',
      '‡§ñ‡§∞‡§æ‡§¨': 'Broken',
      '‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ': 'Problem',
      '‡§ï‡§æ‡§Æ': 'Work',
      '‡§®‡§π‡•Ä‡§Ç': 'No',
      '‡§π‡§æ‡§Å': 'Yes',
      '‡§π‡§æ‡§Ç': 'Yes',
      '‡§ò‡§∞': 'Home',
      '‡§¶‡•Å‡§ï‡§æ‡§®': 'Shop',
      '‡§ó‡•à‡§∞‡•á‡§ú': 'Garage',
      '‡§∏‡•á‡§µ‡§æ': 'Service',
      '‡§Æ‡§∞‡§Æ‡•ç‡§Æ‡§§': 'Repair',
      '‡§ó‡§æ‡§Ç‡§µ': 'Village',
      '‡§∂‡§π‡§∞': 'City',
      '‡§∏‡§°‡§º‡§ï': 'Road',
      '‡§á‡§Ç‡§ú‡§®': 'Engine',
      '‡§¨‡•ç‡§∞‡•á‡§ï': 'Brake',
      '‡§ü‡§æ‡§Ø‡§∞': 'Tire',
      '‡§¨‡•à‡§ü‡§∞‡•Ä': 'Battery',
      '‡§ñ‡•Å‡§≤‡•ç‡§≤‡•Ä': 'Open',
      '‡§¨‡§Ç‡§¶': 'Closed',
      '‡§™‡§æ‡§®‡•Ä': 'Water',
      '‡§§‡•á‡§≤': 'Oil',
      '‡§∞‡§ø‡§∏‡§æ‡§µ': 'Leakage',
      '‡§§‡•á‡§ú‡§º': 'Fast',
      '‡§ß‡•Ä‡§Æ‡§æ': 'Slow',
      '‡§∂‡•ã‡§∞': 'Noise',
      '‡§ï‡§Ç‡§™‡§®': 'Vibration',
      '‡§ß‡•Å‡§Ü‡§Å': 'Smoke',
      '‡§ö‡§≤': 'Running',
      '‡§¨‡§Ç‡§¶': 'Stop',
      '‡§∏‡•ç‡§ü‡§æ‡§∞‡•ç‡§ü': 'Start',
      '‡§∏‡•ç‡§ï‡•ÇŸÑ': 'School',
      '‡§ï‡•â‡§≤‡•á‡§ú': 'College',
      '‡§´‡•à‡§ï‡•ç‡§ü‡•ç‡§∞‡•Ä': 'Factory',
      '‡§ñ‡•á‡§§': 'Field',
      '‡§Æ‡•á‡§∞‡•á': 'My',
      '‡§Ü‡§™‡§ï‡§æ': 'Your',
      '‡§â‡§∏‡§ï‡§æ': 'His',
      '‡§â‡§∏‡§ï‡•Ä': 'Her',
      '‡§π‡§Æ‡§æ‡§∞‡§æ': 'Our',
      '‡§â‡§®‡§ï‡§æ': 'Their',
      '‡§ú‡•ã': 'Which',
      '‡§ï‡•ç‡§Ø‡§æ': 'What',
      '‡§ï‡§¨': 'When',
      '‡§ï‡§π‡§æ‡§Å': 'Where',
      '‡§ï‡•à‡§∏‡•á': 'How',
      '‡§ï‡•ç‡§Ø‡•ã‡§Ç': 'Why',
      '‡§ï‡§ø‡§§‡§®‡§æ': 'How much',
      '‡§¶‡§ø‡§®': 'Day',
      '‡§∞‡§æ‡§§': 'Night',
      '‡§∏‡•Å‡§¨‡§π': 'Morning',
      '‡§¶‡•ã‡§™‡§π‡§∞': 'Afternoon',
      '‡§∂‡§æ‡§Æ': 'Evening',
      '‡§Æ‡§π‡•Ä‡§®‡§æ': 'Month',
      '‡§∏‡§æ‡§≤': 'Year',
      '‡§∏‡§™‡•ç‡§§‡§æ‡§π': 'Week',
      '‡§à‡§Ç‡§ß‡§®': 'Fuel',
      '‡§∏‡§∞‡•ç‡§µ‡§ø‡§∏': 'Service',
      '‡§µ‡§æ‡§∞‡§Ç‡§ü‡•Ä': 'Warranty',
      '‡§®‡•Å‡§ï‡§∏‡§æ‡§®': 'Damage',
      '‡§ñ‡§§‡§∞‡§æ': 'Danger',
      '‡§†‡•Ä‡§ï': 'Fine',
      '‡§∏‡§π‡•Ä': 'Correct',
      '‡§ó‡§≤‡§§': 'Wrong',
      '‡§™‡•Ç‡§∞‡§æ': 'Full',
      '‡§Ü‡§ß‡§æ': 'Half',
      '‡§™‡§π‡§≤‡§æ': 'First',
      '‡§¶‡•Ç‡§∏‡§∞‡§æ': 'Second',
      '‡§§‡•Ä‡§∏‡§∞‡§æ': 'Third',
      '‡§è‡§ï': 'One',
      '‡§¶‡•ã': 'Two',
      '‡§§‡•Ä‡§®': 'Three',
      '‡§ö‡§æ‡§∞': 'Four',
      '‡§™‡§æ‡§Å‡§ö': 'Five',
      '‡§õ‡§É': 'Six',
      '‡§∏‡§æ‡§§': 'Seven',
      '‡§Ü‡§†': 'Eight',
      '‡§®‡•å': 'Nine',
      '‡§¶‡§∏': 'Ten',
      // Locations
      '‡§Ö‡§ú‡§Æ‡•á‡§∞': 'Ajmer',
      '‡§≠‡§∞‡§§‡§™‡•Å‡§∞': 'Bharatpur',
      '‡§¶‡§ø‡§≤‡•ç‡§≤‡•Ä': 'Delhi',
      '‡§á‡§≤‡§æ‡§π‡§æ‡§¨‡§æ‡§¶': 'Allahabad',
      '‡§ï‡§æ‡§®‡§™‡•Å‡§∞': 'Kanpur',
      '‡§≤‡§ñ‡§®‡§ä': 'Lucknow',
      '‡§Ü‡§ó‡§∞‡§æ': 'Agra',
      '‡§µ‡§æ‡§∞‡§æ‡§£‡§∏‡•Ä': 'Varanasi',
      '‡§Æ‡•Å‡§Ç‡§¨‡§à': 'Mumbai',
      '‡§™‡•Å‡§£‡•á': 'Pune',
      '‡§ö‡•á‡§®‡•ç‡§®‡§à': 'Chennai',
      '‡§ï‡•ã‡§≤‡§ï‡§æ‡§§‡§æ': 'Kolkata',
      '‡§¨‡•á‡§Ç‡§ó‡§≤‡•Å‡§∞‡•Å': 'Bangalore',
      '‡§π‡•à‡§¶‡§∞‡§æ‡§¨‡§æ‡§¶': 'Hyderabad',
      '‡§ú‡§Ø‡§™‡•Å‡§∞': 'Jaipur',
      '‡§≤‡•Å‡§ß‡§ø‡§Ø‡§æ‡§®‡§æ': 'Ludhiana',
      '‡§ö‡§Ç‡§°‡•Ä‡§ó‡§¢‡§º': 'Chandigarh',
      '‡§®‡§à ‡§¶‡§ø‡§≤‡•ç‡§≤‡•Ä': 'New Delhi',
      '‡§ó‡•Å‡§°‡§º‡§ó‡§æ‡§Ç‡§µ': 'Gurgaon',
      '‡§®‡•ã‡§è‡§°‡§æ': 'Noida',
      '‡§ó‡•ç‡§∞‡•á‡§ü‡§∞ ‡§®‡•ã‡§è‡§°‡§æ': 'Greater Noida',
      '‡§¨‡§∏ ‡§Ö‡§°‡•ç‡§°‡§æ': 'Bus Stand',
      '‡§∏‡•ç‡§ü‡•á‡§∂‡§®': 'Station',
      '‡§Ö‡§∏‡•ç‡§™‡§§‡§æ‡§≤': 'Hospital',
      '‡§™‡•Å‡§≤‡§ø‡§∏': 'Police',
      '‡§¨‡§æ‡§ú‡§æ‡§∞': 'Market',
      '‡§™‡§æ‡§∞‡•ç‡§ï': 'Park',
      '‡§Æ‡§Ç‡§¶‡§ø‡§∞': 'Temple',
      '‡§Æ‡§∏‡•ç‡§ú‡§ø‡§¶': 'Mosque',
      '‡§ö‡§∞‡•ç‡§ö': 'Church',
      '‡§ó‡•Å‡§∞‡•Å‡§¶‡•ç‡§µ‡§æ‡§∞‡§æ': 'Gurudwara',
      '‡§®‡§ú‡§º‡§¶‡•Ä‡§ï': 'Near',
      '‡§™‡§æ‡§∏': 'Near',
      '‡§∏‡§æ‡§Æ‡§®‡•á': 'Opposite',
      '‡§™‡•Ä‡§õ‡•á': 'Behind',
      '‡§ä‡§™‡§∞': 'Above',
      '‡§®‡•Ä‡§ö‡•á': 'Below',
      '‡§¨‡§æ‡§à‡§Ç': 'Left',
      '‡§¶‡§æ‡§à‡§Ç': 'Right',
    };

    let translatedText = text;
    
    // Apply dictionary translations (longest words first to avoid partial matches)
    const sortedEntries = Object.entries(hindiToEnglishDict).sort((a, b) => b[0].length - a[0].length);
    
    for (const [hindi, english] of sortedEntries) {
      const regex = new RegExp(`\\b${hindi}\\b`, 'gi');
      translatedText = translatedText.replace(regex, english);
    }

    // Devanagari to Latin transliteration for remaining Hindi characters
    const devanagariToLatin = {
      '‡§Ö': 'A', '‡§Ü': 'AA', '‡§á': 'I', '‡§à': 'II', '‡§â': 'U', '‡§ä': 'UU', '‡§ã': 'RI', '‡§è': 'E', '‡§ê': 'AI', '‡§ì': 'O', '‡§î': 'AU',
      '‡§ï': 'K', '‡§ñ': 'KH', '‡§ó': 'G', '‡§ò': 'GH', '‡§ô': 'N', '‡§ö': 'CH', '‡§õ': 'CHH', '‡§ú': 'J', '‡§ù': 'JH', '‡§û': 'NY', 
      '‡§ü': 'T', '‡§†': 'TH', '‡§°': 'D', '‡§¢': 'DH', '‡§£': 'N', '‡§§': 'T', '‡§•': 'TH', '‡§¶': 'D', '‡§ß': 'DH', '‡§®': 'N', 
      '‡§™': 'P', '‡§´': 'PH', '‡§¨': 'B', '‡§≠': 'BH', '‡§Æ': 'M', '‡§Ø': 'Y', '‡§∞': 'R', '‡§≤': 'L', '‡§µ': 'V', 
      '‡§∂': 'SH', '‡§∑': 'SH', '‡§∏': 'S', '‡§π': 'H',
      '‡§æ': 'A', '‡§ø': 'I', '‡•Ä': 'II', '‡•Å': 'U', '‡•Ç': 'UU', '‡•É': 'RI', '‡•á': 'E', '‡•à': 'AI', '‡•ã': 'O', '‡•å': 'AU',
      '‡§É': 'H', '‡§Å': 'N', '‡§Ç': 'N',
      '‡•¶': '0', '‡•ß': '1', '‡•®': '2', '‡•©': '3', '‡•™': '4', '‡•´': '5', '‡•¨': '6', '‡•≠': '7', '‡•Æ': '8', '‡•Ø': '9'
    };

    // Apply transliteration for any remaining Devanagari characters
    for (const [devanagari, latin] of Object.entries(devanagariToLatin)) {
      const regex = new RegExp(devanagari, 'g');
      translatedText = translatedText.replace(regex, latin);
    }

    // Clean up: remove extra spaces and special characters
    translatedText = translatedText.replace(/\s+/g, ' ').trim();
    translatedText = translatedText.replace(/[^a-zA-Z0-9\s\-\.]/g, ''); // Remove non-ASCII except space, dash, dot

    if (translatedText && translatedText !== text) {
      console.log(`‚úÖ Translated: "${translatedText.substring(0, 50)}..."`);
      return translatedText;
    }

    console.log(`‚ö†Ô∏è Could not fully translate: "${text.substring(0, 50)}..."`);
    return translatedText || text;

  } catch (error) {
    console.error("‚ùå Translation Error:", error.message);
    return text;
  }
}
function mergeLocationAndPincode(address, pincode) {
  if (!address && !pincode) return "Not Provided";
  if (!address) return pincode;
  if (!pincode) return address;
  
  // Merge with comma separator
  return `${address}, ${pincode}`;
}

/* ======================= FORMAT TIME TO 12-HOUR WITH AM/PM ======================= */
function formatTimeToTwelveHour(timeString) {
  if (!timeString) return "";
  
  // If already in HH:MM AM/PM format, return as-is
  if (/\d{1,2}:\d{2}\s*(AM|PM)/.test(timeString)) {
    return timeString;
  }
  
  // Extract time from different formats
  const match = timeString.match(/(\d{1,2}):?(\d{2})?/);
  if (!match) return timeString;
  
  let hour = parseInt(match[1]);
  const minute = match[2] || '00';
  
  // Ensure PM times are in 24-hour format first if needed
  const isPM = hour > 12 || /pm|evening|shaam|duphare/.test(timeString.toLowerCase());
  
  if (isPM && hour <= 12) {
    hour = hour === 12 ? 12 : hour + 12;
  }
  
  // Convert back to 12-hour format
  const displayHour = hour > 12 ? hour - 12 : (hour === 0 ? 12 : hour);
  const period = hour >= 12 ? 'PM' : 'AM';
  
  return `${String(displayHour).padStart(2, '0')}:${minute} ${period}`;
}

async function submitComplaintToExternal(complaintData) {
  try {
    console.log("\n" + "=".repeat(120));
    console.log("üåê SUBMITTING COMPLAINT TO EXTERNAL API");
    console.log("=".repeat(120));
    console.log("üì§ REQUEST DATA:");
    console.log(JSON.stringify(complaintData, null, 2));
    console.log("=".repeat(120));

    const response = await axios.post(COMPLAINT_API_URL, complaintData, {
      timeout: API_TIMEOUT,
      headers: {
        "Content-Type": "application/json",
        ...API_HEADERS
      },
      validateStatus: (status) => status < 500,
    });

    console.log("\n" + "=".repeat(120));
    console.log("üì• API RESPONSE:");
    console.log("=".repeat(120));
    console.log(`Status Code: ${response.status}`);
    console.log(`Response Data: ${JSON.stringify(response.data, null, 2)}`);
    console.log("=".repeat(120) + "\n");

    if (
      response.status !== 200 ||
      !response.data ||
      response.data.status !== 1
    ) {
      console.log("‚ö†Ô∏è API Rejected:", response.data?.message || "Unknown error");
      return {
        success: false,
        error: response.data?.message || "API rejected"
      };
    }

    const sapId = response.data.data?.complaint_sap_id ||
                  response.data.data?.sap_id ||
                  null;

    console.log("‚úÖ Complaint submitted successfully. SAP ID:", sapId);

    return {
      success: true,
      data: response.data,
      sapId
    };

  } catch (error) {
    console.error("‚ùå Submit Error:", error.message);
    console.error("Error Details:", error.response?.data || error);
    return {
      success: false,
      error: error.message
    };
  }
}

/* ======================= SAVE COMPLAINT ======================= */

async function saveComplaint(twiml, callData) {
  try {
    const customerData = callData.customerData;
    const branchOutlet = detectBranchAndOutlet(customerData.city);

    const installationDate = customerData.installationDate &&
                            customerData.installationDate !== "NA"
      ? formatDateForExternal(customerData.installationDate)
      : null;

    // Translate Hindi fields to English before creating complaint data
    const translatedCallerName = await translateHindiToEnglish(callData.callerName || "Not Provided");
    const translatedComplaintDetails = await translateHindiToEnglish(callData.rawComplaint || "Not provided");
    const translatedAddress = await translateHindiToEnglish(callData.address || "Not Provided");
    const translatedJobLocation = await translateHindiToEnglish(callData.jobLocation || "Onsite");
    const translatedMachineStatus = await translateHindiToEnglish(callData.machineStatus || "Running With Problem");
    const translatedMachineType = await translateHindiToEnglish(callData.machineType || "Warranty");
    const translatedComplaintTitle = await translateHindiToEnglish(callData.complaintTitle || "General Problem");
    const translatedComplaintSubTitle = await translateHindiToEnglish(callData.complaintSubTitle || "Other");

    // Merge address and pincode into single machine_location field
    const mergedLocation = mergeLocationAndPincode(translatedAddress, callData.pincode || "");
    
    // Format times to 12-hour with PM
    const formattedFromTime = formatTimeToTwelveHour(callData.fromTime || "");
    const formattedToTime = formatTimeToTwelveHour(callData.toTime || "");

    const complaintApiData = {
      machine_no: callData.chassis || "Unknown",
      customer_name: safeAscii(customerData.name),
      caller_name: translatedCallerName,
      caller_no: callData.callerPhone || customerData.phone,
      contact_person: translatedCallerName,
      contact_person_number: callData.callerPhone || customerData.phone,
      machine_model: customerData.machineType || "Unknown",
      sub_model: customerData.model || "NA",
      installation_date: installationDate || "2025-01-01",
      machine_type: translatedMachineType,
      city_id: branchOutlet.cityCode,
      complain_by: "Customer",
      machine_status: translatedMachineStatus,
      job_location: translatedJobLocation,
      branch: branchOutlet.branch,
      outlet: branchOutlet.outlet,
      complaint_details: translatedComplaintDetails,
      complaint_title: translatedComplaintTitle,
      sub_title: translatedComplaintSubTitle,
      business_partner_code: customerData.businessPartnerCode || "NA",
      complaint_sap_id: "NA",
      machine_location: mergedLocation,
      service_date: callData.serviceDate
        ? formatDateForExternal(callData.serviceDate)
        : "",
      from_time: formattedFromTime,
      to_time: formattedToTime,
      job_close_lat: "0.000000",
      job_close_lng: "0.000000",
      job_open_lat: "0.000000",
      job_open_lng: "0.000000",
    };

    // ===== LOG API DATA IN ENGLISH BEFORE SENDING =====
    console.log("\n" + "=".repeat(120));
    console.log("üì§ SENDING TO EXTERNAL API - ALL DATA IN ENGLISH");
    console.log("=".repeat(120));
    console.log(`üì± Caller Name: ${translatedCallerName}`);
    console.log(`‚òéÔ∏è  Contact Person: ${translatedCallerName}`);
    console.log(`üìç Machine Location: ${mergedLocation}`);
    console.log(`üî¥ Machine Status: ${translatedMachineStatus}`);
    console.log(`üè¢ Service Plan: ${translatedMachineType}`);
    console.log(`üéØ Complaint: ${translatedComplaintTitle}`);
    console.log(`üìù Sub-Complaint: ${translatedComplaintSubTitle}`);
    console.log(`üí¨ Description: ${translatedComplaintDetails.substring(0, 80)}...`);
    console.log(`üìÖ Date: ${complaintApiData.service_date}`);
    console.log(`‚è∞ Time: ${formattedFromTime} - ${formattedToTime}`);
    console.log("=".repeat(120) + "\n");

    // Submit to external API
    const externalResult = await submitComplaintToExternal(complaintApiData);
    let sapId = null;

    if (externalResult.success) {
      sapId = externalResult.sapId;
      console.log("‚úÖ Data successfully posted to external API");
    } else {
      console.log("‚ö†Ô∏è External API submission failed:", externalResult.error);
    }

    const complaintDbData = {
      machineNo: callData.chassis || "Unknown",
      chassisNo: callData.chassis || "Unknown",
      customerName: safeAscii(customerData.name),
      registeredPhone: customerData.phone || "Unknown",
      machineModel: customerData.model || "Unknown",
      machineType: translatedMachineType,
      machineStatus: translatedMachineStatus,
      jobLocation: translatedJobLocation,
      complaintGivenByName: translatedCallerName,
      complaintGivenByPhone: callData.callerPhone || "Unknown",
      machineInstallationDate: installationDate ? new Date(installationDate) : null,
      description_raw: translatedComplaintDetails,
      complaintTitle: translatedComplaintTitle,
      complaintSubTitle: translatedComplaintSubTitle,
      complaintSapId: sapId || null,
      branch: branchOutlet.branch,
      outlet: branchOutlet.outlet,
      source: "IVR_VOICE_BOT",
      machineLocationAddress: translatedAddress,
      machineLocationPincode: callData.pincode || "",
      serviceDate: callData.serviceDate || null,
      fromTime: callData.fromTime || "",
      toTime: callData.toTime || "",
    };

    // ===== LOG DATABASE DATA IN ENGLISH BEFORE SAVING =====
    console.log("\n" + "=".repeat(120));
    console.log("üíæ SAVING TO DATABASE - COMPLAINT DATA IN ENGLISH");
    console.log("=".repeat(120));
    console.log(`üîß Machine Number: ${complaintDbData.machineNo}`);
    console.log(`üë§ Caller Name (English): ${complaintDbData.complaintGivenByName}`);
    console.log(`üìç Location (English): ${complaintDbData.machineLocationAddress}`);
    console.log(`üìÆ Pincode: ${complaintDbData.machineLocationPincode}`);
    console.log(`üéØ Complaint (English): ${complaintDbData.complaintTitle} ‚Üí ${complaintDbData.complaintSubTitle}`);
    console.log(`üí¨ Description (English): ${complaintDbData.description_raw.substring(0, 80)}...`);
    console.log(`üìÖ Service Date: ${complaintDbData.serviceDate}`);
    console.log("=".repeat(120) + "\n");

    // Save to MongoDB
    console.log("\n" + "=".repeat(120));
    console.log("üíæ SAVING COMPLAINT TO DATABASE");
    console.log("=".repeat(120));
    console.log("üìù DATABASE PAYLOAD:");
    console.log(JSON.stringify(complaintDbData, null, 2));
    console.log("=".repeat(120));

    const savedComplaint = await Complaint.create(complaintDbData);
    
    console.log("\n" + "=".repeat(120));
    console.log("‚úÖ COMPLAINT SUCCESSFULLY SAVED TO DATABASE");
    console.log("=".repeat(120));
    console.log(`Database ID: ${savedComplaint._id}`);
    console.log(`SAP ID: ${sapId}`);
    console.log(`Machine: ${callData.chassis}`);
    console.log(`Customer: ${customerData.name}`);
    console.log(`Type: ${callData.machineType}`);
    console.log(`Status: ${callData.machineStatus}`);
    console.log("=".repeat(120) + "\n");

    return { success: true, sapId };

  } catch (error) {
    console.error("\n" + "‚ùå".repeat(60));
    console.error("DATABASE ERROR:", error.message);
    console.error("‚ùå".repeat(60) + "\n");
    return { success: false, error: error.message };
  }
}

/* ======================= INCOMING CALL HANDLER ======================= */

router.post("/", async (req, res) => {
  const { CallSid, From } = req.body;
  const twiml = new VoiceResponse();

  activeCalls.set(CallSid, {
    callSid: CallSid,
    from: From,
    step: "ivr_menu",
    retries: 0,
  });

  const gather = twiml.gather({
    input: "dtmf",
    numDigits: 1,
    timeout: 5,
    action: "/voice/process",
    method: "POST",
  });

  gather.say(
    { voice: "Polly.Aditi", language: "hi-IN" },
    "‡§®‡§Æ‡§∏‡•ç‡§§‡•á! ‡§∞‡§æ‡§ú‡•á‡§∂ JCB ‡§Æ‡•ã‡§ü‡§∞‡•ç‡§∏ ‡§Æ‡•á‡§Ç ‡§Ü‡§™‡§ï‡§æ ‡§∏‡•ç‡§µ‡§æ‡§ó‡§§ ‡§π‡•à‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§π‡•à‡§Ç‡•§ ‡§Ü‡§™‡§ï‡•Ä ‡§ï‡•â‡§≤ ‡§¶‡§∞‡•ç‡§ú ‡§ï‡•Ä ‡§ú‡§æ ‡§∞‡§π‡•Ä ‡§π‡•à‡•§ Complaint register ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§è‡§ï ‡§¶‡§¨‡§æ‡§è‡§Ç‡•§ ‡§Ö‡§ó‡§∞ ‡§Ü‡§™ ‡§ï‡§ø‡§∏‡•Ä agent ‡§∏‡•á ‡§¨‡§æ‡§§ ‡§ï‡§∞‡§®‡§æ ‡§ö‡§æ‡§π‡§§‡•á ‡§π‡•à‡§Ç ‡§§‡•ã ‡§¶‡•ã ‡§¶‡§¨‡§æ‡§è‡§Ç‡•§"
    // "Namaste! Rajesh JCB Motors mein aapka swagat hai. Complaint register karne ke liye ek dabayein. Agar aap kisi agent se baat karna chahte hain to do dabayien."
  );

  res.type("text/xml").send(twiml.toString());
});

/* ======================= MAIN PROCESSING HANDLER ======================= */

router.post("/process", async (req, res) => {
  try {
    const twiml = new VoiceResponse();
    const { CallSid, Digits, SpeechResult } = req.body;

    let callData = activeCalls.get(CallSid);

    if (!callData) {
      callData = {
        callSid: CallSid,
        step: "ivr_menu",
        retries: 0,
      };
      activeCalls.set(CallSid, callData);
    }

    if (!SpeechResult && !Digits) {
      const lastQ = callData.lastQuestion || "Kripya apna jawab bolein.";
      ask(twiml, lastQ);
      activeCalls.set(CallSid, callData);
      return res.type("text/xml").send(twiml.toString());
    }

    // ===== IVR MENU =====
    if (callData.step === "ivr_menu") {
      if (Digits === "2") {
        twiml.say(
          { voice: "Polly.Aditi", language: "hi-IN" },
          "‡§†‡•Ä‡§ï ‡§π‡•à‡•§ ‡§Ü‡§™‡§ï‡•ã ‡§è‡§ú‡•á‡§Ç‡§ü ‡§∏‡•á ‡§ú‡•ã‡§°‡§º‡§æ ‡§ú‡§æ ‡§∞‡§π‡§æ ‡§π‡•à‡•§"
        );
        twiml.dial(process.env.HUMAN_AGENT_NUMBER);
        activeCalls.delete(CallSid);
        return res.type("text/xml").send(twiml.toString());
      }

      if (Digits === "1") {
        callData.step = "ask_identifier";
        callData.retries = 0;
        callData.lastQuestion = "‡§ï‡•É‡§™‡§Ø‡§æ ‡§Ö‡§™‡§®‡§æ ‡§Æ‡§∂‡•Ä‡§® ‡§®‡§Ç‡§¨‡§∞ ‡§Ø‡§æ ‡§´‡•ã‡§® ‡§®‡§Ç‡§¨‡§∞ ‡§¨‡•ã‡§≤‡§ø‡§è ‡§Ø‡§æ ‡§¶‡§∞‡•ç‡§ú ‡§ï‡§∞‡•á‡§Ç‡•§ ‡§¶‡§∞‡•ç‡§ú ‡§ï‡§∞‡§§‡•á ‡§∏‡§Æ‡§Ø ‡§™‡•Ç‡§∞‡§æ ‡§π‡•ã‡§®‡•á ‡§™‡§∞ ‡§π‡•à‡§∂ ‡§¶‡§¨‡§æ‡§è‡§Å‡•§";
        const gather = twiml.gather({
          input: "dtmf speech",
          hints: "machine number, phone number, chassis, ‡§Æ‡§∂‡•Ä‡§® ‡§®‡§Ç‡§¨‡§∞, ‡§´‡•ã‡§® ‡§®‡§Ç‡§¨‡§∞, ‡§ö‡•á‡§∏‡§ø‡§∏",
          finishOnKey: "#",
          timeout: 30,
          actionOnEmptyResult: true,
          action: "/voice/process",
          method: "POST",
        });
        gather.say({ voice: "Polly.Aditi", language: "hi-IN" }, callData.lastQuestion);
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      }

      askDTMF(twiml, "‡§ï‡•É‡§™‡§Ø‡§æ ‡§è‡§ï ‡§Ø‡§æ ‡§¶‡•ã ‡§¶‡§¨‡§æ‡§á‡§è‡•§", 1);
      activeCalls.set(CallSid, callData);
      return res.type("text/xml").send(twiml.toString());
    }

    const rawSpeech = cleanSpeech(SpeechResult || "");

    console.log("\n" + "=".repeat(120));
    console.log(`üìû CALL: ${CallSid} | STEP: ${callData.step}`);
    console.log(`üé§ CUSTOMER: "${SpeechResult}" || üî¢ DIGITS: "${Digits}"`);
    console.log(`üßπ CLEANED: "${rawSpeech}"`);
    console.log("=".repeat(120));

    // ===== CONFIRM MACHINE NUMBER =====
    if (callData.step === "confirm_identifier") {
      if (Digits === "1") {
        // User confirmed the number is correct
        console.log(`‚úÖ User confirmed number: ${callData.lastAttemptedNumber}`);
        callData.step = "ask_identifier";
        callData.identifier = callData.lastAttemptedNumber;
        // Continue with the rest of ask_identifier logic (fetch from API, etc.)
        // Trigger re-entry by continuing to next handler
        const identifier = callData.lastAttemptedNumber;
        callData.chassis = identifier;
        
        // Now fetch from API
        const customerData = await fetchCustomerFromExternal({ 
          phone: /^\d{10}$/.test(identifier) ? identifier : null,
          chassisNo: !/^\d{10}$/.test(identifier) ? identifier : null
        });

        if (!customerData) {
          console.log("‚ùå Machine not found in API database even after confirmation");
          twiml.say(
            { voice: "Polly.Aditi", language: "hi-IN" },
            "‡§á‡§∏ ‡§®‡§Ç‡§¨‡§∞ ‡§ï‡•Ä ‡§Æ‡§∂‡•Ä‡§® ‡§π‡§Æ‡§æ‡§∞‡•á ‡§™‡§æ‡§∏ ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à‡•§ ‡§Ü‡§™‡§ï‡•ã ‡§è‡§ú‡•á‡§Ç‡§ü ‡§∏‡•á ‡§ú‡•ã‡§°‡§º‡§æ ‡§ú‡§æ ‡§∞‡§π‡§æ ‡§π‡•à‡•§"
          );
          twiml.dial(process.env.HUMAN_AGENT_NUMBER);
          activeCalls.delete(CallSid);
          return res.type("text/xml").send(twiml.toString());
        }

        callData.chassis = identifier;
        callData.customerData = customerData;
        callData.isRegistered = true;
        callData.step = "ask_caller_name";
        callData.retries = 0;
        callData.lastQuestion = "‡§†‡•Ä‡§ï ‡§π‡•à! ‡§Æ‡§∂‡•Ä‡§® ‡§ï‡§æ ‡§∞‡§ø‡§ï‡•â‡§∞‡•ç‡§° ‡§Æ‡§ø‡§≤ ‡§ó‡§Ø‡§æ‡•§ ‡§Ö‡§¨ ‡§Ö‡§™‡§®‡§æ ‡§™‡•Ç‡§∞‡§æ ‡§®‡§æ‡§Æ ‡§¨‡§§‡§æ‡§á‡§è, ‡§ï‡•É‡§™‡§Ø‡§æ‡•§";
        ask(twiml, callData.lastQuestion);
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      } else if (Digits === "2") {
        // User said the number is incorrect
        console.log(`‚ùå User rejected number: ${callData.lastAttemptedNumber} - Asking to re-enter`);
        callData.step = "ask_identifier";
        callData.retries = 0;
        callData.lastAttemptedNumber = null;
        callData.lastQuestion = "‡§ï‡•ã‡§à ‡§¨‡§æ‡§§ ‡§®‡§π‡•Ä‡§Ç‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§∏‡§π‡•Ä ‡§Æ‡§∂‡•Ä‡§® ‡§®‡§Ç‡§¨‡§∞ ‡§Ø‡§æ ‡§´‡•ã‡§® ‡§®‡§Ç‡§¨‡§∞ ‡§¨‡•ã‡§≤‡§ø‡§è ‡§Ø‡§æ ‡§¶‡§∞‡•ç‡§ú ‡§ï‡§∞‡•á‡§Ç‡•§";
        const gather = twiml.gather({
          input: "dtmf speech",
          hints: "machine number, phone number, ‡§Æ‡§∂‡•Ä‡§® ‡§®‡§Ç‡§¨‡§∞, ‡§´‡•ã‡§® ‡§®‡§Ç‡§¨‡§∞",
          finishOnKey: "#",
          timeout: 30,
          actionOnEmptyResult: true,
          action: "/voice/process",
          method: "POST",
        });
        gather.say({ voice: "Polly.Aditi", language: "hi-IN" }, callData.lastQuestion);
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      } else {
        // Invalid input
        askDTMF(twiml, "‡§ï‡•É‡§™‡§Ø‡§æ ‡§è‡§ï ‡§¶‡§¨‡§æ‡§á‡§è ‡§∏‡§π‡•Ä ‡§π‡•à ‡§§‡•ã, ‡§¶‡•ã ‡§¶‡§¨‡§æ‡§á‡§è ‡§ó‡§≤‡§§ ‡§π‡•à ‡§§‡•ã‡•§", 1);
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      }
    }

    // ===== ASK IDENTIFIER FOR NON-REGISTERED =====
    if (callData.step === "ask_identifier") {
      // Handle STAR (*) key to repeat last question
      if (Digits === "*") {
        console.log("üîÑ User pressed * - Repeating last question");
        const gather = twiml.gather({
          input: "dtmf speech",
          hints: "machine number, phone number, chassis, ‡§Æ‡§∂‡•Ä‡§® ‡§®‡§Ç‡§¨‡§∞, ‡§´‡•ã‡§® ‡§®‡§Ç‡§¨‡§∞",
          finishOnKey: "#",
          timeout: 30,
          numDigits: 1,
          actionOnEmptyResult: true,
          action: "/voice/process",
          method: "POST",
        });
        gather.say({ voice: "Polly.Aditi", language: "hi-IN" }, callData.lastQuestion);
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      }

      // Check if user provided DTMF digits (chassis/phone number)
      let inputToProcess = rawSpeech;
      
      if (Digits && Digits.trim().length > 0) {
        console.log(`üî¢ Processing DTMF input: "${Digits}"`);
        // Strip leading # if present (from #number# format)
        let cleanedDigits = Digits.trim();
        if (cleanedDigits.startsWith('#')) {
          cleanedDigits = cleanedDigits.substring(1);
        }
        // Strip trailing # if present
        if (cleanedDigits.endsWith('#')) {
          cleanedDigits = cleanedDigits.substring(0, cleanedDigits.length - 1);
        }
        inputToProcess = cleanedDigits;
        console.log(`üîß Cleaned DTMF: "${inputToProcess}"`);
      }

      // If no input at all
      if (!inputToProcess || inputToProcess.trim().length === 0) {
        callData.retries = (callData.retries || 0) + 1;
        console.log(`‚ö†Ô∏è No input received - Retry ${callData.retries}/3`);

        if (callData.retries >= 3) {
          console.log("‚ùå No input received after 3 retries - Escalating");
          twiml.say(
            { voice: "Polly.Aditi", language: "hi-IN" },
            "Samajh nahi paye. Aapko agent se connect kar rahe hain."
          );
          twiml.dial(process.env.HUMAN_AGENT_NUMBER);
          activeCalls.delete(CallSid);
          return res.type("text/xml").send(twiml.toString());
        }

        callData.lastQuestion = `‡§¶‡•ã‡§¨‡§æ‡§∞‡§æ ‡§™‡•ç‡§∞‡§Ø‡§æ‡§∏ ${callData.retries}/3: ‡§Æ‡§∂‡•Ä‡§® ‡§®‡§Ç‡§¨‡§∞ ‡§Ø‡§æ ‡§´‡•ã‡§® ‡§®‡§Ç‡§¨‡§∞ ‡§¨‡•ã‡§≤‡§ø‡§è ‡§Ø‡§æ ‡§¶‡§∞‡•ç‡§ú ‡§ï‡§∞‡•á‡§Ç‡•§`;
        const gather = twiml.gather({
          input: "dtmf speech",
          hints: "machine number, phone number, ‡§Æ‡§∂‡•Ä‡§® ‡§®‡§Ç‡§¨‡§∞, ‡§´‡•ã‡§® ‡§®‡§Ç‡§¨‡§∞",
          finishOnKey: "#",
          timeout: 30,
          actionOnEmptyResult: true,
          action: "/voice/process",
          method: "POST",
        });
        gather.say({ voice: "Polly.Aditi", language: "hi-IN" }, callData.lastQuestion);
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      }

      // Try to extract identifier from input (speech or DTMF)
      let chassis = null;
      let phone = null;

      // Keep full input as typed - don't remove duplicate digits
      let cleanedInput = inputToProcess;
      console.log(`üìå Numeric input detected: "${cleanedInput}"`);
      
      // If it looks like DTMF digits only, try both extraction methods
      if (/^\d+$/.test(cleanedInput)) {
        chassis = extractChassisNumberV2(cleanedInput);
        phone = extractPhoneNumberV2(cleanedInput);
      } else {
        // Mixed speech input
        chassis = extractChassisNumberV2(cleanedInput);
        phone = extractPhoneNumberV2(cleanedInput);
      }

      console.log(`‚úì Extracted - Chassis: ${chassis || "N/A"} | Phone: ${phone || "N/A"}`);

      let identifier = null;
      if (chassis && isValidChassis(chassis)) {
        identifier = chassis;
        console.log(`‚úÖ Using Chassis: ${identifier}`);
      } else if (phone && isValidPhone(phone)) {
        identifier = phone;
        console.log(`‚úÖ Using Phone: ${identifier}`);
      }

      if (!identifier) {
        callData.retries = (callData.retries || 0) + 1;
        console.log(`‚ö†Ô∏è Invalid identifier extracted - Retry ${callData.retries}/3`);

        if (callData.retries >= 3) {
          console.log("‚ùå No valid identifier found after 3 retries - Fetching from API with raw input");
          
          // Try direct API fetch with the raw input
          let apiUrl = null;
          if (/^\d{10}$/.test(inputToProcess)) {
            apiUrl = `${EXTERNAL_API_BASE}/get_machine_by_phone_no.php?phone_no=${inputToProcess}`;
            console.log(`üåê Trying Phone API: ${apiUrl}`);
          } else if (inputToProcess.length >= 7) {
            apiUrl = `${EXTERNAL_API_BASE}/get_machine_by_machine_no.php?machine_no=${inputToProcess}`;
            console.log(`üåê Trying Chassis API: ${apiUrl}`);
          }

          if (apiUrl) {
            try {
              const response = await axios.get(apiUrl, {
                timeout: API_TIMEOUT,
                headers: API_HEADERS,
                validateStatus: (status) => status < 500,
              });

              if (response.status === 200 && response.data?.status === 1 && response.data?.data) {
                console.log("‚úÖ Found in API with raw input!");
                identifier = cleanedInput;
              } else {
                console.log("‚ùå API returned no data - Asking for confirmation");
                // Give user a chance to confirm the number they entered
                callData.retries = (callData.retries || 0) + 1;
                callData.lastAttemptedNumber = cleanedInput;
                
                if (callData.retries >= 3) {
                  console.log("‚ùå Machine not found after 2 retries - Escalating");
                  twiml.say(
                    { voice: "Polly.Aditi", language: "hi-IN" },
                    `‡§Æ‡§æ‡§´ ‡§ï‡•Ä‡§ú‡§ø‡§è, ‡§Æ‡§∂‡•Ä‡§® ‡§®‡§Ç‡§¨‡§∞ ${digitsToHindi(cleanedInput)} ‡§π‡§Æ‡§æ‡§∞‡•á ‡§∞‡§ø‡§ï‡•â‡§∞‡•ç‡§° ‡§Æ‡•á‡§Ç ‡§®‡§π‡•Ä‡§Ç ‡§Æ‡§ø‡§≤ ‡§∞‡§π‡§æ‡•§ ‡§Ü‡§™‡§ï‡•ã ‡§è‡§ú‡•á‡§Ç‡§ü ‡§∏‡•á ‡§ú‡•ã‡§°‡§º‡§æ ‡§ú‡§æ ‡§∞‡§π‡§æ ‡§π‡•à‡•§`
                  );
                  twiml.dial(process.env.HUMAN_AGENT_NUMBER);
                  activeCalls.delete(CallSid);
                  return res.type("text/xml").send(twiml.toString());
                } else {
                  // Ask user to confirm the number
                  callData.step = "confirm_identifier";  // Set to confirmation step
                  callData.lastAttemptedNumber = cleanedInput;
                  callData.lastQuestion = `‡§Ü‡§™‡§ï‡§æ ‡§Æ‡§∂‡•Ä‡§® ‡§®‡§Ç‡§¨‡§∞ ‡§π‡•à: ${digitsToHindi(cleanedInput)}‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§™‡•Å‡§∑‡•ç‡§ü‡§ø ‡§ï‡§∞‡•á‡§Ç - ‡§Ø‡§π ‡§∏‡§π‡•Ä ‡§π‡•à ‡§§‡•ã ‡§è‡§ï ‡§¶‡§¨‡§æ‡§á‡§è, ‡§ó‡§≤‡§§ ‡§π‡•à ‡§§‡•ã ‡§¶‡•ã ‡§¶‡§¨‡§æ‡§á‡§è‡•§`;
                  askDTMF(twiml, callData.lastQuestion, 1);
                  activeCalls.set(CallSid, callData);
                  return res.type("text/xml").send(twiml.toString());
                }
              }
            } catch (error) {
              console.error("‚ùå API Error:", error.message);
              callData.retries = (callData.retries || 0) + 1;
              
              if (callData.retries >= 3) {
                twiml.say(
                  { voice: "Polly.Aditi", language: "hi-IN" },
                  "‡§∏‡§∞‡•ç‡§µ‡§∞ ‡§Æ‡•á‡§Ç ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§π‡•à‡•§ ‡§Ü‡§™‡§ï‡•ã ‡§è‡§ú‡•á‡§Ç‡§ü ‡§∏‡•á ‡§ú‡•ã‡§°‡§º‡§æ ‡§ú‡§æ ‡§∞‡§π‡§æ ‡§π‡•à‡•§"
                );
                twiml.dial(process.env.HUMAN_AGENT_NUMBER);
                activeCalls.delete(CallSid);
                return res.type("text/xml").send(twiml.toString());
              } else {
                callData.lastQuestion = `‡§ï‡•É‡§™‡§Ø‡§æ ‡§Æ‡§∂‡•Ä‡§® ‡§®‡§Ç‡§¨‡§∞ ‡§¶‡•ã‡§¨‡§æ‡§∞‡§æ ‡§¨‡•ã‡§≤‡§ø‡§è ‡§Ø‡§æ ‡§¶‡§∞‡•ç‡§ú ‡§ï‡§∞‡•á‡§Ç, ‡§´‡§ø‡§∞ ‡§π‡•à‡§∂ (#) key ‡§¶‡§¨‡§æ‡§á‡§è‡•§ (‡§™‡•ç‡§∞‡§Ø‡§æ‡§∏ ${callData.retries}/2)`;
                const gather = twiml.gather({
                  input: "dtmf speech",
                  hints: "machine number, chassis, ‡§Æ‡§∂‡•Ä‡§® ‡§®‡§Ç‡§¨‡§∞, ‡§ö‡•á‡§∏‡§ø‡§∏",
                  finishOnKey: "#",
                  timeout: 30,
                  actionOnEmptyResult: true,
                  action: "/voice/process",
                  method: "POST",
                });
                gather.say({ voice: "Polly.Aditi", language: "hi-IN" }, callData.lastQuestion);
                activeCalls.set(CallSid, callData);
                return res.type("text/xml").send(twiml.toString());
              }
            }
          } else {
            twiml.say(
              { voice: "Polly.Aditi", language: "hi-IN" },
              "‡§π‡§Æ ‡§Ü‡§™‡§ï‡•Ä ‡§™‡§π‡§ö‡§æ‡§® ‡§∏‡§Æ‡§ù ‡§®‡§π‡•Ä‡§Ç ‡§™‡§æ‡§è‡•§ ‡§Ü‡§™‡§ï‡•ã ‡§è‡§ú‡•á‡§Ç‡§ü ‡§∏‡•á ‡§ú‡•ã‡§°‡§º‡§æ ‡§ú‡§æ ‡§∞‡§π‡§æ ‡§π‡•à‡•§"
            );
            twiml.dial(process.env.HUMAN_AGENT_NUMBER);
            activeCalls.delete(CallSid);
            return res.type("text/xml").send(twiml.toString());
          }
        }

        if (!identifier) {
          callData.lastQuestion = `‡§¶‡•ã‡§¨‡§æ‡§∞‡§æ ‡§™‡•ç‡§∞‡§Ø‡§æ‡§∏ ${callData.retries}/3: ‡§Æ‡§∂‡•Ä‡§® ‡§®‡§Ç‡§¨‡§∞ ‡§Ø‡§æ ‡§´‡•ã‡§® ‡§®‡§Ç‡§¨‡§∞ ‡§¨‡•ã‡§≤‡§ø‡§è ‡§Ø‡§æ ‡§¶‡§∞‡•ç‡§ú ‡§ï‡§∞‡•á‡§Ç‡•§`;
          const gather = twiml.gather({
            input: "dtmf speech",
            hints: "machine number, phone number, ‡§Æ‡§∂‡•Ä‡§® ‡§®‡§Ç‡§¨‡§∞, ‡§´‡•ã‡§® ‡§®‡§Ç‡§¨‡§∞",
            finishOnKey: "#",
            timeout: 30,
            actionOnEmptyResult: true,
            action: "/voice/process",
            method: "POST",
          });
          gather.say({ voice: "Polly.Aditi", language: "hi-IN" }, callData.lastQuestion);
          activeCalls.set(CallSid, callData);
          return res.type("text/xml").send(twiml.toString());
        }
      }

      // ===== FETCH MACHINE DATA FROM API =====
      console.log("\n" + "=".repeat(120));
      console.log(`üåê FETCHING MACHINE DATA FROM API FOR IDENTIFIER: ${identifier}`);
      console.log("=".repeat(120));

      const customerData = await fetchCustomerFromExternal({ 
        phone: /^\d{10}$/.test(identifier) ? identifier : null,
        chassisNo: !/^\d{10}$/.test(identifier) ? identifier : null
      });

      if (!customerData) {
        console.log("‚ùå Machine not found in API database");
        twiml.say(
          { voice: "Polly.Aditi", language: "hi-IN" },
          "Hum aapka machine API mein nahi khoj paye. Aapko agent se connect kar rahe hain."
        );
        twiml.dial(process.env.HUMAN_AGENT_NUMBER);
        activeCalls.delete(CallSid);
        return res.type("text/xml").send(twiml.toString());
      }

      console.log("‚úÖ Machine found in API!");
      console.log(`üìç City: ${customerData.city}`);
      console.log(`üë§ Name: ${customerData.name}`);
      console.log("=".repeat(120) + "\n");

      // ===== CONFIRM CUSTOMER CITY AND NAME =====
      callData.chassis = identifier;
      callData.customerData = customerData;
      callData.isRegistered = false;
      callData.step = "confirm_customer_details";
      callData.retries = 0;
      
      const confirmQuestion = `‡§Ü‡§™‡§ï‡§æ city ‡§π‡•à  ${customerData.city} ‡§î‡§∞ ‡§®‡§æ‡§Æ ‡§π‡•à ${customerData.name}.‡§ï‡•ç‡§Ø‡§æ ‡§Ø‡•á ‡§†‡•Ä‡§ï ‡§π‡•à? ‡§π‡§æ‡§Å ‡§§‡•ã 1 ‡§¶‡§¨‡§æ‡§è‡§Ç, ‡§®‡§π‡•Ä‡§Ç ‡§§‡•ã 2 ‡§¶‡§¨‡§æ‡§è‡§Ç‡•§`;
      callData.lastQuestion = confirmQuestion;
      
      console.log(`üîä Asking for confirmation: "${confirmQuestion}"`);
      askDTMF(twiml, confirmQuestion, 1);
      activeCalls.set(CallSid, callData);
      return res.type("text/xml").send(twiml.toString());
    }

    // ===== CONFIRM CUSTOMER DETAILS =====
    if (callData.step === "confirm_customer_details") {
      if (Digits === "*") {
        console.log("üîÑ User pressed * - Repeating confirmation question");
        askDTMF(twiml, callData.lastQuestion || "‡§ï‡•ç‡§Ø‡§æ ‡§∏‡§≠‡•Ä ‡§ú‡§æ‡§®‡§ï‡§æ‡§∞‡•Ä ‡§∏‡§π‡•Ä ‡§π‡•à? ‡§è‡§ï ‡§¶‡§¨‡§æ‡§á‡§è ‡§∏‡§π‡•Ä ‡§π‡•à ‡§§‡•ã, ‡§¶‡•ã ‡§¶‡§¨‡§æ‡§á‡§è ‡§ó‡§≤‡§§ ‡§π‡•à ‡§§‡•ã‡•§", 1);
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      }

      if (Digits === "1") {
        // Customer confirmed - Continue
        console.log("‚úÖ Customer confirmed details - Moving to next step");
        callData.step = "ask_caller_name";
        callData.retries = 0;
        callData.lastQuestion = "‡§¨‡§π‡•Å‡§§ ‡§Ö‡§ö‡•ç‡§õ‡§æ! ‡§Ö‡§¨ ‡§Æ‡•Å‡§ù‡•á ‡§¨‡§§‡§æ‡§á‡§è, ‡§Ü‡§™‡§ï‡§æ ‡§™‡•Ç‡§∞‡§æ ‡§®‡§æ‡§Æ ‡§ï‡•ç‡§Ø‡§æ ‡§π‡•à?";
        ask(twiml, callData.lastQuestion);
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      } else if (Digits === "2") {
        // Customer denied - Restart
        console.log("‚ùå Customer rejected details - Restarting identifier collection");
        callData.step = "ask_identifier";
        callData.retries = 0;
        callData.lastQuestion = "‡§†‡•Ä‡§ï ‡§π‡•à‡•§ ‡§¶‡•ã‡§¨‡§æ‡§∞‡§æ: ‡§Æ‡§∂‡•Ä‡§® ‡§®‡§Ç‡§¨‡§∞ ‡§¨‡•ã‡§≤‡§ø‡§è ‡§Ø‡§æ ‡§¶‡§∞‡•ç‡§ú ‡§ï‡§∞‡•á‡§Ç, ‡§´‡§ø‡§∞ ‡§π‡•à‡§∂ (#) key ‡§¶‡§¨‡§æ‡§á‡§è‡•§";
        const gather = twiml.gather({
          input: "dtmf speech",
          hints: "machine number, chassis, ‡§Æ‡§∂‡•Ä‡§® ‡§®‡§Ç‡§¨‡§∞, ‡§ö‡•á‡§∏‡§ø‡§∏",
          finishOnKey: "#",
          timeout: 30,
          actionOnEmptyResult: true,
          action: "/voice/process",
          method: "POST",
        });
        gather.say({ voice: "Polly.Aditi", language: "hi-IN" }, callData.lastQuestion);
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      } else {
        callData.retries = (callData.retries || 0) + 1;
        if (callData.retries >= 3) {
          console.log("‚ùå Invalid confirmation after retries - Escalating");
          twiml.say(
            { voice: "Polly.Aditi", language: "hi-IN" },
            "Samajh nahi paye. Aapko agent se connect kar rahe hain."
          );
          twiml.dial(process.env.HUMAN_AGENT_NUMBER);
          activeCalls.delete(CallSid);
          return res.type("text/xml").send(twiml.toString());
        }
        askDTMF(twiml, "Kripya 1 ya 2 dabayien.", 1);
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      }
    }

    // ===== ASK CHASSIS (FOR REGISTERED CUSTOMERS) =====
    if (callData.step === "ask_chassis") {
      const chassis = extractChassisNumberV2(rawSpeech);
      console.log(`‚úì Chassis: ${chassis || "N/A"}`);

      if (!chassis || !isValidChassis(chassis)) {
        callData.retries = (callData.retries || 0) + 1;

        if (callData.retries >= 3) {
          console.log(`‚ùå Invalid chassis after ${callData.retries} attempts - Escalating`);
          twiml.say(
            { voice: "Polly.Aditi", language: "hi-IN" },
            "‡§π‡§Æ ‡§Ü‡§™‡§ï‡§æ ‡§ö‡•á‡§∏‡§ø‡§∏ ‡§®‡§Ç‡§¨‡§∞ ‡§∏‡§Æ‡§ù ‡§®‡§π‡•Ä‡§Ç ‡§™‡§æ‡§è‡•§ ‡§Ü‡§™‡§ï‡•ã ‡§è‡§ú‡•á‡§Ç‡§ü ‡§∏‡•á ‡§ú‡•ã‡§°‡§º‡§æ ‡§ú‡§æ ‡§∞‡§π‡§æ ‡§π‡•à‡•§"
          );
          twiml.dial(process.env.HUMAN_AGENT_NUMBER);
          activeCalls.delete(CallSid);
          return res.type("text/xml").send(twiml.toString());
        }

        const hints = callData.retries === 1
          ? "‡§ï‡•ã‡§à ‡§¨‡§æ‡§§ ‡§®‡§π‡•Ä‡§Ç‡•§ ‡§ö‡•á‡§∏‡§ø‡§∏ ‡§®‡§Ç‡§¨‡§∞ ‡§è‡§ï-‡§è‡§ï ‡§Ö‡§Ç‡§ï ‡§ï‡•á ‡§∏‡§æ‡§• ‡§ß‡•Ä‡§∞‡•á-‡§ß‡•Ä‡§∞‡•á ‡§¨‡•ã‡§≤‡§ø‡§è‡•§ ‡§ú‡•à‡§∏‡•á: ‡§§‡•Ä‡§®, ‡§§‡•Ä‡§®, ‡§∂‡•Ç‡§®‡•ç‡§Ø, ‡§™‡§æ‡§Å‡§ö, ‡§ö‡§æ‡§∞, ‡§ö‡§æ‡§∞, ‡§∏‡§æ‡§§‡•§"
          : "‡§Ö‡§™‡§®‡•Ä ‡§Æ‡§∂‡•Ä‡§® ‡§ï‡•á ‡§¶‡§∏‡•ç‡§§‡§æ‡§µ‡•á‡§ú‡§º ‡§Æ‡•á‡§Ç ‡§¶‡•á‡§ñ‡§ï‡§∞ ‡§ö‡•á‡§∏‡§ø‡§∏ ‡§®‡§Ç‡§¨‡§∞ ‡§¨‡•ã‡§≤‡§ø‡§è‡•§ ‡§è‡§ï-‡§è‡§ï ‡§®‡§Ç‡§¨‡§∞ ‡§∏‡§æ‡§´ ‡§¨‡•ã‡§≤‡§ø‡§è‡•§";

        callData.lastQuestion = hints;
        ask(twiml, hints);
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      }

      const customerData = await fetchCustomerFromExternal({ chassisNo: chassis });

      if (!customerData) {
        callData.retries = (callData.retries || 0) + 1;

        if (callData.retries >= 3) {
          console.log("‚ùå Customer not found - Escalating");
          twiml.say(
            { voice: "Polly.Aditi", language: "hi-IN" },
            "Machine ka record nahi mila. Aapko agent se connect kar rahe hain."
          );
          twiml.dial(process.env.HUMAN_AGENT_NUMBER);
          activeCalls.delete(CallSid);
          return res.type("text/xml").send(twiml.toString());
        }

        callData.lastQuestion = "‡§∞‡§ø‡§ï‡•â‡§∞‡•ç‡§° ‡§®‡§π‡•Ä‡§Ç ‡§Æ‡§ø‡§≤‡§æ‡•§ ‡§´‡§ø‡§∞ ‡§∏‡•á ‡§ö‡•á‡§∏‡§ø‡§∏ ‡§®‡§Ç‡§¨‡§∞ ‡§¨‡•ã‡§≤‡§ø‡§è‡•§";
        ask(twiml, callData.lastQuestion);
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      }

      console.log(`‚úÖ Customer found: ${customerData.name}`);
      callData.chassis = chassis;
      callData.customerData = customerData;
      callData.isRegistered = true;
      callData.step = "ask_caller_name";
      callData.retries = 0;
      callData.lastQuestion = "‡§†‡•Ä‡§ï ‡§π‡•à! ‡§Æ‡§∂‡•Ä‡§® ‡§ï‡§æ ‡§∞‡§ø‡§ï‡•â‡§∞‡•ç‡§° ‡§Æ‡§ø‡§≤ ‡§ó‡§Ø‡§æ‡•§ ‡§Ö‡§¨ ‡§Ö‡§™‡§®‡§æ ‡§™‡•Ç‡§∞‡§æ ‡§®‡§æ‡§Æ ‡§¨‡§§‡§æ‡§á‡§è, ‡§ï‡•É‡§™‡§Ø‡§æ‡•§";
      ask(twiml, callData.lastQuestion);
      activeCalls.set(CallSid, callData);
      return res.type("text/xml").send(twiml.toString());
    }

    // ===== ASK CALLER NAME =====
    if (callData.step === "ask_caller_name") {
      // Handle STAR (*) key to repeat last question
      if (Digits === "*") {
        console.log("üîÑ User pressed * - Repeating caller name question");
        ask(twiml, callData.lastQuestion || "‡§Ö‡§™‡§ï‡§æ ‡§™‡•Ç‡§∞‡§æ ‡§®‡§æ‡§Æ ‡§¨‡§§‡§æ‡§á‡§è‡•§");
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      }

      if (rejectInvalid(rawSpeech)) {
        callData.retries = (callData.retries || 0) + 1;

        if (callData.retries >= 3) {
          twiml.say(
            { voice: "Polly.Aditi", language: "hi-IN" },
            "Naam samajh nahi aaya. Aapko ek agent se connect kar dete hain."
          );
          twiml.dial(process.env.HUMAN_AGENT_NUMBER);
          activeCalls.delete(CallSid);
          return res.type("text/xml").send(twiml.toString());
        }

        console.log(`‚ö†Ô∏è Invalid name input - Retry ${callData.retries}/3`);
        callData.lastQuestion = "‡§®‡§æ‡§Æ ‡§∏‡•ç‡§™‡§∑‡•ç‡§ü ‡§®‡§π‡•Ä‡§Ç ‡§∏‡•Å‡§®‡§æ‡•§ ‡§Ö‡§™‡§®‡§æ ‡§™‡•Ç‡§∞‡§æ ‡§®‡§æ‡§Æ ‡§¶‡•ã‡§¨‡§æ‡§∞‡§æ ‡§¨‡•ã‡§≤‡§ø‡§è, ‡§ú‡§∞‡§æ ‡§ß‡•Ä‡§∞‡•á-‡§ß‡•Ä‡§∞‡•á‡•§";
        ask(twiml, callData.lastQuestion);
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      }

      const name = extractNameV2(rawSpeech);
      console.log(`‚úì Caller Name Extracted: ${name || "N/A"}`);

      if (!name || !isValidName(name)) {
        callData.retries = (callData.retries || 0) + 1;

        if (callData.retries >= 3) {
          twiml.say(
            { voice: "Polly.Aditi", language: "hi-IN" },
            "Samajh nahi aa raha. Agent ko connect karte hain."
          );
          twiml.dial(process.env.HUMAN_AGENT_NUMBER);
          activeCalls.delete(CallSid);
          return res.type("text/xml").send(twiml.toString());
        }

        console.log(`‚ö†Ô∏è Name validation failed - Retry ${callData.retries}/3`);
        callData.lastQuestion = "‡§Ö‡§™‡§®‡§æ ‡§™‡•Ç‡§∞‡§æ ‡§®‡§æ‡§Æ ‡§∏‡§æ‡§´-‡§∏‡§æ‡§´ ‡§¨‡•ã‡§≤‡§ø‡§è, ‡§ß‡•Ä‡§∞‡•á-‡§ß‡•Ä‡§∞‡•á ";
        ask(twiml, callData.lastQuestion);
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      }

      callData.callerName = name;
      callData.retries = 0;
      callData.step = "ask_caller_phone";
      callData.lastQuestion = " ‡§∂‡•Å‡§ï‡•ç‡§∞‡§ø‡§Ø‡§æ! ‡§Ö‡§¨ ‡§Ö‡§™‡§®‡§æ 10-digit mobile number ‡§¨‡•ã‡§≤‡§ø‡§è ‡§Ø‡§æ type ‡§ï‡§∞‡•á‡§Ç, ‡§´‡§ø‡§∞ # key ‡§¶‡§¨‡§æ‡§è‡§Ç‡•§ ‡§ú‡•à‡§∏‡•á: ‡§®‡•å ‡§Ü‡§† ‡§Ü‡§† ‡§¶‡•ã ‡§§‡•Ä‡§® ‡§ö‡§æ‡§∞...";
      const gather = twiml.gather({
        input: "speech dtmf",
        language: "hi-IN",
        speechTimeout: "auto",
        timeout: 15,
        finishOnKey: "#",
        numDigits: 10,
        actionOnEmptyResult: true,
        action: "/voice/process",
        method: "POST",
      });
      gather.say({ voice: "Polly.Aditi", language: "hi-IN" }, callData.lastQuestion);
      activeCalls.set(CallSid, callData);
      return res.type("text/xml").send(twiml.toString());
    }

    // ===== ASK CALLER PHONE =====
    if (callData.step === "ask_caller_phone") {
      // Handle STAR (*) key to repeat last question
      if (Digits === "*") {
        console.log("üîÑ User pressed * - Repeating phone entry question");
        const gather = twiml.gather({
          input: "speech dtmf",
          language: "hi-IN",
          speechTimeout: "auto",
          timeout: 15,
          finishOnKey: "#",
          numDigits: 10,
          actionOnEmptyResult: true,
          action: "/voice/process",
          method: "POST",
        });
        gather.say({ voice: "Polly.Aditi", language: "hi-IN" }, "‡§Ö‡§™‡§®‡§æ 10-digit mobile number ‡§¨‡•ã‡§≤‡§ø‡§è ‡§Ø‡§æ type ‡§ï‡§∞‡•á‡§Ç, ‡§´‡§ø‡§∞ # key ‡§¶‡§¨‡§æ‡§è‡§Ç‡•§ ‡§ú‡•à‡§∏‡•á: ‡§®‡•å ‡§Ü‡§† ‡§Ü‡§† ‡§¶‡•ã ‡§§‡•Ä‡§® ‡§ö‡§æ‡§∞...");
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      }

      // Extract phone from either speech or DTMF
      let phoneInput = null;
      
      // First try DTMF digits
      if (Digits && Digits.trim().length > 0) {
        phoneInput = Digits.replace(/[^0-9]/g, ''); // Clean to digits only
        console.log(`üì± DTMF Phone Input: "${phoneInput}" (Length: ${phoneInput.length})`);
      }
      
      // Fallback to speech extraction
      if (!phoneInput || phoneInput.length < 10) {
        if (rawSpeech && rawSpeech.length > 0) {
          const extracted = extractPhoneNumberV2(rawSpeech);
          if (extracted && isValidPhone(extracted)) {
            phoneInput = extracted;
            console.log(`üì± Speech Phone Extracted: "${phoneInput}"`);
          }
        }
      }

      if (phoneInput && isValidPhone(phoneInput) && phoneInput.length === 10) {
        // Valid phone number entered
        callData.callerPhone = phoneInput;
        callData.step = "confirm_phone";
        callData.retries = 0;
        const spokenDigits = phoneToSpokenDigits(phoneInput);
        callData.lastQuestion = `‡§Ü‡§™‡§ï‡§æ ‡§´‡•ã‡§® ‡§®‡§Ç‡§¨‡§∞: ${spokenDigits}‡•§ ‡§ï‡•ç‡§Ø‡§æ ‡§Ø‡§π ‡§®‡§Ç‡§¨‡§∞ ‡§∏‡§π‡•Ä ‡§π‡•à? ‡§è‡§ï ‡§¶‡§¨‡§æ‡§á‡§è ‡§π‡§æ‡§Å ‡§§‡•ã, ‡§¶‡•ã ‡§¶‡§¨‡§æ‡§á‡§è ‡§®‡§π‡•Ä‡§Ç ‡§§‡•ã‡•§`;
        askDTMF(twiml, callData.lastQuestion, 1);
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      } else {
        // Invalid or incomplete phone
        callData.retries = (callData.retries || 0) + 1;

        if (phoneInput) {
          console.log(`‚ö†Ô∏è Invalid phone format "${phoneInput}" (${phoneInput.length} digits) - Retry ${callData.retries}/4`);
        } else {
          console.log(`‚ö†Ô∏è No phone input - Retry ${callData.retries}/4`);
        }

        if (callData.retries >= 4) {
          console.log("‚ùå Invalid phone after 4 retries - Transferring to agent");
          twiml.say(
            { voice: "Polly.Aditi", language: "hi-IN" },
            "‡§π‡§Æ ‡§Ü‡§™‡§ï‡§æ ‡§´‡•ã‡§® ‡§®‡§Ç‡§¨‡§∞ ‡§∏‡§Æ‡§ù ‡§®‡§π‡•Ä‡§Ç ‡§™‡§æ‡§è‡•§ ‡§Ü‡§™‡§ï‡•ã ‡§è‡§ú‡•á‡§Ç‡§ü ‡§∏‡•á ‡§ú‡•ã‡§°‡§º‡§æ ‡§ú‡§æ ‡§∞‡§π‡§æ ‡§π‡•à‡•§"
          );
          twiml.dial(process.env.HUMAN_AGENT_NUMBER);
          activeCalls.delete(CallSid);
          return res.type("text/xml").send(twiml.toString());
        }

        callData.lastQuestion = `‡§¶‡•ã‡§¨‡§æ‡§∞‡§æ ‡§™‡•ç‡§∞‡§Ø‡§æ‡§∏ ${callData.retries}/4: ‡§Ö‡§™‡§®‡§æ 10 ‡§Ö‡§Ç‡§ï‡•ã‡§Ç ‡§ï‡§æ ‡§Æ‡•ã‡§¨‡§æ‡§á‡§≤ ‡§®‡§Ç‡§¨‡§∞ ‡§¨‡•ã‡§≤‡§ø‡§è‡•§ ‡§ú‡•à‡§∏‡•á: ‡§®‡•å ‡§Ü‡§† ‡§Ü‡§† ‡§¶‡•ã ‡§§‡•Ä‡§® ‡§ö‡§æ‡§∞...`;
        const gather = twiml.gather({
          input: "speech dtmf",
          language: "hi-IN",
          speechTimeout: "auto",
          timeout: 15,
          finishOnKey: "#",
          numDigits: 10,
          actionOnEmptyResult: true,
          action: "/voice/process",
          method: "POST",
        });
        gather.say({ voice: "Polly.Aditi", language: "hi-IN" }, callData.lastQuestion);
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      }
    }

    // ===== CONFIRM PHONE =====
    if (callData.step === "confirm_phone") {
      if (Digits === "*") {
        console.log("üîÑ User pressed * - Repeating phone confirmation question");
        askDTMF(twiml, callData.lastQuestion || "Press 1 for Yes, 2 for No.", 1);
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      }

      if (Digits === "1") {
        console.log(`‚úì Phone confirmed: ${callData.callerPhone}`);
        callData.step = "ask_machine_type_numeric";
        callData.retries = 0;
        callData.lastQuestion = "‡§ß‡§®‡•ç‡§Ø‡§µ‡§æ‡§¶! ‡§Ö‡§¨ ‡§Ö‡§™‡§®‡•Ä ‡§Æ‡§∂‡•Ä‡§® ‡§ï‡•Ä ‡§∏‡•á‡§µ‡§æ ‡§Ø‡•ã‡§ú‡§®‡§æ ‡§¨‡§§‡§æ‡§á‡§è‡•§ ‡§è‡§ï ‡§¶‡§¨‡§æ‡§á‡§è Warranty ‡§ï‡•á ‡§≤‡§ø‡§è, ‡§¶‡•ã ‡§¶‡§¨‡§æ‡§á‡§è JCB Care ‡§ï‡•á ‡§≤‡§ø‡§è, ‡§§‡•Ä‡§® ‡§¶‡§¨‡§æ‡§á‡§è Engine Care ‡§ï‡•á ‡§≤‡§ø‡§è, ‡§ö‡§æ‡§∞ ‡§¶‡§¨‡§æ‡§á‡§è Demo ‡§ï‡•á ‡§≤‡§ø‡§è, ‡§™‡§æ‡§Å‡§ú ‡§¶‡§¨‡§æ‡§á‡§è BHL ‡§ï‡•á ‡§≤‡§ø‡§è‡•§";
        askDTMF(twiml, callData.lastQuestion, 1);
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      }

      if (Digits === "2") {
        console.log(`‚ùå Phone not confirmed - Re-asking`);
        callData.step = "ask_caller_phone";
        callData.retries = 0;
        callData.lastQuestion = "‡§†‡•Ä‡§ï ‡§π‡•à‡•§ ‡§¶‡•ã‡§¨‡§æ‡§∞‡§æ: 10 ‡§Ö‡§Ç‡§ï‡•ã‡§Ç ‡§ï‡§æ ‡§Æ‡•ã‡§¨‡§æ‡§á‡§≤ ‡§®‡§Ç‡§¨‡§∞ ‡§¨‡•ã‡§≤‡§ø‡§è ‡§Ø‡§æ type ‡§ï‡§∞‡•á‡§Ç, ‡§´‡§ø‡§∞ ‡§π‡•à‡§∂ (#) key ‡§¶‡§¨‡§æ‡§á‡§è‡•§";
        const gather = twiml.gather({
          input: "speech dtmf",
          language: "hi-IN",
          speechTimeout: "auto",
          timeout: 15,
          finishOnKey: "#",
          numDigits: 10,
          actionOnEmptyResult: true,
          action: "/voice/process",
          method: "POST",
        });
        gather.say({ voice: "Polly.Aditi", language: "hi-IN" }, callData.lastQuestion);
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      }

      // If user speaks unexpected input or no digit pressed, repeat question
      if (!Digits || Digits.trim().length === 0) {
        callData.retries = (callData.retries || 0) + 1;
        console.log(`‚ö†Ô∏è No/invalid digit pressed - Retry ${callData.retries}/3 for phone confirmation`);

        if (callData.retries >= 3) {
          callData.step = "ask_machine_type_numeric";
          callData.retries = 0;
          callData.lastQuestion = "‡§†‡•Ä‡§ï ‡§π‡•à‡•§ ‡§Ö‡§¨ ‡§Æ‡§∂‡•Ä‡§® ‡§ï‡•Ä ‡§∏‡•á‡§µ‡§æ ‡§Ø‡•ã‡§ú‡§®‡§æ ‡§ö‡•Å‡§®‡§ø‡§è‡•§ ‡§è‡§ï ‡§¶‡§¨‡§æ‡§á‡§è Warranty ‡§ï‡•á ‡§≤‡§ø‡§è, ‡§¶‡•ã ‡§¶‡§¨‡§æ‡§á‡§è JCB Care ‡§ï‡•á ‡§≤‡§ø‡§è, ‡§§‡•Ä‡§® ‡§¶‡§¨‡§æ‡§á‡§è Engine Care ‡§ï‡•á ‡§≤‡§ø‡§è, ‡§ö‡§æ‡§∞ ‡§¶‡§¨‡§æ‡§á‡§è Demo ‡§ï‡•á ‡§≤‡§ø‡§è, ‡§™‡§æ‡§Å‡§ö ‡§¶‡§¨‡§æ‡§á‡§è BHL ‡§ï‡•á ‡§≤‡§ø‡§è‡•§";
          askDTMF(twiml, callData.lastQuestion, 1);
          activeCalls.set(CallSid, callData);
          return res.type("text/xml").send(twiml.toString());
        }

        console.log("‚ö†Ô∏è Repeating: Press 1 for Yes, 2 for No");
        askDTMF(twiml, "‡§è‡§ï ‡§¶‡§¨‡§æ‡§á‡§è ‡§π‡§æ‡§Å ‡§ï‡•á ‡§≤‡§ø‡§è, ‡§¶‡•ã ‡§¶‡§¨‡§æ‡§á‡§è ‡§®‡§π‡•Ä‡§Ç ‡§ï‡•á ‡§≤‡§ø‡§è‡•§", 1);
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      } else {
        // Invalid digit pressed (not 1, 2, or empty)
        callData.retries = (callData.retries || 0) + 1;
        console.log(`‚ö†Ô∏è Invalid digit '${Digits}' pressed - Retry ${callData.retries}/3 for phone confirmation`);

        if (callData.retries >= 3) {
          callData.step = "ask_machine_type_numeric";
          callData.retries = 0;
          callData.lastQuestion = "‡§†‡•Ä‡§ï ‡§π‡•à‡•§ ‡§Ö‡§¨ ‡§Æ‡§∂‡•Ä‡§® ‡§ï‡•Ä ‡§∏‡•á‡§µ‡§æ ‡§Ø‡•ã‡§ú‡§®‡§æ ‡§ö‡•Å‡§®‡§ø‡§è‡•§ ‡§è‡§ï ‡§¶‡§¨‡§æ‡§á‡§è Warranty ‡§ï‡•á ‡§≤‡§ø‡§è, ‡§¶‡•ã ‡§¶‡§¨‡§æ‡§á‡§è JCB Care ‡§ï‡•á ‡§≤‡§ø‡§è, ‡§§‡•Ä‡§® ‡§¶‡§¨‡§æ‡§á‡§è Engine Care ‡§ï‡•á ‡§≤‡§ø‡§è, ‡§ö‡§æ‡§∞ ‡§¶‡§¨‡§æ‡§á‡§è Demo ‡§ï‡•á ‡§≤‡§ø‡§è, ‡§™‡§æ‡§Å‡§ö ‡§¶‡§¨‡§æ‡§á‡§è BHL ‡§ï‡•á ‡§≤‡§ø‡§è‡•§";
          askDTMF(twiml, callData.lastQuestion, 1);
          activeCalls.set(CallSid, callData);
          return res.type("text/xml").send(twiml.toString());
        }

        console.log("‚ö†Ô∏è Asking to confirm phone again");
        askDTMF(twiml, "‡§ï‡•É‡§™‡§Ø‡§æ ‡§è‡§ï ‡§¶‡§¨‡§æ‡§á‡§è ‡§∏‡§π‡•Ä ‡§π‡•à ‡§§‡•ã, ‡§¶‡•ã ‡§¶‡§¨‡§æ‡§á‡§è ‡§ó‡§≤‡§§ ‡§π‡•à ‡§§‡•ã‡•§", 1);
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      }
    }

    // ===== ASK MACHINE TYPE - NUMERIC IVR =====
    if (callData.step === "ask_machine_type_numeric") {
      // Handle STAR (*) key to repeat last question
      if (Digits === "*") {
        console.log("üîÑ User pressed * - Repeating machine type question");
        askDTMF(twiml, callData.lastQuestion || "Press 1 for Warranty, 2 for JCB Care, 3 for Engine Care, 4 for Demo, 5 for BHL.", 1);
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      }

      const machineType = getMachineTypeByNumber(Digits);

      if (Digits && ['1', '2', '3', '4', '5'].includes(Digits)) {
        console.log(`‚úì Machine Type Selected: ${machineType} (Digit: ${Digits})`);
        callData.machineType = machineType;
        // SKIP CONFIRMATION - DIRECTLY GO TO MACHINE STATUS
        callData.step = "ask_machine_status_numeric";
        callData.retries = 0;
        callData.lastQuestion = "‡§†‡•Ä‡§ï ‡§π‡•à‡•§ ‡§Ö‡§¨ ‡§¨‡§§‡§æ‡§á‡§è - ‡§Ü‡§™‡§ï‡•Ä ‡§Æ‡§∂‡•Ä‡§® ‡§ï‡•Ä ‡§∏‡•ç‡§•‡§ø‡§§‡§ø ‡§ï‡•ç‡§Ø‡§æ ‡§π‡•à? 1 ‡§¶‡§¨‡§æ‡§á‡§è ‡§Ö‡§ó‡§∞ ‡§¨‡§ø‡§≤‡•ç‡§ï‡•Å‡§≤ ‡§¨‡§Ç‡§¶ ‡§π‡•à, ‡§Ø‡§æ 2 ‡§¶‡§¨‡§æ‡§á‡§è ‡§Ö‡§ó‡§∞ ‡§ö‡§≤ ‡§∞‡§π‡•Ä ‡§π‡•à ‡§™‡§∞ ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§Ü ‡§∞‡§π‡•Ä ‡§π‡•à‡•§";
        askDTMF(twiml, callData.lastQuestion, 1);
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      } else {
        callData.retries = (callData.retries || 0) + 1;

        if (callData.retries >= 3) {
          console.log("‚ùå Invalid machine type - Using default");
          callData.machineType = "Warranty";
          callData.step = "ask_machine_status_numeric";
          callData.retries = 0;
          callData.lastQuestion = "‡§†‡•Ä‡§ï ‡§π‡•à‡•§ ‡§Ö‡§¨ ‡§Æ‡§∂‡•Ä‡§® ‡§ï‡•Ä ‡§∏‡•ç‡§•‡§ø‡§§‡§ø - ‡§¨‡§Ç‡§¶ ‡§π‡•à ‡§Ø‡§æ ‡§ö‡§≤ ‡§∞‡§π‡•Ä ‡§π‡•à? ‡§è‡§ï ‡§¶‡§¨‡§æ‡§á‡§è ‡§Ø‡§æ ‡§¶‡•ã ‡§¶‡§¨‡§æ‡§á‡§è‡•§";
          askDTMF(twiml, callData.lastQuestion, 1);
          activeCalls.set(CallSid, callData);
          return res.type("text/xml").send(twiml.toString());
        }

        callData.lastQuestion = "‡§ó‡§≤‡§§ ‡§á‡§®‡§™‡•Å‡§ü‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ 1 ‡§∏‡•á 5 ‡§ï‡•á ‡§¨‡•Ä‡§ö ‡§®‡§Ç‡§¨‡§∞ ‡§¶‡§¨‡§æ‡§á‡§è‡•§";
        askDTMF(twiml, callData.lastQuestion, 1);
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      }
    }

    // ===== ASK MACHINE STATUS - NUMERIC IVR =====
    if (callData.step === "ask_machine_status_numeric") {
      // Handle STAR (*) key to repeat last question
      if (Digits === "*") {
        console.log("üîÑ User pressed * - Repeating machine status question");
        askDTMF(twiml, callData.lastQuestion || "‡§è‡§ï ‡§Ø‡§æ ‡§¶‡•ã ‡§¶‡§¨‡§æ‡§à‡§è‡•§", 1);
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      }

      const status = getMachineStatusByNumber(Digits);

      if (Digits && ['1', '2'].includes(Digits)) {
        console.log(`‚úì Machine Status Selected: ${status} (Digit: ${Digits})`);
        callData.machineStatus = status;
        // SKIP CONFIRMATION - DIRECTLY GO TO LOCATION
        callData.step = "ask_machine_location_numeric";
        callData.retries = 0;
        callData.lastQuestion = "‡§Ö‡§ö‡•ç‡§õ‡§æ‡•§ ‡§Ö‡§¨ ‡§¨‡§§‡§æ‡§á‡§è ‡§Ü‡§™‡§ï‡•Ä ‡§Æ‡§∂‡•Ä‡§® ‡§ï‡§π‡§æ‡§Å ‡§π‡•à? 1 ‡§¶‡§¨‡§æ‡§á‡§è ‡§Ö‡§ó‡§∞ ‡§∏‡§æ‡§á‡§ü ‡§™‡§∞ ‡§π‡•à, 2 ‡§¶‡§¨‡§æ‡§á‡§è ‡§Ö‡§ó‡§∞ ‡§ï‡§æ‡§∞‡•ç‡§Ø‡§∂‡§æ‡§≤‡§æ ‡§Æ‡•á‡§Ç ‡§π‡•à‡•§";
        askDTMF(twiml, callData.lastQuestion, 1);
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      } else {
        callData.retries = (callData.retries || 0) + 1;

        if (callData.retries >= 3) {
          console.log("‚ùå Invalid machine status - Using default");
          callData.machineStatus = "Running With Problem";
          callData.step = "ask_machine_location_numeric";
          callData.retries = 0;
          callData.lastQuestion = "‡§Æ‡§∂‡•Ä‡§® ‡§ï‡§π‡§æ‡§Å ‡§π‡•à? 1 ‡§¶‡§¨‡§æ‡§á‡§è ‡§∏‡§æ‡§á‡§ü ‡§ï‡•á ‡§≤‡§ø‡§è, 2 ‡§¶‡§¨‡§æ‡§á‡§è ‡§ï‡§æ‡§∞‡•ç‡§Ø‡§∂‡§æ‡§≤‡§æ ‡§ï‡•á ‡§≤‡§ø‡§è‡•§";
          askDTMF(twiml, callData.lastQuestion, 1);
          activeCalls.set(CallSid, callData);
          return res.type("text/xml").send(twiml.toString());
        }

        callData.lastQuestion = "‡§ó‡§≤‡§§ ‡§á‡§®‡§™‡•Å‡§ü‡•§ 1 ‡§¶‡§¨‡§æ‡§á‡§è ‡§Ö‡§ó‡§∞ ‡§¨‡§Ç‡§¶ ‡§π‡•à, 2 ‡§¶‡§¨‡§æ‡§á‡§è ‡§Ö‡§ó‡§∞ ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§ï‡•á ‡§∏‡§æ‡§• ‡§ö‡§≤ ‡§∞‡§π‡•Ä ‡§π‡•à‡•§";
        askDTMF(twiml, callData.lastQuestion, 1);
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      }
    }

    // ===== ASK MACHINE LOCATION - NUMERIC IVR =====
    if (callData.step === "ask_machine_location_numeric") {
      // Handle STAR (*) key to repeat last question
      if (Digits === "*") {
        console.log("üîÑ User pressed * - Repeating machine location question");
        askDTMF(twiml, "‡§∏‡•ç‡§•‡§æ‡§®: ‡§è‡§ï ‡§¶‡§¨‡§æ‡§á‡§è ‡§∏‡§æ‡§á‡§ü ‡§ï‡•á ‡§≤‡§ø‡§è, ‡§¶‡•ã ‡§¶‡§¨‡§æ‡§á‡§è ‡§µ‡§∞‡•ç‡§ï‡§∂‡•â‡§™ ‡§ï‡•á ‡§≤‡§ø‡§è‡•§", 1);
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      }

      if (Digits && ['1', '2'].includes(Digits)) {
        const locationNames = {
          '1': 'Site',
          '2': 'Workshop'
        };
        callData.jobLocation = locationNames[Digits];
        console.log(`‚úì Machine Location Selected: ${callData.jobLocation}`);
        
        callData.step = "ask_address";
        callData.retries = 0;
        callData.lastQuestion = "‡§¨‡§ø‡§≤‡•ç‡§ï‡•Å‡§≤ ‡§†‡•Ä‡§ï ‡§π‡•à‡•§ ‡§Ö‡§¨ ‡§Æ‡§∂‡•Ä‡§® ‡§ï‡§æ ‡§™‡•Ç‡§∞‡§æ ‡§™‡§§‡§æ ‡§¨‡§§‡§æ‡§á‡§è - ‡§∂‡§π‡§∞ ‡§ï‡§æ ‡§®‡§æ‡§Æ, ‡§á‡§≤‡§æ‡§ï‡§æ, ‡§î‡§∞ ‡§™‡§æ‡§∏ ‡§Æ‡•á‡§Ç ‡§ï‡•ã‡§à ‡§¶‡•Å‡§ï‡§æ‡§® ‡§Ø‡§æ ‡§®‡§ø‡§∂‡§æ‡§®‡•Ä‡•§";
        ask(twiml, callData.lastQuestion);
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      } else {
        callData.retries = (callData.retries || 0) + 1;

        if (callData.retries >= 3) {
          console.log("‚ùå Invalid location - Using default");
          callData.jobLocation = "Site";
          callData.step = "ask_complaint";
          callData.retries = 0;
          callData.lastQuestion = "‡§†‡•Ä‡§ï ‡§π‡•à‡•§ ‡§Ö‡§¨ ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§¨‡§§‡§æ‡§á‡§è - ‡§Æ‡§∂‡•Ä‡§® ‡§Æ‡•á‡§Ç ‡§ï‡•ç‡§Ø‡§æ ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§Ü ‡§∞‡§π‡•Ä ‡§π‡•à?";
          ask(twiml, callData.lastQuestion);
          activeCalls.set(CallSid, callData);
          return res.type("text/xml").send(twiml.toString());
        }

        callData.lastQuestion = "‡§ó‡§≤‡§§ ‡§á‡§®‡§™‡•Å‡§ü‡•§ 1 ‡§¶‡§¨‡§æ‡§á‡§è ‡§∏‡§æ‡§á‡§ü ‡§ï‡•á ‡§≤‡§ø‡§è, 2 ‡§¶‡§¨‡§æ‡§á‡§è ‡§ï‡§æ‡§∞‡•ç‡§Ø‡§∂‡§æ‡§≤‡§æ ‡§ï‡•á ‡§≤‡§ø‡§è‡•§";
        askDTMF(twiml, callData.lastQuestion, 1);
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      }
    }

    // ===== ASK ADDRESS =====

    // ===== ASK ADDRESS =====
    if (callData.step === "ask_address") {
      // Handle STAR (*) key to repeat last question
      if (Digits === "*") {
        console.log("üîÑ User pressed * - Repeating address question");
        callData.lastQuestion = "‡§Æ‡§∂‡•Ä‡§® ‡§ï‡§æ ‡§™‡§§‡§æ ‡§¶‡•ã‡§¨‡§æ‡§∞‡§æ ‡§¨‡•ã‡§≤‡§ø‡§è‡•§ ‡§∂‡§π‡§∞ ‡§î‡§∞ ‡§á‡§≤‡§æ‡§ï‡•á ‡§ï‡§æ ‡§®‡§æ‡§Æ ‡§ú‡§∞‡•Ç‡§∞‡•Ä ‡§π‡•à‡•§";
        ask(twiml, callData.lastQuestion);
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      }

      if (rejectInvalid(rawSpeech)) {
        callData.retries = (callData.retries || 0) + 1;

        if (callData.retries >= 3) {
          callData.address = "Not Provided";
          callData.step = "ask_pincode";
          callData.retries = 0;
          callData.lastQuestion = "Theek hai. Ab apna 6 digit pincode batayein.";
          ask(twiml, callData.lastQuestion);
          activeCalls.set(CallSid, callData);
          return res.type("text/xml").send(twiml.toString());
        }

        console.log(`‚ö†Ô∏è Invalid address input - Retry ${callData.retries}/3`);
        ask(twiml, callData.lastQuestion);
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      }

      const address = extractLocationAddressV2(rawSpeech);
      console.log(`‚úì Address: ${address || "N/A"}`);

      if (!address || !isValidAddress(address)) {
        callData.retries = (callData.retries || 0) + 1;

        if (callData.retries >= 3) {
          callData.address = "Not Provided";
          callData.step = "ask_pincode";
          callData.retries = 0;
          callData.lastQuestion = "Theek hai. Ab apna 6 digit pincode batayein.";
          ask(twiml, callData.lastQuestion);
          activeCalls.set(CallSid, callData);
          return res.type("text/xml").send(twiml.toString());
        }

        console.log(`‚ö†Ô∏è Invalid address format - Retry ${callData.retries}/3`);
        callData.lastQuestion = "‡§™‡§§‡§æ ‡§∏‡•ç‡§™‡§∑‡•ç‡§ü ‡§®‡§π‡•Ä‡§Ç ‡§∏‡•Å‡§®‡§æ‡•§ ‡§∂‡§π‡§∞ ‡§î‡§∞ ‡§á‡§≤‡§æ‡§ï‡•á ‡§ï‡§æ ‡§®‡§æ‡§Æ ‡§¶‡•ã‡§¨‡§æ‡§∞‡§æ ‡§¨‡•ã‡§≤‡§ø‡§è, ‡§∏‡§æ‡§´-‡§∏‡§æ‡§´‡•§";
        ask(twiml, callData.lastQuestion);
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      }

      callData.address = address;
      callData.step = "ask_pincode";
      callData.retries = 0;
      callData.lastQuestion = "‡§¨‡§π‡•Å‡§§ ‡§Ö‡§ö‡•ç‡§õ‡§æ! ‡§Ö‡§¨ ‡§Ö‡§™‡§®‡§æ 6 ‡§Ö‡§Ç‡§ï‡•ã‡§Ç ‡§ï‡§æ ‡§™‡§ø‡§®‡§ï‡•ã‡§° ‡§¨‡§§‡§æ‡§á‡§è‡•§";
      ask(twiml, callData.lastQuestion);
      activeCalls.set(CallSid, callData);
      return res.type("text/xml").send(twiml.toString());
    }

    // ===== ASK PINCODE =====
    if (callData.step === "ask_pincode") {
      // Handle STAR (*) key to repeat last question
      if (Digits === "*") {
        console.log("üîÑ User pressed * - Repeating pincode question");
        callData.lastQuestion = "‡§™‡§ø‡§®‡§ï‡•ã‡§° ‡§¨‡•ã‡§≤‡§ø‡§è ‡§®‡§æ, ‡§ú‡§∞‡§æ ‡§∏‡§æ‡§´ ‡§ï‡§∞‡§ï‡•á‡•§ 6 ‡§Ö‡§Ç‡§ï‡•§";
        ask(twiml, callData.lastQuestion);
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      }

      if (rejectInvalid(rawSpeech)) {
        callData.retries = (callData.retries || 0) + 1;

        if (callData.retries >= 3) {
          callData.pincode = "000000";
          callData.step = "ask_complaint";
          callData.retries = 0;
          callData.lastQuestion = "Theek hai. Ab machine mein kya problem hai?";
          ask(twiml, callData.lastQuestion);
          activeCalls.set(CallSid, callData);
          return res.type("text/xml").send(twiml.toString());
        }

        console.log(`‚ö†Ô∏è Invalid pincode input - Retry ${callData.retries}/3`);
        ask(twiml, callData.lastQuestion);
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      }

      const pincode = extractPincodeV2(rawSpeech);

      if (!pincode || !isValidPincode(pincode)) {
        callData.retries = (callData.retries || 0) + 1;

        if (callData.retries >= 3) {
          callData.pincode = "000000";
          callData.step = "ask_complaint";
          callData.retries = 0;
          callData.lastQuestion = "Theek hai. Ab machine mein kya problem hai?";
          ask(twiml, callData.lastQuestion);
          activeCalls.set(CallSid, callData);
          return res.type("text/xml").send(twiml.toString());
        }

        console.log(`‚ö†Ô∏è Invalid pincode format - Retry ${callData.retries}/3`);
        callData.lastQuestion = "‡§ï‡•É‡§™‡§Ø‡§æ ‡§Ö‡§™‡§®‡§æ ‡§∏‡§π‡•Ä 6 ‡§Ö‡§Ç‡§ï‡•ã‡§Ç ‡§ï‡§æ ‡§™‡§ø‡§®‡§ï‡•ã‡§° ‡§¨‡•ã‡§≤‡§ø‡§è‡•§";
        ask(twiml, callData.lastQuestion);
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      }

      callData.pincode = pincode;
      callData.retries = 0;
      callData.step = "ask_complaint";
      callData.lastQuestion = "‡§¨‡§ø‡§≤‡•ç‡§ï‡•Å‡§≤ ‡§†‡•Ä‡§ï ‡§π‡•à‡•§ ‡§Ö‡§¨ ‡§Æ‡•Å‡§ù‡•á ‡§¨‡§§‡§æ‡§á‡§è, ‡§Æ‡§∂‡•Ä‡§® ‡§Æ‡•á‡§Ç ‡§ï‡•ç‡§Ø‡§æ ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§π‡•à?";
      ask(twiml, callData.lastQuestion);
      activeCalls.set(CallSid, callData);
      return res.type("text/xml").send(twiml.toString());
    }

    // ===== ASK COMPLAINT =====
    if (callData.step === "ask_complaint") {
      // Handle STAR (*) key to repeat last question
      if (Digits === "*") {
        console.log("üîÑ User pressed * - Repeating complaint question");
        callData.lastQuestion = "‡§Æ‡§∂‡•Ä‡§® ‡§Ø‡§æ ‡§â‡§™‡§ï‡§∞‡§£ ‡§Æ‡•á‡§Ç ‡§ï‡•ç‡§Ø‡§æ ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§π‡•à? ‡§™‡•Ç‡§∞‡§æ ‡§µ‡§ø‡§µ‡§∞‡§£ ‡§¨‡§§‡§æ‡§á‡§è ‡§®‡§æ‡•§ ‡§ú‡•à‡§∏‡•á: ‡§á‡§Ç‡§ú‡§® ‡§®‡§π‡•Ä‡§Ç ‡§ö‡§≤‡§æ ‡§∞‡§π‡§æ, ‡§è‡§∏‡•Ä ‡§†‡§Ç‡§°‡§æ ‡§®‡§π‡•Ä‡§Ç ‡§ï‡§∞ ‡§∞‡§π‡§æ, ‡§π‡§æ‡§á‡§°‡•ç‡§∞‡•ã‡§≤‡§ø‡§ï ‡§¶‡§¨‡§æ‡§µ ‡§ï‡§Æ ‡§π‡•à, ‡§Ü‡§¶‡§ø‡•§";
        ask(twiml, callData.lastQuestion);
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      }

      if (rejectInvalid(rawSpeech)) {
        callData.retries = (callData.retries || 0) + 1;

        if (callData.retries >= 3) {
          console.log("‚ùå No complaint info after 2 retries - Transferring to agent");
          twiml.say(
            { voice: "Polly.Aditi", language: "hi-IN" },
            "‡§∏‡§Æ‡§ù ‡§®‡§π‡•Ä‡§Ç ‡§Ü ‡§∞‡§π‡§æ‡•§ ‡§Ü‡§™‡§ï‡•ã ‡§è‡§ï ‡§è‡§ú‡•á‡§Ç‡§ü ‡§∏‡•á ‡§ú‡•ã‡§°‡§º ‡§¶‡§ø‡§Ø‡§æ ‡§ú‡§æ ‡§∞‡§π‡§æ ‡§π‡•à‡•§"
          );
          twiml.dial(process.env.HUMAN_AGENT_NUMBER);
          activeCalls.delete(CallSid);
          return res.type("text/xml").send(twiml.toString());
        }

        console.log(`‚ö†Ô∏è Invalid complaint input - Retry ${callData.retries}/2`);
        ask(twiml, callData.lastQuestion);
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      }

      callData.rawComplaint = rawSpeech;
      const detected = detectComplaint(rawSpeech);
      console.log(`üîç Complaint detection result: ${detected.complaint} (Score: ${detected.score})`);

      // If no clear match or low score
      if (!detected || detected.score < 3) {
        console.log(`‚ö†Ô∏è No clear complaint match - Asking clarifying questions`);
        callData.step = "ask_complaint_clarify";
        callData.retries = 0;
        callData.lastQuestion = "‡§†‡•Ä‡§ï ‡§π‡•à, ‡§•‡•ã‡§°‡§º‡§æ ‡§î‡§∞ ‡§µ‡§ø‡§µ‡§∞‡§£ ‡§∏‡•á ‡§¨‡§§‡§æ‡§á‡§è‡•§ ‡§ï‡§¨ ‡§∏‡•á ‡§Ø‡§π ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§π‡•à? ‡§Æ‡§∂‡•Ä‡§® ‡§ï‡•Ä ‡§∂‡•Å‡§∞‡•Å‡§Ü‡§§ ‡§Æ‡•á‡§Ç ‡§•‡•Ä ‡§Ø‡§æ ‡§¨‡§æ‡§¶ ‡§Æ‡•á‡§Ç? ‡§Ø‡§æ ‡§ï‡•ã‡§à ‡§µ‡§ø‡§¶‡•ç‡§Ø‡•Å‡§§ ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§π‡•à?";
        ask(twiml, callData.lastQuestion);
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      }

      console.log(`‚úì Complaint detected: ${detected.complaint} (Score: ${detected.score})`);
      callData.complaintTitle = detected.complaint;
      
      // Ask for confirmation before proceeding
      callData.step = "confirm_complaint_title";
      callData.retries = 0;
      callData.lastQuestion = `‡§†‡•Ä‡§ï ‡§π‡•à, ‡§∏‡§Æ‡§ù ‡§ó‡§Ø‡§æ‡•§ ‡§§‡•ã ‡§Ü‡§™‡§ï‡•Ä ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§ï‡•Ä ‡§∂‡•ç‡§∞‡•á‡§£‡•Ä ‡§π‡•à: ${detected.complaint}‡•§ ‡§ï‡•ç‡§Ø‡§æ ‡§Ø‡§π ‡§†‡•Ä‡§ï ‡§π‡•à? ‡§Ö‡§ó‡§∞ ‡§∏‡§π‡•Ä ‡§π‡•à ‡§§‡•ã ‡§è‡§ï ‡§¶‡§¨‡§æ‡§á‡§è, ‡§Ö‡§ó‡§∞ ‡§ó‡§≤‡§§ ‡§π‡•à ‡§§‡•ã ‡§¶‡•ã ‡§¶‡§¨‡§æ‡§á‡§è‡•§`;
      askDTMF(twiml, callData.lastQuestion, 1);
      activeCalls.set(CallSid, callData);
      return res.type("text/xml").send(twiml.toString());
    }

    // ===== CONFIRM COMPLAINT TITLE =====
    if (callData.step === "confirm_complaint_title") {
      if (Digits === "*") {
        console.log("üîÑ User pressed * - Repeating confirmation question");
        callData.lastQuestion = "‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§ï‡•Ä ‡§∂‡•ç‡§∞‡•á‡§£‡•Ä ‡§∏‡§π‡•Ä ‡§π‡•à ‡§®‡§æ? 1 ‡§¶‡§¨‡§æ‡§á‡§è ‡§π‡§æ‡§Å ‡§§‡•ã, 2 ‡§¶‡§¨‡§æ‡§á‡§è ‡§®‡§π‡•Ä‡§Ç ‡§§‡•ã‡•§";
        askDTMF(twiml, callData.lastQuestion, 1);
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      }

      if (Digits === "1") {
        console.log(`‚úì User confirmed complaint title: ${callData.complaintTitle}`);
        
        // Check if this category has sub-complaints
        const hasSubComplaints = complaintMap[callData.complaintTitle]?.subTitles &&
                                Object.keys(complaintMap[callData.complaintTitle].subTitles).length > 1;

        if (hasSubComplaints) {
          // Move to sub-complaint selection
          callData.step = "ask_sub_complaint";
          callData.retries = 0;
          const subQuestion = getSubComplaintQuestion(callData.complaintTitle);
          callData.lastQuestion = subQuestion;
          ask(twiml, subQuestion);
          activeCalls.set(CallSid, callData);
          return res.type("text/xml").send(twiml.toString());
        } else {
          // No sub-complaints, go directly to service date
          callData.complaintSubTitle = "General";
          callData.step = "ask_service_date";
          callData.retries = 0;
          callData.lastQuestion = "‡§ß‡§®‡•ç‡§Ø‡§µ‡§æ‡§¶! ‡§Ö‡§¨ ‡§¨‡§§‡§æ‡§á‡§è, ‡§á‡§Ç‡§ú‡•Ä‡§®‡§ø‡§Ø‡§∞ ‡§ï‡•á ‡§≤‡§ø‡§è ‡§ï‡•å‡§® ‡§∏‡•Ä ‡§§‡§æ‡§∞‡•Ä‡§ñ ‡§†‡•Ä‡§ï ‡§π‡•à? ‡§§‡§æ‡§∞‡•Ä‡§ñ ‡§¨‡•ã‡§≤‡§ø‡§è - ‡§ú‡•à‡§∏‡•á: 15 ‡§´‡§∞‡§µ‡§∞‡•Ä, 15/2, ‡§Ü‡§ú, ‡§ï‡§≤, ‡§Ø‡§æ ‡§™‡§∞‡§∏‡•ã‡§Ç‡•§";
          ask(twiml, callData.lastQuestion);
          activeCalls.set(CallSid, callData);
          return res.type("text/xml").send(twiml.toString());
        }
      } else if (Digits === "2") {
        console.log(`‚ùå User rejected complaint title - Re-asking`);
        callData.step = "ask_complaint";
        callData.retries = 0;
        callData.lastQuestion = "‡§†‡•Ä‡§ï ‡§π‡•à, ‡§¶‡•ã‡§¨‡§æ‡§∞‡§æ ‡§™‡•Ç‡§õ‡§§‡§æ ‡§π‡•Ç‡§Å‡•§ ‡§Æ‡§∂‡•Ä‡§® ‡§Ø‡§æ ‡§â‡§™‡§ï‡§∞‡§£ ‡§Æ‡•á‡§Ç ‡§Ö‡§∏‡§≤‡•Ä ‡§ï‡•ç‡§Ø‡§æ ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§π‡•à? ‡§™‡•Ç‡§∞‡§æ ‡§µ‡§ø‡§µ‡§∞‡§£ ‡§¨‡§§‡§æ‡§á‡§è‡•§";
        ask(twiml, callData.lastQuestion);
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      } else {
        callData.retries = (callData.retries || 0) + 1;
        if (callData.retries >= 3) {
          console.log("‚ùå Invalid confirmation after retries - Using detected complaint");
          // Use the detected complaint as-is
          const hasSubComplaints = complaintMap[callData.complaintTitle]?.subTitles &&
                                  Object.keys(complaintMap[callData.complaintTitle].subTitles).length > 1;

          if (hasSubComplaints) {
            callData.step = "ask_sub_complaint";
            callData.retries = 0;
            const subQuestion = getSubComplaintQuestion(callData.complaintTitle);
            callData.lastQuestion = subQuestion;
            ask(twiml, subQuestion);
            activeCalls.set(CallSid, callData);
            return res.type("text/xml").send(twiml.toString());
          } else {
            callData.complaintSubTitle = "General";
            callData.step = "ask_service_date";
            callData.retries = 0;
            callData.lastQuestion = "‡§ö‡§≤‡•ã ‡§Ü‡§ó‡•á ‡§¨‡§¢‡§º‡§§‡•á ‡§π‡•à‡§Ç‡•§ ‡§á‡§Ç‡§ú‡•Ä‡§®‡§ø‡§Ø‡§∞ ‡§ï‡•á ‡§≤‡§ø‡§è ‡§ï‡•å‡§® ‡§∏‡•Ä ‡§§‡§æ‡§∞‡•Ä‡§ñ ‡§†‡•Ä‡§ï ‡§π‡•à?";
            ask(twiml, callData.lastQuestion);
            activeCalls.set(CallSid, callData);
            return res.type("text/xml").send(twiml.toString());
          }
        }
        
        askDTMF(twiml, "‡§ï‡•É‡§™‡§Ø‡§æ ‡§è‡§ï ‡§Ø‡§æ ‡§¶‡•ã ‡§¶‡§¨‡§æ‡§á‡§è‡•§ ‡§è‡§ï ‡§Ö‡§ó‡§∞ ‡§∏‡§π‡•Ä, ‡§¶‡•ã ‡§Ö‡§ó‡§∞ ‡§ó‡§≤‡§§‡•§", 1);
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      }
    }

    // ===== ASK COMPLAINT CLARIFICATION =====
    if (callData.step === "ask_complaint_clarify") {
      if (Digits === "*") {
        console.log("üîÑ User pressed * - Repeating clarification question");
        ask(twiml, callData.lastQuestion);
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      }

      if (rejectInvalid(rawSpeech)) {
        callData.retries = (callData.retries || 0) + 1;
        if (callData.retries >= 3) {
          // If still no clear complaint, use "Other"
          console.log("‚ùå Complaint still unclear - Using 'Other' category");
          callData.complaintTitle = "General Problem";
          callData.complaintSubTitle = "Other";
          callData.step = "ask_service_date";
          callData.retries = 0;
          callData.lastQuestion = "‡§†‡•Ä‡§ï ‡§π‡•à ‡§¨‡§∏‡•§ ‡§á‡§Ç‡§ú‡•Ä‡§®‡§ø‡§Ø‡§∞ ‡§ï‡•ã ‡§ï‡§¨ ‡§¨‡•Å‡§≤‡§æ‡§®‡§æ ‡§π‡•à? ‡§Ü‡§ú, ‡§ï‡§≤, ‡§Ø‡§æ ‡§™‡§∞‡§∏‡•ã‡§Ç?";
          ask(twiml, callData.lastQuestion);
          activeCalls.set(CallSid, callData);
          return res.type("text/xml").send(twiml.toString());
        }
        
        console.log(`‚ö†Ô∏è Clarification unclear - Retry ${callData.retries}/2`);
        ask(twiml, callData.lastQuestion);
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      }

      // Try to detect complaint again with clarification
      const secondDetected = detectComplaint(rawSpeech);
      
      if (secondDetected && secondDetected.score >= 3) {
        callData.complaintTitle = secondDetected.complaint;
        console.log(`‚úì Complaint detected from clarification: ${secondDetected.complaint}`);
        callData.step = "confirm_complaint_title";
        callData.retries = 0;
        callData.lastQuestion = `‡§†‡•Ä‡§ï ‡§π‡•à, ‡§§‡•ã ‡§Ü‡§™‡§ï‡•Ä ‡§Æ‡•Å‡§ñ‡•ç‡§Ø ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§π‡•à: ${secondDetected.complaint}‡•§ ‡§∏‡§π‡•Ä ‡§π‡•à ‡§®‡§æ? ‡§è‡§ï ‡§¶‡§¨‡§æ‡§á‡§è ‡§π‡§æ‡§Å ‡§§‡•ã, ‡§¶‡•ã ‡§¶‡§¨‡§æ‡§á‡§è ‡§®‡§π‡•Ä‡§Ç ‡§§‡•ã‡•§`;
        askDTMF(twiml, callData.lastQuestion, 1);
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      } else {
        // Still no clear match
        console.log("‚ùå No clear complaint from clarification - Using 'Other'");
        callData.complaintTitle = "General Problem";
        callData.complaintSubTitle = "Other";
        callData.step = "ask_service_date";
        callData.retries = 0;
        callData.lastQuestion = "‡§†‡•Ä‡§ï ‡§π‡•à‡•§ ‡§Ö‡§¨ ‡§á‡§Ç‡§ú‡•Ä‡§®‡§ø‡§Ø‡§∞ ‡§ï‡•ã ‡§ï‡§¨ ‡§¨‡•Å‡§≤‡§æ‡§®‡§æ ‡§π‡•à?";
        ask(twiml, callData.lastQuestion);
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      }
    }

    // ===== ASK SUB-COMPLAINT =====
    if (callData.step === "ask_sub_complaint") {
      // Handle STAR (*) key to repeat last question
      if (Digits === "*") {
        console.log("üîÑ User pressed * - Repeating sub-complaint question");
        const subQuestion = getSubComplaintQuestion(callData.complaintTitle);
        callData.lastQuestion = subQuestion;
        console.log(`üìã Asking about ${callData.complaintTitle} sub-types`);
        ask(twiml, callData.lastQuestion);
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      }

      if (rejectInvalid(rawSpeech)) {
        callData.retries = (callData.retries || 0) + 1;

        if (callData.retries >= 3) {
          console.log("‚ùå Sub-complaint not clear - Using Other");
          callData.complaintSubTitle = "Other";
          callData.step = "ask_service_date";
          callData.retries = 0;
          callData.lastQuestion = "Theek hai. Ab engineer ke liye kaun si tarikh theek hai?";
          ask(twiml, callData.lastQuestion);
          activeCalls.set(CallSid, callData);
          return res.type("text/xml").send(twiml.toString());
        }

        const subQuestion = getSubComplaintQuestion(callData.complaintTitle);
        callData.lastQuestion = "‡§∏‡•ç‡§™‡§∑‡•ç‡§ü ‡§®‡§π‡•Ä‡§Ç ‡§∏‡•Å‡§®‡§æ‡•§ " + subQuestion;
        ask(twiml, callData.lastQuestion);
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      }

      const subResult = detectSubComplaint(callData.complaintTitle, rawSpeech);
      console.log(`‚úì Sub-complaint: ${subResult.subTitle} (Confidence: ${subResult.confidence})`);

      callData.complaintSubTitle = subResult.subTitle || "Other";
      
      // Move to service date
      callData.step = "ask_service_date";
      callData.retries = 0;
      callData.lastQuestion = "‡§†‡•Ä‡§ï ‡§π‡•à! ‡§Ö‡§¨ ‡§¨‡§§‡§æ‡§á‡§è, ‡§á‡§Ç‡§ú‡•Ä‡§®‡§ø‡§Ø‡§∞ ‡§ï‡•á ‡§≤‡§ø‡§è ‡§ï‡•å‡§® ‡§∏‡•Ä ‡§§‡§æ‡§∞‡•Ä‡§ñ ‡§†‡•Ä‡§ï ‡§π‡•à? ‡§§‡§æ‡§∞‡•Ä‡§ñ ‡§¨‡•ã‡§≤‡§ø‡§è - ‡§ú‡•à‡§∏‡•á: 15 ‡§´‡§∞‡§µ‡§∞‡•Ä, 15/2, ‡§Ü‡§ú, ‡§ï‡§≤, ‡§Ø‡§æ ‡§™‡§∞‡§∏‡•ã‡§Ç‡•§";
      ask(twiml, callData.lastQuestion);
      activeCalls.set(CallSid, callData);
      return res.type("text/xml").send(twiml.toString());
    }

    // ===== ASK SERVICE DATE =====
    if (callData.step === "ask_service_date") {
      // Handle STAR (*) key to repeat last question
      if (Digits === "*") {
        console.log("üîÑ User pressed * - Repeating service date question");
        callData.lastQuestion = "‡§á‡§Ç‡§ú‡•Ä‡§®‡§ø‡§Ø‡§∞ ‡§ï‡•á ‡§≤‡§ø‡§è ‡§ï‡•å‡§® ‡§∏‡•Ä ‡§§‡§æ‡§∞‡•Ä‡§ñ ‡§†‡•Ä‡§ï ‡§π‡•à? ‡§§‡§æ‡§∞‡•Ä‡§ñ ‡§¨‡§§‡§æ‡§á‡§è ‡§ú‡•à‡§∏‡•á: 15 ‡§´‡§∞‡§µ‡§∞‡•Ä ‡§Ø‡§æ 15/2‡•§";
        ask(twiml, callData.lastQuestion);
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      }

      const date = extractServiceDate(rawSpeech);

      if (!date) {
        callData.retries = (callData.retries || 0) + 1;

        if (callData.retries >= 3) {
          const tomorrow = new Date();
          tomorrow.setDate(tomorrow.getDate() + 1);
          callData.serviceDate = tomorrow;
          callData.step = "ask_service_time_from";
          callData.retries = 0;
          callData.lastQuestion = "‡§†‡•Ä‡§ï ‡§π‡•à, ‡§ï‡§≤ ‡§ï‡•á ‡§≤‡§ø‡§è ‡§§‡§Ø ‡§ï‡§∞ ‡§¶‡§ø‡§Ø‡§æ‡•§ ‡§Ö‡§¨ ‡§¨‡§§‡§æ‡§á‡§è, ‡§á‡§Ç‡§ú‡•Ä‡§®‡§ø‡§Ø‡§∞ ‡§ï‡§ø‡§∏ ‡§∏‡§Æ‡§Ø ‡§Ü ‡§∏‡§ï‡§§‡§æ ‡§π‡•à?";
          ask(twiml, callData.lastQuestion);
          activeCalls.set(CallSid, callData);
          return res.type("text/xml").send(twiml.toString());
        }

        callData.lastQuestion = "‡§§‡§æ‡§∞‡•Ä‡§ñ ‡§®‡§π‡•Ä‡§Ç ‡§∏‡•Å‡§®‡§æ‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§¨‡•ã‡§≤‡§ø‡§è: 13 ‡§´‡§∞‡§µ‡§∞‡•Ä, 15/2";
        ask(twiml, callData.lastQuestion);
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      }

      console.log(`‚úì Service Date: ${date.toDateString()}`);
      callData.serviceDate = date;
      callData.step = "ask_service_time_from";
      callData.lastQuestion = "‡§¨‡§ø‡§≤‡•ç‡§ï‡•Å‡§≤ ‡§†‡•Ä‡§ï ‡§π‡•à‡•§ ‡§Ö‡§¨ ‡§¨‡§§‡§æ‡§á‡§è, ‡§á‡§Ç‡§ú‡•Ä‡§®‡§ø‡§Ø‡§∞ ‡§ï‡§ø‡§§‡§®‡•á ‡§¨‡§ú‡•á ‡§Ü ‡§∏‡§ï‡§§‡§æ ‡§π‡•à? ‡§∏‡•Å‡§¨‡§π, ‡§¶‡•ã‡§™‡§π‡§∞ ‡§Ø‡§æ ‡§∂‡§æ‡§Æ, ‡§ï‡•ã‡§à ‡§≠‡•Ä ‡§∏‡§Æ‡§Ø ‡§¨‡§§‡§æ ‡§¶‡•Ä‡§ú‡§ø‡§è‡•§";
      ask(twiml, callData.lastQuestion);
      activeCalls.set(CallSid, callData);
      return res.type("text/xml").send(twiml.toString());
    }

    // ===== ASK FROM TIME =====
    if (callData.step === "ask_service_time_from") {
      // Handle STAR (*) key to repeat last question
      if (Digits === "*") {
        console.log("üîÑ User pressed * - Repeating from time question");
        callData.lastQuestion = "‡§á‡§Ç‡§ú‡•Ä‡§®‡§ø‡§Ø‡§∞ ‡§ï‡§ø‡§§‡§®‡•á ‡§¨‡§ú‡•á ‡§∏‡•á ‡§Ü ‡§∏‡§ï‡§§‡§æ ‡§π‡•à? ‡§∂‡•Å‡§∞‡•Å‡§Ü‡§§ ‡§ï‡§æ ‡§∏‡§Æ‡§Ø ‡§¨‡•ã‡§≤‡§ø‡§è ‡§®‡§æ‡•§";
        ask(twiml, callData.lastQuestion);
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      }

      const fromTime = extractTimeV2(rawSpeech);

      if (!fromTime) {
        callData.retries = (callData.retries || 0) + 1;

        if (callData.retries >= 3) {
          callData.fromTime = "9:00 AM";
          callData.step = "ask_service_time_to";
          callData.retries = 0;
          callData.lastQuestion = "‡§ï‡§ø‡§§‡§®‡•á ‡§¨‡§ú‡•á ‡§§‡§ï ‡§á‡§Ç‡§ú‡•Ä‡§®‡§ø‡§Ø‡§∞ ‡§ï‡§æ‡§Æ ‡§ï‡§∞ ‡§∏‡§ï‡§§‡§æ ‡§π‡•à? ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§‡§ø ‡§∏‡§Æ‡§Ø ‡§¨‡•ã‡§≤‡§ø‡§è‡•§ ‡§ú‡•à‡§∏‡•á: 5 ‡§¨‡§ú‡•á, 7 ‡§¨‡§ú‡•á‡•§";
          ask(twiml, callData.lastQuestion);
          activeCalls.set(CallSid, callData);
          return res.type("text/xml").send(twiml.toString());
        }

        callData.lastQuestion = "‡§∏‡§Æ‡§Ø ‡§∏‡•ç‡§™‡§∑‡•ç‡§ü ‡§¨‡•ã‡§≤‡§ø‡§è‡•§ ‡§ú‡•à‡§∏‡•á: ‡§∏‡•Å‡§¨‡§π ‡§®‡•å ‡§¨‡§ú‡•á, ‡§¶‡•ã‡§™‡§π‡§∞ ‡§¶‡•ã ‡§¨‡§ú‡•á, ‡§∂‡§æ‡§Æ ‡§™‡§æ‡§Å‡§ö ‡§¨‡§ú‡•á‡•§";
        ask(twiml, callData.lastQuestion);
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      }

      console.log(`‚úì From Time: ${fromTime}`);
      callData.fromTime = fromTime;
      callData.step = "ask_service_time_to";
      callData.lastQuestion = "‡§¨‡§ø‡§≤‡•ç‡§ï‡•Å‡§≤‡•§ ‡§Ö‡§¨ ‡§¨‡§§‡§æ‡§á‡§è, ‡§ï‡§ø‡§§‡§®‡•á ‡§¨‡§ú‡•á ‡§§‡§ï ‡§á‡§Ç‡§ú‡•Ä‡§®‡§ø‡§Ø‡§∞ ‡§µ‡§π‡§æ‡§Å ‡§∞‡§π ‡§∏‡§ï‡§§‡§æ ‡§π‡•à? ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§‡§ø ‡§∏‡§Æ‡§Ø ‡§¨‡§§‡§æ‡§á‡§è‡•§";
      ask(twiml, callData.lastQuestion);
      activeCalls.set(CallSid, callData);
      return res.type("text/xml").send(twiml.toString());
    }

    // ===== ASK TO TIME & SAVE =====
    if (callData.step === "ask_service_time_to") {
      // Handle STAR (*) key to repeat last question
      if (Digits === "*") {
        console.log("üîÑ User pressed * - Repeating to time question");
        callData.lastQuestion = "‡§ï‡§ø‡§§‡§®‡•á ‡§¨‡§ú‡•á ‡§§‡§ï ‡§á‡§Ç‡§ú‡•Ä‡§®‡§ø‡§Ø‡§∞ ‡§ï‡§æ‡§Æ ‡§ï‡§∞ ‡§∏‡§ï‡§§‡§æ ‡§π‡•à? ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§‡§ø ‡§∏‡§Æ‡§Ø ‡§¨‡§§‡§æ‡§á‡§è‡•§";
        ask(twiml, callData.lastQuestion);
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      }

      const toTime = extractTimeV2(rawSpeech);

      if (!toTime) {
        callData.retries = (callData.retries || 0) + 1;

        if (callData.retries >= 3) {
          callData.toTime = "5:00 PM";

          console.log("\n" + "=".repeat(120));
          console.log("‚úÖ ALL DATA COLLECTED - SAVING COMPLAINT");
          console.log("=".repeat(120));
          console.log(`üîß Chassis: ${callData.chassis}`);
          console.log(`üì± Caller: ${callData.callerName} (${callData.callerPhone})`);
          console.log(`üè¢ Machine Type: ${callData.machineType}`);
          console.log(`üî¥ Status: ${callData.machineStatus}`);
          console.log(`üìç Location: ${callData.jobLocation}`);
          console.log(`üè† Address: ${callData.address}`);
          console.log(`üìÆ Pincode: ${callData.pincode}`);
          console.log(`üéØ Complaint: ${callData.complaintTitle} ‚Üí ${callData.complaintSubTitle}`);
          console.log(`üìÖ Service: ${callData.serviceDate?.toDateString()}`);
          console.log(`‚è∞ Time: ${callData.fromTime} - ${callData.toTime}`);
          console.log("=".repeat(120) + "\n");

          if (callData.customerData) {
            const result = await saveComplaint(twiml, callData);

            if (result.success) {
              twiml.say(
                { voice: "Polly.Aditi", language: "hi-IN" },
                `Bahut bahut dhanyavaad! Aapki complaint successfully register ho gayi hai${result.sapId ? '. Complaint number: ' + result.sapId : ''}. Hamara engineer jald hi aapse contact karega!`
              );
            } else {
              twiml.say(
                { voice: "Polly.Aditi", language: "hi-IN" },
                "Dhanyavaad! Aapki complaint register ho gayi hai. Hamari team aapko contact karega!"
              );
            }
          } else {
            twiml.say(
              { voice: "Polly.Aditi", language: "hi-IN" },
              "Dhanyavaad! Aapki complaint register ho gayi hai. Hamari team aapko contact karega!"
            );
          }

          twiml.hangup();
          activeCalls.delete(CallSid);
          return res.type("text/xml").send(twiml.toString());
        }

        callData.lastQuestion = "‡§∏‡§Æ‡§æ‡§™‡•ç‡§§‡§ø ‡§∏‡§Æ‡§Ø ‡§¨‡§§‡§æ‡§á‡§è ‡§®‡§æ‡•§ ‡§ú‡•à‡§∏‡•á: ‡§™‡§æ‡§Å‡§ö ‡§¨‡§ú‡•á, ‡§∏‡§æ‡§§ ‡§¨‡§ú‡•á‡•§";
        ask(twiml, callData.lastQuestion);
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      }

      console.log(`‚úì To Time: ${toTime}`);
      callData.toTime = toTime;

      console.log("\n" + "=".repeat(120));
      console.log("‚úÖ ALL DATA COLLECTED - SAVING COMPLAINT");
      console.log("=".repeat(120));
      console.log(`üîß Chassis: ${callData.chassis}`);
      console.log(`üì± Caller: ${callData.callerName} (${callData.callerPhone})`);
      console.log(`üè¢ Machine Type: ${callData.machineType}`);
      console.log(`üî¥ Status: ${callData.machineStatus}`);
      console.log(`üìç Location: ${callData.jobLocation}`);
      console.log(`üè† Address: ${callData.address}`);
      console.log(`üìÆ Pincode: ${callData.pincode}`);
      console.log(`üéØ Complaint: ${callData.complaintTitle} ‚Üí ${callData.complaintSubTitle}`);
      console.log(`üìÖ Service: ${callData.serviceDate?.toDateString()}`);
      console.log(`‚è∞ Time: ${callData.fromTime} - ${toTime}`);
      console.log("=".repeat(120) + "\n");

      if (callData.customerData) {
        const result = await saveComplaint(twiml, callData);

        if (result.success) {
          twiml.say(
            { voice: "Polly.Aditi", language: "hi-IN" },
            `Bahut bahut dhanyavaad! Aapki complaint successfully register ho gayi hai${result.sapId ? '. Complaint number: ' + result.sapId : ''}. Hamara engineer jald hi aapse contact karega!`
          );
        } else {
          twiml.say(
            { voice: "Polly.Aditi", language: "hi-IN" },
            "Dhanyavaad! Aapki complaint register ho gayi hai. Hamari team aapko contact karega!"
          );
        }
      } else {
        twiml.say(
          { voice: "Polly.Aditi", language: "hi-IN" },
          "Dhanyavaad! Aapki complaint register ho gayi hai. Hamari team aapko contact karega!"
        );
      }

      twiml.hangup();
      activeCalls.delete(CallSid);
      return res.type("text/xml").send(twiml.toString());
    }

    activeCalls.set(CallSid, callData);
    res.type("text/xml").send(twiml.toString());
  } catch (error) {
    console.error("‚ùå Call Processing Error:", error);
    const twiml = new VoiceResponse();
    twiml.say(
      { voice: "Polly.Aditi", language: "hi-IN" },
      "Kshama karein, kuch technical problem hai. Kripya agent se baat karne ke liye do dabayein."
    );
    twiml.dial(process.env.HUMAN_AGENT_NUMBER);
    return res.type("text/xml").send(twiml.toString());
  }
});

export default router;
