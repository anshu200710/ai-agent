import express from "express";
import twilio from "twilio";
import axios from "axios";
import Complaint from "../models/Complaint.js";
import {
  extractPhoneNumberV2,
  extractChassisNumberV2,
  extractNameV2,
  extractPincodeV2,
  extractLocationAddressV2,
  extractTimeV2,
  isValidPhone,
  isValidChassis,
  isValidName,
  isValidAddress,
  isValidPincode
} from '../utils/improved_extraction.js';

const router = express.Router();
const VoiceResponse = twilio.twiml.VoiceResponse;

const activeCalls = new Map();

/* ======================= EXTERNAL API CONFIG ======================= */
const EXTERNAL_API_BASE = "http://192.168.0.134/jcbServiceEnginerAPIv7";
const COMPLAINT_API_URL = "http://192.168.0.134/jcbServiceEnginerAPIv7/ai_call_complaint.php";
const API_TIMEOUT = 20000;
const API_HEADERS = { JCBSERVICEAPI: "MakeInJcb" };

/* ======================= AFFIRMATIVE KEYWORDS ======================= */
const affirmativeKeywords = [
  'à¤¹à¤¾à¤¨', 'à¤¹à¤¾à¤‚', 'à¤¹à¤¾à¤', 'à¤¹à¤®', 'à¤œà¥€', 'à¤¸à¤¹à¥€', 'à¤ à¥€à¤•', 'à¤¬à¤¿à¤²à¥à¤•à¥à¤²', 'à¤ à¥€à¤• à¤¹à¥ˆ', 'à¤¸à¤¹à¥€ à¤¹à¥ˆ',
  'à¤œà¥€ à¤¹à¤¾à¤‚', 'à¤œà¥€ à¤¹à¤¾à¤', 'à¤¹à¤¾à¤‚ à¤œà¥€', 'à¤¹à¤¾à¤ à¤œà¥€', 'à¤¬à¤¿à¤²à¥à¤•à¥à¤² à¤¸à¤¹à¥€', 'à¤œà¥€ à¤¸à¤°', 'à¤œà¥€ à¤®à¥ˆà¤¡à¤®',
  'à¤…à¤šà¥à¤›à¤¾', 'à¤“à¤•à¥‡', 'à¤•à¤°à¥‹', 'à¤•à¥€à¤œà¤¿à¤', 'à¤ à¥€à¤• à¤°à¤¹à¥‡à¤—à¤¾', 'à¤šà¤²à¥‡à¤—à¤¾', 'à¤¹à¥‹ à¤—à¤¯à¤¾',
  'yes', 'yep', 'yeah', 'yup', 'sure', 'correct', 'right', 'ok', 'okay',
  'fine', 'good', 'ji', 'sahi', 'theek', 'thik', 'bilkul', 'haan', 'han',
  'absolutely', 'definitely', 'affirmative'
];

/* ======================= NEGATIVE KEYWORDS ======================= */
const negativeKeywords = [
  'à¤¨à¤¹à¥€à¤‚', 'à¤¨à¤¹à¥€', 'à¤¨à¤¾', 'à¤¨à¤¾à¤¹', 'à¤¨', 'à¤¨à¤¾à¤¯', 'à¤—à¤²à¤¤', 'à¤—à¤²à¤¤ à¤¹à¥ˆ', 'à¤à¤¸à¥€ à¤¨à¤¹à¥€à¤‚',
  'à¤¯à¥‡ à¤¨à¤¹à¥€à¤‚', 'à¤¯à¤¹ à¤¨à¤¹à¥€à¤‚', 'à¤¨à¤•à¤¾à¤°', 'à¤®à¤¤', 'à¤®à¤¤ à¤•à¤°à¥‹', 'à¤°à¤¹à¤¨à¥‡ à¤¦à¥‹', 'à¤œà¤°à¥‚à¤°à¤¤ à¤¨à¤¹à¥€à¤‚',
  'à¤ à¥€à¤• à¤¨à¤¹à¥€à¤‚', 'à¤¸à¤¹à¥€ à¤¨à¤¹à¥€à¤‚', 'à¤¬à¤¿à¤²à¥à¤•à¥à¤² à¤¨à¤¹à¥€à¤‚',
  'no', 'nope', 'nah', 'na', 'not', 'dont', "don't", 'never', 'negative',
  'wrong', 'incorrect', 'galat', 'nai', 'nei'
];

/* ======================= UNCERTAINTY KEYWORDS ======================= */
const uncertaintyKeywords = [
  'à¤ªà¤¤à¤¾ à¤¨à¤¹à¥€à¤‚', 'à¤ªà¤¤à¤¾ à¤¨à¤¹à¥€', 'à¤ªà¤¤à¤¾ à¤¨', 'à¤®à¥à¤à¥‡ à¤ªà¤¤à¤¾ à¤¨à¤¹à¥€à¤‚', 'à¤®à¥à¤à¥‡ à¤¨à¤¹à¥€à¤‚ à¤ªà¤¤à¤¾',
  'à¤ªà¤¤à¤¾ à¤¨à¤ˆà¤‚', 'à¤ªà¤¤à¤¾ à¤¨à¤ˆ', 'à¤®à¤¾à¤²à¥‚à¤® à¤¨à¤¹à¥€à¤‚', 'à¤®à¤¾à¤²à¥‚à¤® à¤¨à¤¹à¥€', 'à¤¨à¤¹à¥€à¤‚ à¤®à¤¾à¤²à¥‚à¤®',
  'à¤®à¤¾à¤²à¥‚à¤® à¤¨à¤ˆà¤‚', 'à¤œà¤¾à¤¨à¤•à¤¾à¤°à¥€ à¤¨à¤¹à¥€à¤‚',
  'à¤¯à¤¾à¤¦ à¤¨à¤¹à¥€à¤‚', 'à¤¯à¤¾à¤¦ à¤¨à¤¹à¥€', 'à¤¨à¤¹à¥€à¤‚ à¤¯à¤¾à¤¦', 'à¤¯à¤¾à¤¦ à¤¨', 'à¤¯à¤¾à¤¦ à¤¨à¤ˆà¤‚',
  'à¤­à¥‚à¤² à¤—à¤¯à¤¾', 'à¤­à¥‚à¤² à¤—à¤¯à¥€', 'à¤­à¥‚à¤² à¤—à¤', 'à¤­à¥‚à¤² à¤—à¤ˆ', 'à¤¯à¤¾à¤¦ à¤¨à¤¹à¥€à¤‚ à¤† à¤°à¤¹à¤¾',
  'à¤¸à¤®à¤ à¤¨à¤¹à¥€à¤‚', 'à¤¸à¤®à¤ à¤¨à¤¹à¥€', 'à¤¨à¤¹à¥€à¤‚ à¤¸à¤®à¤ à¤† à¤°à¤¹à¤¾', 'à¤¸à¤®à¤ à¤¨à¤¹à¥€à¤‚ à¤†à¤¯à¤¾',
  'à¤¸à¤®à¤ à¤¨à¤ˆà¤‚ à¤†à¤¯à¤¾', 'à¤¸à¤®à¤ à¤®à¥‡à¤‚ à¤¨à¤¹à¥€à¤‚ à¤†à¤¯à¤¾',
  'à¤œà¤¾à¤¨à¤¤à¤¾ à¤¨à¤¹à¥€à¤‚', 'à¤œà¤¾à¤¨à¤¤à¤¾ à¤¨à¤¹à¥€', 'à¤œà¤¾à¤¨à¤¤à¥€ à¤¨à¤¹à¥€à¤‚', 'à¤®à¥ˆà¤‚ à¤¨à¤¹à¥€à¤‚ à¤œà¤¾à¤¨à¤¤à¤¾',
  'à¤®à¥ˆà¤‚ à¤¨à¤¹à¥€à¤‚ à¤œà¤¾à¤¨à¤¤à¥€', 'à¤¹à¤®à¥‡à¤‚ à¤¨à¤¹à¥€à¤‚ à¤ªà¤¤à¤¾', 'à¤•à¥‹à¤ˆ à¤µà¤¿à¤šà¤¾à¤° à¤¨à¤¹à¥€à¤‚', 'à¤•à¥‹à¤ˆ à¤†à¤‡à¤¡à¤¿à¤¯à¤¾ à¤¨à¤¹à¥€à¤‚',
  'à¤…à¤‚à¤¦à¤¾à¤œà¤¾ à¤¨à¤¹à¥€à¤‚', 'à¤•à¥à¤²à¥‚ à¤¨à¤¹à¥€à¤‚',
  'dont know', 'do not know', "don't know", 'dunno', 'no idea', 'no clue',
  'not sure', 'uncertain', 'forget', 'forgot', 'forgotten', "can't remember",
  'cant remember', 'not certain', 'confused'
];

/* ======================= CONTROL KEYWORDS ======================= */
const repeatKeywords = [
  'repeat', 'dobara', 'fir se', 'phir se', 'kya', 'kya kaha',
  'dubara', 'again', 'once more', 'samjha nahi'
];

const pauseKeywords = [
  'ruko', 'ruk', 'ek minute', 'ek min', 'i mean', 'matlab',
  'ruk jao', 'hold', 'thoda ruk'
];

function isRepeatRequest(text) {
  if (!text) return false;
  const lower = text.toLowerCase();
  return repeatKeywords.some(k => lower.includes(k));
}

function isPauseRequest(text) {
  if (!text) return false;
  const lower = text.toLowerCase();
  return pauseKeywords.some(k => lower.includes(k));
}

/* ======================= MACHINE TYPE KEYWORDS ======================= */
const machineTypeKeywords = {
  'Warranty': [
    'à¤µà¤¾à¤°à¤‚à¤Ÿà¥€', 'warranty', 'à¤µà¤¾à¤°à¥‡à¤‚à¤Ÿà¥€', 'à¤µà¥‰à¤°à¤‚à¤Ÿà¥€', 'à¤—à¤¾à¤°à¤‚à¤Ÿà¥€', 'guarantee',
    'free', 'à¤«à¥à¤°à¥€', 'à¤®à¥à¤«à¥à¤¤', 'warranty mein', 'warranty à¤®à¥‡à¤‚'
  ],
  'JCB Care': [
    'à¤œà¥€à¤¸à¥€à¤¬à¥€ à¤•à¥‡à¤¯à¤°', 'jcb care', 'à¤•à¥‡à¤¯à¤°', 'care', 'jcb à¤•à¥‡à¤¯à¤°', 'à¤œà¥‡à¤¸à¥€à¤¬à¥€ à¤•à¥‡à¤¯à¤°',
    'annual', 'yearly', 'à¤¸à¤¾à¤²', 'à¤µà¤¾à¤°à¥à¤·à¤¿à¤•'
  ],
  'Engine Care': [
    'à¤‡à¤‚à¤œà¤¨ à¤•à¥‡à¤¯à¤°', 'engine care', 'à¤‡à¤‚à¤œà¥€à¤¨ à¤•à¥‡à¤¯à¤°', 'engine à¤•à¤¾ à¤•à¥‡à¤¯à¤°',
    'engine protection', 'à¤‡à¤‚à¤œà¤¨ à¤ªà¥à¤°à¥‹à¤Ÿà¥‡à¤•à¥à¤¶à¤¨'
  ],
  'Demo': [
    'à¤¡à¥‡à¤®à¥‹', 'demo', 'à¤¡à¥‡à¤®à¥‹ à¤®à¤¶à¥€à¤¨', 'demonstration', 'test machine',
    'à¤Ÿà¥‡à¤¸à¥à¤Ÿ', 'à¤ªà¤°à¥€à¤•à¥à¤·à¤£'
  ],
  'BHL': [
    'à¤¬à¥€à¤à¤šà¤à¤²', 'bhl', 'backhoe', 'à¤¬à¥ˆà¤•à¤¹à¥‹', 'back hoe', 'backhoe loader'
  ]
};

/* ======================= MACHINE STATUS KEYWORDS ======================= */
const machineStatusKeywords = {
  'Breakdown': [
    'à¤¬à¥à¤°à¥‡à¤•à¤¡à¤¾à¤‰à¤¨', 'breakdown', 'break down', 'à¤¬à¥à¤°à¥‡à¤• à¤¡à¤¾à¤‰à¤¨', 'à¤¬à¥à¤°à¥‡à¤•-à¤¡à¤¾à¤‰à¤¨',
    'à¤¬à¤¿à¤²à¥à¤•à¥à¤² à¤¬à¤‚à¤¦', 'à¤ªà¥‚à¤°à¥€ à¤¤à¤°à¤¹ à¤¬à¤‚à¤¦', 'completely down', 'totally down',
    'à¤¬à¤‚à¤¦ à¤¹à¥ˆ', 'à¤¬à¤‚à¤¦ à¤¹à¥‹ à¤—à¤¯à¤¾', 'à¤¬à¤‚à¤¦ à¤¹à¥‹ à¤—à¤ˆ', 'à¤¬à¤‚à¤¦ à¤ªà¤¡à¤¼à¤¾', 'à¤¬à¤‚à¤¦ à¤ªà¤¡à¤¼à¥€',
    'à¤ªà¥‚à¤°à¤¾ à¤¬à¤‚à¤¦', 'à¤¡à¤¾à¤‰à¤¨ à¤¹à¥ˆ', 'down à¤¹à¥ˆ', 'à¤ªà¥‚à¤°à¥€ à¤¤à¤°à¤¹ à¤¡à¤¾à¤‰à¤¨',
    'à¤¬à¤¿à¤²à¥à¤•à¥à¤² à¤•à¤¾à¤® à¤¨à¤¹à¥€à¤‚', 'bilkul kaam nahi', 'à¤•à¤¾à¤® à¤¹à¥€ à¤¨à¤¹à¥€à¤‚ à¤•à¤° à¤°à¤¹à¤¾',
    'à¤¬à¤¿à¤²à¥à¤•à¥à¤² à¤šà¤² à¤¨à¤¹à¥€à¤‚', 'bilkul chal nahi', 'à¤šà¤² à¤¹à¥€ à¤¨à¤¹à¥€à¤‚ à¤°à¤¹à¤¾',
    'à¤¶à¥à¤°à¥‚ à¤¨à¤¹à¥€à¤‚ à¤¹à¥‹ à¤°à¤¹à¤¾', 'à¤¸à¥à¤Ÿà¤¾à¤°à¥à¤Ÿ à¤¨à¤¹à¥€à¤‚ à¤¹à¥‹ à¤°à¤¹à¤¾', 'à¤šà¤¾à¤²à¥‚ à¤¨à¤¹à¥€à¤‚ à¤¹à¥‹ à¤°à¤¹à¤¾',
    'start nahi ho raha', 'chalu nahi ho raha',
    'à¤–à¤°à¤¾à¤¬ à¤¹à¥‹ à¤—à¤¯à¤¾', 'à¤–à¤°à¤¾à¤¬ à¤¹à¥‹ à¤—à¤ˆ', 'à¤ à¤ªà¥à¤ª à¤¹à¥ˆ', 'à¤ à¤ªà¥à¤ª à¤¹à¥‹ à¤—à¤¯à¤¾',
    'à¤®à¤° à¤—à¤¯à¤¾', 'à¤¡à¥‡à¤¡', 'dead', 'stopped completely',
    'à¤•à¤¾à¤® à¤¨à¤¹à¥€à¤‚ à¤•à¤°à¤¤à¤¾', 'à¤•à¤¾à¤® à¤¨à¤¹à¥€à¤‚ à¤•à¤°à¤¤à¥€', 'work nahi karta'
  ],
  'Running With Problem': [
    'à¤šà¤² à¤°à¤¹à¤¾ à¤¹à¥ˆ à¤²à¥‡à¤•à¤¿à¤¨', 'à¤šà¤² à¤°à¤¹à¥€ à¤¹à¥ˆ à¤²à¥‡à¤•à¤¿à¤¨', 'chal raha hai lekin',
    'à¤šà¤² à¤°à¤¹à¤¾ à¤¹à¥ˆ à¤ªà¤°', 'à¤šà¤² à¤°à¤¹à¥€ à¤¹à¥ˆ à¤ªà¤°', 'à¤šà¤² à¤¤à¥‹ à¤°à¤¹à¤¾ à¤¹à¥ˆ',
    'à¤•à¤¾à¤® à¤•à¤° à¤°à¤¹à¤¾ à¤¹à¥ˆ à¤²à¥‡à¤•à¤¿à¤¨', 'à¤•à¤¾à¤® à¤¤à¥‹ à¤•à¤° à¤°à¤¹à¤¾ à¤¹à¥ˆ',
    'à¤¸à¤®à¤¸à¥à¤¯à¤¾ à¤•à¥‡ à¤¸à¤¾à¤¥ à¤šà¤²', 'problem à¤•à¥‡ à¤¸à¤¾à¤¥ à¤šà¤²', 'à¤¦à¤¿à¤•à¥à¤•à¤¤ à¤•à¥‡ à¤¸à¤¾à¤¥ à¤šà¤²',
    'running with problem', 'working with issue', 'working but',
    'à¤†à¤‚à¤¶à¤¿à¤• à¤°à¥‚à¤ª à¤¸à¥‡', 'partially working', 'à¤¥à¥‹à¤¡à¤¼à¤¾ à¤•à¤¾à¤® à¤•à¤°',
    'à¤•à¤® à¤¸à¥‡ à¤•à¤® à¤•à¤¾à¤® à¤•à¤°', 'à¤ à¥€à¤• à¤¸à¥‡ à¤•à¤¾à¤® à¤¨à¤¹à¥€à¤‚ à¤²à¥‡à¤•à¤¿à¤¨ à¤šà¤²',
    'à¤ªà¥à¤°à¥‰à¤¬à¥à¤²à¤® à¤¹à¥ˆ à¤ªà¤° à¤šà¤²', 'issue à¤¹à¥ˆ but running', 'à¤¦à¤¿à¤•à¥à¤•à¤¤ à¤¹à¥ˆ à¤²à¥‡à¤•à¤¿à¤¨ on'
  ]
};

/* ======================= JOB LOCATION KEYWORDS ======================= */
const jobLocationKeywords = {
  'Workshop': [
    'à¤µà¤°à¥à¤•à¤¶à¥‰à¤ª', 'workshop', 'à¤µà¤°à¥à¤•à¤¶à¤¾à¤ª', 'work shop', 'à¤µà¤°à¥à¤• à¤¶à¥‰à¤ª',
    'à¤¶à¥‰à¤ª', 'shop', 'à¤¦à¥à¤•à¤¾à¤¨', 'à¤—à¥ˆà¤°à¥‡à¤œ', 'garage', 'à¤—à¤°à¤¾à¤œ',
    'à¤µà¤°à¥à¤•à¤¶à¥‰à¤ª à¤®à¥‡à¤‚', 'workshop à¤®à¥‡à¤‚', 'workshop mein', 'shop à¤®à¥‡à¤‚',
    'à¤¶à¥‰à¤ª à¤®à¥‡à¤‚', 'à¤—à¥ˆà¤°à¥‡à¤œ à¤®à¥‡à¤‚', 'à¤—à¤°à¤¾à¤œ à¤®à¥‡à¤‚',
    'à¤˜à¤° à¤ªà¤°', 'à¤˜à¤°', 'à¤˜à¤° à¤®à¥‡à¤‚', 'home', 'à¤¹à¥‹à¤®', 'à¤…à¤‚à¤¦à¤°', 'indoor',
    'à¤—à¥‹à¤¦à¤¾à¤®', 'à¤¶à¥‡à¤¡', 'shed', 'warehouse',
    'service center', 'à¤¸à¤°à¥à¤µà¤¿à¤¸ à¤¸à¥‡à¤‚à¤Ÿà¤°', 'repair shop',
    'à¤°à¤¿à¤ªà¥‡à¤¯à¤° à¤¶à¥‰à¤ª', 'à¤®à¤°à¤®à¥à¤®à¤¤ à¤•à¥€ à¤¦à¥à¤•à¤¾à¤¨'
  ],
  'Onsite': [
    'à¤¸à¤¾à¤‡à¤Ÿ', 'site', 'à¤¸à¤¾à¤‡à¤Ÿ à¤ªà¤°', 'à¤¸à¤¾à¤ˆà¤Ÿ', 'à¤¸à¤¾à¤ˆà¤Ÿ à¤ªà¤°', 'site à¤ªà¤°',
    'à¤–à¥‡à¤¤', 'à¤–à¥‡à¤¤ à¤®à¥‡à¤‚', 'field', 'à¤«à¥€à¤²à¥à¤¡', 'à¤®à¥ˆà¤¦à¤¾à¤¨',
    'à¤œà¤—à¤¹', 'à¤œà¤—à¤¹ à¤ªà¤°', 'à¤¬à¤¾à¤¹à¤°', 'outdoor',
    'à¤•à¤¾à¤® à¤•à¥€ à¤œà¤—à¤¹', 'work site', 'à¤µà¤°à¥à¤• à¤¸à¤¾à¤‡à¤Ÿ', 'location', 'à¤²à¥‹à¤•à¥‡à¤¶à¤¨',
    'à¤œà¤¹à¤¾à¤‚ à¤•à¤¾à¤® à¤¹à¥‹ à¤°à¤¹à¤¾', 'construction', 'à¤•à¤‚à¤¸à¥à¤Ÿà¥à¤°à¤•à¥à¤¶à¤¨',
    'à¤¨à¤¿à¤°à¥à¤®à¤¾à¤£', 'project', 'à¤ªà¥à¤°à¥‹à¤œà¥‡à¤•à¥à¤Ÿ',
    'road', 'à¤°à¥‹à¤¡', 'à¤¸à¤¡à¤¼à¤•', 'highway', 'à¤¹à¤¾à¤ˆà¤µà¥‡'
  ]
};

/* ======================= COMPREHENSIVE COMPLAINT MAP ======================= */
const complaintMap = {
  "AC System": {
    keywords: [
      "ac", "a.c", "a c", "air conditioner", "air conditioning", "cooling",
      "cooler", "climate", "temperature control",
      "à¤à¤¸à¥€", "à¤à¤¸à¥€", "à¤à¤•à¤¸à¥€", "à¤ à¤¸à¥€", "à¤.à¤¸à¥€", "à¤à¤¯à¤° à¤•à¤‚à¤¡à¥€à¤¶à¤¨à¤°",
      "à¤ à¤‚à¤¡à¤¾", "à¤ à¤‚à¤¡à¥€", "à¤•à¥‚à¤²à¤¿à¤‚à¤—", "à¤•à¥‚à¤²", "à¤ à¤‚à¤¡", "à¤à¤¯à¤° à¤•à¤‚à¤¡à¥€à¤¶à¤¨à¤¿à¤‚à¤—"
    ],
    priority: 10,
    subTitles: {
      "AC not Working": [
        "à¤¨à¤¹à¥€à¤‚ à¤šà¤²", "à¤¨à¤ˆ à¤šà¤²", "band", "à¤¬à¤‚à¤¦", "à¤•à¤¾à¤® à¤¨à¤¹à¥€à¤‚", "work à¤¨à¤¹à¥€à¤‚",
        "à¤šà¤¾à¤²à¥‚ à¤¨à¤¹à¥€à¤‚", "start à¤¨à¤¹à¥€à¤‚", "on à¤¨à¤¹à¥€à¤‚", "à¤¨à¤¹à¥€à¤‚ à¤¹à¥‹ à¤°à¤¹à¤¾",
        "not working", "stopped", "dead", "à¤–à¤°à¤¾à¤¬", "not turning on",
        "AC à¤¬à¤‚à¤¦", "AC à¤•à¤¾à¤® à¤¨à¤¹à¥€à¤‚", "AC à¤–à¤°à¤¾à¤¬"
      ],
      "AC not Cooling": [
        "cooling", "à¤ à¤‚à¤¡à¤¾ à¤¨à¤¹à¥€à¤‚", "à¤ à¤‚à¤¡à¥€ à¤¨à¤¹à¥€à¤‚", "à¤•à¥‚à¤²à¤¿à¤‚à¤— à¤¨à¤¹à¥€à¤‚", "cool à¤¨à¤¹à¥€à¤‚",
        "à¤—à¤°à¤®", "à¤—à¤°à¥à¤®", "heat", "hot", "à¤ à¤‚à¤¡ à¤¨à¤¹à¥€à¤‚", "thanda nahi",
        "à¤šà¤¾à¤²à¥‚ à¤¹à¥ˆ à¤²à¥‡à¤•à¤¿à¤¨", "on hai lekin", "chal rahi lekin",
        "à¤ à¤‚à¤¡à¤¾ à¤¨à¤¹à¥€à¤‚ à¤•à¤° à¤°à¤¹à¤¾", "cooling à¤¨à¤¹à¥€à¤‚ à¤¦à¥‡ à¤°à¤¹à¤¾", "à¤¹à¤µà¤¾ à¤—à¤°à¤®",
        "not cooling", "warm air", "no cooling", "à¤—à¤°à¤® à¤¹à¤µà¤¾",
        "à¤ à¤‚à¤¡à¤• à¤¨à¤¹à¥€à¤‚", "AC à¤šà¤² à¤°à¤¹à¤¾ à¤¹à¥ˆ à¤ªà¤° à¤ à¤‚à¤¡à¤¾ à¤¨à¤¹à¥€à¤‚"
      ]
    }
  },

  "Brake": {
    keywords: [
      "brake", "à¤¬à¥à¤°à¥‡à¤•", "braking", "stop", "à¤°à¥‹à¤•", "à¤°à¥à¤•à¤¨à¤¾",
      "brake fail", "brake problem", "brake issue", "à¤¬à¥à¤°à¥‡à¤• à¤¸à¤®à¤¸à¥à¤¯à¤¾"
    ],
    priority: 9,
    subTitles: {
      "Brake Not Working": [
        "brake à¤¨à¤¹à¥€à¤‚ à¤²à¤— à¤°à¤¹à¤¾", "brake à¤•à¤¾à¤® à¤¨à¤¹à¥€à¤‚ à¤•à¤° à¤°à¤¹à¤¾", "brake fail",
        "à¤¬à¥à¤°à¥‡à¤• à¤¨à¤¹à¥€à¤‚ à¤²à¤—", "à¤¬à¥à¤°à¥‡à¤• à¤«à¥‡à¤²", "brake failure", "brake dead",
        "à¤¨à¤¹à¥€à¤‚ à¤°à¥à¤• à¤°à¤¹à¤¾", "à¤°à¥à¤• à¤¨à¤¹à¥€à¤‚ à¤°à¤¹à¤¾", "stop à¤¨à¤¹à¥€à¤‚"
      ],
      "Weak Braking": [
        "brake à¤•à¤®à¤œà¥‹à¤°", "weak braking", "brake soft", "brake loose",
        "à¤¬à¥à¤°à¥‡à¤• à¤•à¤®à¤œà¥‹à¤°", "brake pressure à¤•à¤®", "pressure down"
      ]
    }
  },

  "Engine": {
    keywords: [
      "engine", "motor", "smoke", "overheat", "heat", "power",
      "starting", "noise", "sound",
      "à¤‡à¤‚à¤œà¤¨", "à¤‡à¤‚à¤¡à¤¿à¤¯à¤¨", "à¤®à¥‹à¤Ÿà¤°", "à¤§à¥à¤†", "à¤§à¥à¤‚à¤†", "à¤—à¤°à¤®", "à¤—à¤°à¥à¤®",
      "à¤ªà¤¾à¤µà¤°", "à¤¶à¤•à¥à¤¤à¤¿", "à¤¤à¤¾à¤•à¤¤", "à¤†à¤µà¤¾à¤œ", "à¤¶à¥‹à¤°"
    ],
    priority: 9,
    subTitles: {
      "Starting trouble": [
        "start", "à¤¸à¥à¤Ÿà¤¾à¤°à¥à¤Ÿ", "à¤¶à¥à¤°à¥‚", "chalu nahi", "à¤šà¤¾à¤²à¥‚ à¤¨à¤¹à¥€à¤‚",
        "self", "à¤¸à¥‡à¤²à¥à¤«", "starter", "à¤¸à¥à¤Ÿà¤¾à¤°à¥à¤Ÿà¤°", "kick",
        "start problem", "start à¤¨à¤¹à¥€à¤‚", "à¤¶à¥à¤°à¥‚ à¤¨à¤¹à¥€à¤‚", "starting",
        "à¤¸à¥à¤Ÿà¤¾à¤°à¥à¤Ÿà¤¿à¤‚à¤—", "dikkat", "à¤¦à¤¿à¤•à¥à¤•à¤¤", "hone mein", "à¤¹à¥‹à¤¨à¥‡ à¤®à¥‡à¤‚",
        "shuru hone", "à¤¨à¤¹à¥€à¤‚ à¤¹à¥‹ à¤°à¤¹à¤¾", "not starting", "won't start",
        "starting issue", "start à¤¨à¤¹à¥€à¤‚ à¤¹à¥‹ à¤°à¤¹à¤¾", "engine start à¤¨à¤¹à¥€à¤‚"
      ],
      "Engine Over heating": [
        "overheat", "over heat", "à¤—à¤°à¤®", "à¤—à¤°à¥à¤®", "heat", "à¤—à¤°à¥à¤®à¥€",
        "hot", "à¤—à¤°à¤®à¥€", "à¤¤à¤¾à¤ªà¤®à¤¾à¤¨", "temperature", "hit", "à¤¹à¤¿à¤Ÿ",
        "à¤—à¤°à¥à¤® à¤¹à¥‹", "garam ho", "overheat ho", "à¤œà¥à¤¯à¤¾à¤¦à¤¾ à¤—à¤°à¤®",
        "à¤¬à¤¹à¥à¤¤ à¤—à¤°à¤®", "overheating", "heating problem"
      ],
      "Smoke problem": [
        "smoke", "à¤§à¥à¤†", "à¤§à¥à¤‚à¤†", "dhuan", "à¤•à¤¾à¤²à¤¾ à¤§à¥à¤†", "black smoke",
        "white smoke", "à¤¸à¤«à¥‡à¤¦ à¤§à¥à¤†", "blue smoke", "à¤¨à¥€à¤²à¤¾ à¤§à¥à¤†",
        "smoke à¤† à¤°à¤¹à¤¾", "smoke à¤¨à¤¿à¤•à¤² à¤°à¤¹à¤¾"
      ],
      "Abnormal Noise": [
        "noise", "sound", "à¤†à¤µà¤¾à¤œ", "à¤¶à¥‹à¤°", "awaaz", "à¤–à¤¡à¤¼à¤–à¤¡à¤¼",
        "à¤†à¤µà¤¾à¤œ à¤†", "sound aa", "strange sound", "weird noise",
        "à¤…à¤¸à¤¾à¤®à¤¾à¤¨à¥à¤¯ à¤†à¤µà¤¾à¤œ", "à¤–à¤Ÿà¤–à¤Ÿ", "à¤˜à¤°à¥à¤°", "à¤˜à¤°à¤˜à¤°"
      ]
    }
  },

  "Hydraulic": {
    keywords: [
      "hydraulic", "pressure", "pump", "oil", "flow", "valve",
      "cylinder", "slow", "weak",
      "à¤¹à¤¾à¤‡à¤¡à¥à¤°à¥‹à¤²à¤¿à¤•", "à¤ªà¥à¤°à¥‡à¤¶à¤°", "à¤¦à¤¬à¤¾à¤µ", "à¤ªà¤‚à¤ª", "à¤¤à¥‡à¤²", "à¤§à¥€à¤®à¤¾",
      "à¤•à¤®à¤œà¥‹à¤°", "à¤¸à¥à¤²à¥‹"
    ],
    priority: 8,
    subTitles: {
      "Pressure down": [
        "pressure", "à¤ªà¥à¤°à¥‡à¤¶à¤°", "à¤•à¤®", "low pressure", "à¤¦à¤¬à¤¾à¤µ à¤•à¤®",
        "pressure down", "à¤ªà¥à¤°à¥‡à¤¶à¤° à¤¡à¤¾à¤‰à¤¨", "pressure à¤¨à¤¹à¥€à¤‚",
        "à¤ªà¥à¤°à¥‡à¤¶à¤° à¤•à¤®", "pressure fall", "à¤¦à¤¬à¤¾à¤µ à¤•à¤® à¤¹à¥‹ à¤—à¤¯à¤¾"
      ],
      "Slow working": [
        "slow", "à¤§à¥€à¤°à¥‡", "à¤§à¥€à¤®à¤¾", "à¤•à¤® speed", "power kam", "à¤ªà¤¾à¤µà¤° à¤•à¤®",
        "performance low", "weak", "à¤•à¤®à¤œà¥‹à¤°", "sluggish", "à¤¸à¥à¤²à¥‹ à¤µà¤°à¥à¤•à¤¿à¤‚à¤—",
        "à¤•à¤¾à¤® à¤§à¥€à¤®à¤¾", "speed à¤•à¤®", "à¤•à¤¾à¤® à¤§à¥€à¤°à¥‡ à¤šà¤² à¤°à¤¹à¤¾"
      ],
      "Hydraulic pump leak": [
        "pump leak", "à¤ªà¤‚à¤ª à¤²à¥€à¤•", "pump à¤¸à¥‡ leak", "hydraulic leak",
        "à¤¤à¥‡à¤² à¤²à¥€à¤•", "oil leak", "à¤¹à¤¾à¤‡à¤¡à¥à¤°à¥‹à¤²à¤¿à¤• à¤²à¥€à¤•à¥‡à¤œ"
      ]
    }
  },

  "Electrical Complaint": {
    keywords: [
      "electrical", "electric", "battery", "light", "wiring", "wire",
      "starter", "alternator", "fuse", "relay", "switch",
      "à¤¬à¤¿à¤œà¤²à¥€", "à¤¬à¥ˆà¤Ÿà¤°à¥€", "à¤²à¤¾à¤‡à¤Ÿ", "à¤µà¤¾à¤¯à¤°à¤¿à¤‚à¤—", "à¤¤à¤¾à¤°", "self", "à¤¸à¥‡à¤²à¥à¤«",
      "à¤¸à¥à¤Ÿà¤¾à¤°à¥à¤Ÿà¤°", "à¤‡à¤²à¥‡à¤•à¥à¤Ÿà¥à¤°à¤¿à¤•à¤²", "à¤¬à¤¤à¥à¤¤à¥€"
    ],
    priority: 8,
    subTitles: {
      "Starting trouble": [
        "start problem", "start à¤¨à¤¹à¥€à¤‚ à¤¹à¥‹ à¤°à¤¹à¥€", "à¤¸à¥à¤Ÿà¤¾à¤°à¥à¤Ÿ à¤¦à¤¿à¤•à¥à¤•à¤¤",
        "à¤¸à¥à¤Ÿà¤¾à¤°à¥à¤Ÿ à¤¨à¤¹à¥€à¤‚ à¤¹à¥‹ à¤°à¤¹à¥€", "à¤¸à¥à¤Ÿà¤¾à¤°à¥à¤Ÿ à¤Ÿà¥à¤°à¤¬à¤²", "à¤¸à¥à¤Ÿà¤¾à¤°à¥à¤Ÿ",
        "self problem", "à¤¸à¥‡à¤²à¥à¤« à¤ªà¥à¤°à¥‰à¤¬à¥à¤²à¤®", "à¤¸à¥‡à¤²à¥à¤« à¤¨à¤¹à¥€à¤‚",
        "chalu nahi ho rahi", "starting issue", "starting trouble",
        "à¤¶à¥à¤°à¥‚ à¤¨à¤¹à¥€à¤‚", "à¤¶à¥à¤°à¥‚ à¤¨à¤¹à¥€à¤‚ à¤¹à¥‹ à¤°à¤¹à¤¾", "start à¤¨à¤¹à¥€à¤‚", "à¤¨à¤¹à¥€à¤‚ à¤šà¤¾à¤²à¥‚ à¤¹à¥‹ à¤°à¤¹à¤¾",
        "not starting", "won't start", "starting problem"
      ],
      "Battery problem": [
        "battery", "à¤¬à¥ˆà¤Ÿà¤°à¥€", "dead", "à¤–à¤¤à¥à¤®", "discharge", "à¤¡à¤¿à¤¸à¥à¤šà¤¾à¤°à¥à¤œ",
        "charge nahi", "à¤šà¤¾à¤°à¥à¤œ à¤¨à¤¹à¥€à¤‚", "battery down", "battery low",
        "à¤¬à¥ˆà¤Ÿà¤°à¥€ à¤–à¤°à¤¾à¤¬", "à¤¬à¥ˆà¤Ÿà¤°à¥€ à¤¡à¤¾à¤‰à¤¨", "à¤¬à¥ˆà¤Ÿà¤°à¥€ à¤•à¤®"
      ],
      "Light not working": [
        "light", "à¤²à¤¾à¤‡à¤Ÿ", "light problem", "à¤¬à¤¤à¥à¤¤à¥€", "light not on",
        "light à¤¨à¤¹à¥€à¤‚ à¤œà¤² à¤°à¤¹à¥€", "à¤²à¤¾à¤‡à¤Ÿ à¤¨à¤¹à¥€à¤‚ à¤œà¤² à¤°à¤¹à¥€"
      ]
    }
  },

  "Tyre/Battery": {
    keywords: [
      "tyre", "tire", "battery", "puncture", "à¤Ÿà¤¾à¤¯à¤°", "à¤¬à¥ˆà¤Ÿà¤°à¥€",
      "à¤ªà¤‚à¤•à¥à¤šà¤°", "wheel", "à¤ªà¤¹à¤¿à¤¯à¤¾"
    ],
    priority: 7,
    subTitles: {
      "Battery problem": [
        "battery", "à¤¬à¥ˆà¤Ÿà¤°à¥€", "dead battery", "à¤¬à¥ˆà¤Ÿà¤°à¥€ à¤–à¤°à¤¾à¤¬",
        "à¤¬à¥ˆà¤Ÿà¤°à¥€ à¤¡à¤¾à¤‰à¤¨", "battery issue"
      ],
      "Tube puncture": [
        "tube puncture", "à¤Ÿà¥à¤¯à¥‚à¤¬ à¤ªà¤‚à¤•à¥à¤šà¤°", "tube à¤«à¥‚à¤Ÿà¤¾", "puncture",
        "à¤ªà¤‚à¤•à¥à¤šà¤°", "puncture à¤¦à¥‡ à¤¦à¤¿à¤¯à¤¾"
      ],
      "Tyre cut": [
        "tyre cut", "tire cut", "à¤Ÿà¤¾à¤¯à¤° à¤•à¤Ÿà¤¾", "tyre damage",
        "à¤Ÿà¤¾à¤¯à¤° à¤–à¤°à¤¾à¤¬", "tyre à¤Ÿà¥‚à¤Ÿà¤¾"
      ]
    }
  },

  "Transmission/Axle components": {
    keywords: [
      "transmission", "gear", "brake", "axle", "à¤Ÿà¥à¤°à¤¾à¤‚à¤¸à¤®à¤¿à¤¶à¤¨",
      "à¤—à¤¿à¤¯à¤°", "à¤¬à¥à¤°à¥‡à¤•", "clutch", "à¤•à¥à¤²à¤š"
    ],
    priority: 7,
    subTitles: {
      "Abnormal sound": [
        "sound", "noise", "à¤†à¤µà¤¾à¤œ", "à¤¶à¥‹à¤°", "transmission noise",
        "gear noise", "transmission à¤†à¤µà¤¾à¤œ"
      ],
      "Brake problem": [
        "brake", "à¤¬à¥à¤°à¥‡à¤•", "braking", "à¤¬à¥à¤°à¥‡à¤• à¤¨à¤¹à¥€à¤‚", "brake issue",
        "brake à¤¨à¤¹à¥€à¤‚ à¤²à¤— à¤°à¤¹à¤¾"
      ],
      "Gear problem": [
        "gear", "à¤—à¤¿à¤¯à¤°", "gear problem", "gear issue", "à¤—à¤¿à¤¯à¤° à¤¸à¤®à¤¸à¥à¤¯à¤¾",
        "gear hard", "gear à¤¸à¤–à¥à¤¤"
      ]
    }
  },

  "Cabin": {
    keywords: [
      "cabin", "cab", "door", "glass", "seat", "à¤•à¥‡à¤¬à¤¿à¤¨", "à¤¸à¥€à¤Ÿ",
      "à¤¦à¤°à¤µà¤¾à¤œà¤¾", "à¤¶à¥€à¤¶à¤¾", "window"
    ],
    priority: 5,
    subTitles: {
      "Cab Door Fault": [
        "door", "à¤¦à¤°à¤µà¤¾à¤œà¤¾", "door problem", "door issue",
        "door à¤–à¤°à¤¾à¤¬", "door à¤¨à¤¹à¥€à¤‚ à¤–à¥à¤² à¤°à¤¹à¤¾"
      ],
      "Cabin glass cracked": [
        "glass crack", "à¤¶à¥€à¤¶à¤¾ à¤Ÿà¥‚à¤Ÿà¤¾", "glass broken", "window crack",
        "à¤¶à¥€à¤¶à¤¾ à¤Ÿà¥‚à¤Ÿà¤¾"
      ],
      "Operator Seat problems": [
        "seat", "à¤¸à¥€à¤Ÿ", "seat problem", "sitting", "à¤¸à¥€à¤Ÿ à¤–à¤°à¤¾à¤¬"
      ]
    }
  },

  "Fabrication part": {
    keywords: [
      "fabrication", "crack", "boom", "bucket", "chassis",
      "à¤«à¥ˆà¤¬à¥à¤°à¤¿à¤•à¥‡à¤¶à¤¨", "à¤•à¥à¤°à¥ˆà¤•", "crack", "broken", "à¤Ÿà¥‚à¤Ÿà¤¾", "à¤«à¤Ÿà¤¾"
    ],
    priority: 5,
    subTitles: {
      "Boom cracked": [
        "boom crack", "boom à¤«à¤Ÿà¥€", "boom broken", "boom à¤Ÿà¥‚à¤Ÿà¤¾",
        "boom à¤®à¥‡à¤‚ à¤•à¥à¤°à¥ˆà¤•"
      ],
      "Bucket cracked": [
        "bucket crack", "bucket à¤«à¤Ÿà¥€", "bucket broken",
        "bucket à¤Ÿà¥‚à¤Ÿà¤¾"
      ],
      "Chassis cracked": [
        "chassis crack", "chassis à¤«à¤Ÿà¥€", "chassis broken"
      ]
    }
  },

  "Service": {
    keywords: [
      "service", "servicing", "maintenance", "à¤¸à¤°à¥à¤µà¤¿à¤¸", "à¤¸à¤°à¥à¤µà¤¿à¤¸à¤¿à¤‚à¤—",
      "à¤®à¥‡à¤‚à¤Ÿà¥‡à¤¨à¥‡à¤‚à¤¸", "checking", "à¤šà¥‡à¤•à¤¿à¤‚à¤—"
    ],
    priority: 3,
    subTitles: {
      "Regular Service": [
        "regular service", "normal service", "general service"
      ],
      "Maintenance": ["maintenance", "à¤®à¥‡à¤‚à¤Ÿà¥‡à¤¨à¥‡à¤‚à¤¸"]
    }
  },

  "General Problem": {
    keywords: ["problem", "issue", "problem", "à¤¸à¤®à¤¸à¥à¤¯à¤¾", "à¤¦à¤¿à¤•à¥à¤•à¤¤"],
    priority: 1,
    subTitles: {
      "Other": ["other", "à¤•à¥à¤› à¤”à¤°", "something else"]
    }
  }
};

/* ======================= BRANCH, OUTLET & CITY CODE MAPPING ======================= */
const cityToBranchMap = {
  'ajmer': { branch: "AJMER", outlet: "AJMER", cityCode: "1" },
  'à¤…à¤œà¤®à¥‡à¤°': { branch: "AJMER", outlet: "AJMER", cityCode: "1" },
  'kekri': { branch: "AJMER", outlet: "KEKRI", cityCode: "1" },
  'à¤•à¥‡à¤•à¤¡à¤¼à¥€': { branch: "AJMER", outlet: "KEKRI", cityCode: "1" },

  'alwar': { branch: "ALWAR", outlet: "ALWAR", cityCode: "2" },
  'à¤…à¤²à¤µà¤°': { branch: "ALWAR", outlet: "ALWAR", cityCode: "2" },
  'bharatpur': { branch: "ALWAR", outlet: "BHARATPUR", cityCode: "2" },
  'à¤­à¤°à¤¤à¤ªà¥à¤°': { branch: "ALWAR", outlet: "BHARATPUR", cityCode: "2" },
  'bhiwadi': { branch: "ALWAR", outlet: "BHIWADI", cityCode: "2" },
  'à¤­à¤¿à¤µà¤¾à¤¡à¤¼à¥€': { branch: "ALWAR", outlet: "BHIWADI", cityCode: "2" },

  'bhilwara': { branch: "BHILWARA", outlet: "BHILWARA", cityCode: "3" },
  'à¤­à¥€à¤²à¤µà¤¾à¤¡à¤¼à¤¾': { branch: "BHILWARA", outlet: "BHILWARA", cityCode: "3" },
  'nimbahera': { branch: "BHILWARA", outlet: "NIMBAHERA", cityCode: "3" },
  'à¤¨à¤¿à¤®à¥à¤¬à¤¾à¤¹à¥‡à¤¡à¤¼à¤¾': { branch: "BHILWARA", outlet: "NIMBAHERA", cityCode: "3" },

  'jaipur': { branch: "JAIPUR", outlet: "JAIPUR", cityCode: "4" },
  'à¤œà¤¯à¤ªà¥à¤°': { branch: "JAIPUR", outlet: "JAIPUR", cityCode: "4" },
  'dausa': { branch: "JAIPUR", outlet: "DAUSA", cityCode: "4" },
  'à¤¦à¥Œà¤¸à¤¾': { branch: "JAIPUR", outlet: "DAUSA", cityCode: "4" },
  'karauli': { branch: "JAIPUR", outlet: "KARAULI", cityCode: "4" },
  'à¤•à¤°à¥Œà¤²à¥€': { branch: "JAIPUR", outlet: "KARAULI", cityCode: "4" },
  'tonk': { branch: "JAIPUR", outlet: "TONK", cityCode: "4" },
  'à¤Ÿà¥‹à¤‚à¤•': { branch: "JAIPUR", outlet: "TONK", cityCode: "4" },

  'kota': { branch: "KOTA", outlet: "KOTA", cityCode: "5" },
  'à¤•à¥‹à¤Ÿà¤¾': { branch: "KOTA", outlet: "KOTA", cityCode: "5" },
  'jhalawar': { branch: "KOTA", outlet: "JHALAWAR", cityCode: "5" },
  'à¤à¤¾à¤²à¤¾à¤µà¤¾à¤¡à¤¼': { branch: "KOTA", outlet: "JHALAWAR", cityCode: "5" },

  'sikar': { branch: "SIKAR", outlet: "SIKAR", cityCode: "6" },
  'à¤¸à¥€à¤•à¤°': { branch: "SIKAR", outlet: "SIKAR", cityCode: "6" },
  'sujangarh': { branch: "SIKAR", outlet: "SUJANGARH", cityCode: "6" },
  'à¤¸à¥à¤œà¤¾à¤¨à¤—à¤¢à¤¼': { branch: "SIKAR", outlet: "SUJANGARH", cityCode: "6" },
  'jhunjhunu': { branch: "SIKAR", outlet: "JHUNJHUNU", cityCode: "6" },
  'à¤à¥à¤‚à¤à¥à¤¨à¥‚': { branch: "SIKAR", outlet: "JHUNJHUNU", cityCode: "6" },

  'udaipur': { branch: "UDAIPUR", outlet: "UDAIPUR", cityCode: "7" },
  'à¤‰à¤¦à¤¯à¤ªà¥à¤°': { branch: "UDAIPUR", outlet: "UDAIPUR", cityCode: "7" },
  'banswara': { branch: "UDAIPUR", outlet: "BANSWARA", cityCode: "7" },
  'à¤¬à¤¾à¤‚à¤¸à¤µà¤¾à¤¡à¤¼à¤¾': { branch: "UDAIPUR", outlet: "BANSWARA", cityCode: "7" },
  'dungarpur': { branch: "UDAIPUR", outlet: "DUNGARPUR", cityCode: "7" },
  'à¤¡à¥‚à¤‚à¤—à¤°à¤ªà¥à¤°': { branch: "UDAIPUR", outlet: "DUNGARPUR", cityCode: "7" },
};

/* ======================= HELPER: Convert phone to spoken digits ======================= */
function phoneToSpokenDigits(phone) {
  if (!phone) return "";
  
  const digitMap = {
    '0': 'zero', '1': 'ek', '2': 'do', '3': 'teen', '4': 'char',
    '5': 'paanch', '6': 'chhe', '7': 'saat', '8': 'aath', '9': 'nau'
  };
  
  return phone.split('').map(d => digitMap[d] || d).join(', ');
}

/* ===========================
   VALIDATION FUNCTIONS
=========================== */

function rejectInvalid(text) {
  if (!text) return true;
  if (text.trim().length < 2) return true;
  if (isUncertain(text)) return true;
  if (isRepeatRequest(text)) return true;
  if (isPauseRequest(text)) return true;
  return false;
}

function isUncertain(text) {
  if (!text) return false;
  const textLower = text.toLowerCase();
  return uncertaintyKeywords.some(keyword =>
    new RegExp(`\\b${keyword}\\b`, 'i').test(textLower)
  );
}

function isAffirmative(text) {
  if (!text) return false;
  const textLower = text.toLowerCase().trim();

  const simpleChecks = ['à¤¹à¤¾à¤‚', 'à¤¹à¤¾à¤', 'à¤¹à¤¾à¤¨', 'à¤¸à¤¹à¥€', 'à¤ à¥€à¤•', 'à¤œà¥€', 'yes', 'ok', 'à¤¬à¤¿à¤²à¥à¤•à¥à¤²'];
  for (const check of simpleChecks) {
    if (textLower.includes(check)) {
      console.log(`âœ… Affirmative detected: "${check}"`);
      return true;
    }
  }

  const found = affirmativeKeywords.some(keyword => {
    const keywordLower = keyword.toLowerCase();
    return textLower.includes(keywordLower);
  });

  if (found) {
    console.log(`âœ… Affirmative detected`);
  }

  return found;
}

function isNegative(text) {
  if (!text) return false;
  const textLower = text.toLowerCase().trim();

  const simpleChecks = ['à¤¨à¤¹à¥€à¤‚', 'à¤¨à¤¹à¥€', 'à¤¨à¤¾', 'à¤—à¤²à¤¤', 'no', 'à¤¨à¤¾à¤¹'];
  for (const check of simpleChecks) {
    if (textLower.includes(check)) {
      console.log(`âŒ Negative detected: "${check}"`);
      return true;
    }
  }

  const found = negativeKeywords.some(keyword => {
    const keywordLower = keyword.toLowerCase();
    return textLower.includes(keywordLower);
  });

  if (found) {
    console.log(`âŒ Negative detected`);
  }

  return found;
}

function getSubComplaintQuestion(complaintType) {
  const questions = {
    "AC System": "AC mein exactly kya problem hai? Bilkul chal nahi raha hai, ya chal raha hai lekin thanda nahi kar raha?",
    "Engine": "Engine mein kya dikkat hai? Start nahi ho raha, ya overheat ho raha hai, ya dhuan aa raha hai, ya noise aa rahi hai?",
    "Brake": "Brake mein kya problem hai? Bilkul nahi lag raha, ya weak hai?",
    "Electrical Complaint": "Electrical mein kya problem hai? Start nahi ho raha, ya battery ki problem hai, ya light ki dikkat?",
    "Hydraulic": "Hydraulic mein kya problem hai? Pressure kam hai, ya slow kaam kar rahi hai, ya leak ho raha?",
    "Tyre/Battery": "Tyre ya battery mein kya problem hai? Battery dead hai, ya tyre puncture hai, ya tyre cut hai?",
    "Transmission/Axle components": "Transmission mein kya problem hai? Sound aa rahi hai, ya gear problem hai, ya brake issue?",
    "General Problem": "Machine mein aur detail mein kya problem hai?"
  };

  return questions[complaintType] || "Aur detail mein batayein ki exact kya problem hai?";
}

/* ======================= DETECTION FUNCTIONS ======================= */

function detectMachineType(text) {
  if (!text) return 'Warranty';
  const textLower = text.toLowerCase();

  for (const [type, keywords] of Object.entries(machineTypeKeywords)) {
    for (const keyword of keywords) {
      if (new RegExp(`\\b${keyword}\\b`, 'i').test(textLower)) {
        return type;
      }
    }
  }
  return 'Warranty';
}

function detectMachineStatus(text) {
  if (!text) return 'Running With Problem';
  const textLower = text.toLowerCase();

  // CRITICAL: Check "Breakdown" FIRST with strict matching
  const breakdownKeywords = machineStatusKeywords['Breakdown'];
  for (const keyword of breakdownKeywords) {
    const escapedKeyword = keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    if (new RegExp(`(^|\\s)${escapedKeyword}(\\s|$)`, 'i').test(textLower)) {
      console.log(`âœ“ Machine Status: Breakdown (matched: "${keyword}")`);
      return 'Breakdown';
    }
  }

  // Then check "Running With Problem"
  const runningKeywords = machineStatusKeywords['Running With Problem'];
  for (const keyword of runningKeywords) {
    if (textLower.includes(keyword.toLowerCase())) {
      console.log(`âœ“ Machine Status: Running With Problem (matched: "${keyword}")`);
      return 'Running With Problem';
    }
  }

  console.log(`âš ï¸ Machine Status not clearly detected, using default: Running With Problem`);
  return 'Running With Problem';
}

function detectJobLocation(text) {
  if (!text) return 'Onsite';
  const textLower = text.toLowerCase();

  // CRITICAL: Check "Workshop" FIRST (higher priority)
  const workshopKeywords = jobLocationKeywords['Workshop'];
  for (const keyword of workshopKeywords) {
    const escapedKeyword = keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    if (new RegExp(`(^|\\s)${escapedKeyword}`, 'i').test(textLower)) {
      console.log(`âœ“ Job Location: Workshop (matched: "${keyword}")`);
      return 'Workshop';
    }
  }

  // Then check "Onsite"
  const onsiteKeywords = jobLocationKeywords['Onsite'];
  for (const keyword of onsiteKeywords) {
    if (textLower.includes(keyword.toLowerCase())) {
      console.log(`âœ“ Job Location: Onsite (matched: "${keyword}")`);
      return 'Onsite';
    }
  }

  console.log(`âš ï¸ Job Location not clearly detected, using default: Onsite`);
  return 'Onsite';
}

function detectComplaint(text) {
  if (!text) return null;
  const textLower = text.toLowerCase();

  let bestMatch = null;
  let highestScore = 0;

  const sortedComplaints = Object.entries(complaintMap).sort(
    (a, b) => (b[1].priority || 0) - (a[1].priority || 0)
  );

  for (const [category, config] of sortedComplaints) {
    let score = 0;

    for (const keyword of config.keywords) {
      const keywordLower = keyword.toLowerCase();
      if (textLower.includes(keywordLower)) {
        if (new RegExp(`\\b${keywordLower}\\b`, 'i').test(textLower)) {
          score += keyword.length * 2;
        } else {
          score += keyword.length;
        }
      }
    }

    if (score > highestScore) {
      highestScore = score;
      bestMatch = category;
    }
  }

  return {
    complaint: bestMatch,
    score: highestScore
  };
}

function detectSubComplaint(mainComplaint, text) {
  if (!mainComplaint || !complaintMap[mainComplaint]) {
    return { subTitle: "Other", confidence: 0.5 };
  }

  const subTitles = complaintMap[mainComplaint].subTitles;
  if (!subTitles || Object.keys(subTitles).length === 0) {
    return { subTitle: "Other", confidence: 1.0 };
  }

  const textLower = text.toLowerCase();
  let bestMatch = null;
  let highestScore = 0;

  for (const [subTitle, keywords] of Object.entries(subTitles)) {
    let score = 0;

    for (const keyword of keywords) {
      const keywordLower = keyword.toLowerCase();
      if (textLower.includes(keywordLower)) {
        if (new RegExp(`\\b${keywordLower}\\b`, 'i').test(textLower)) {
          score += keyword.length * 2;
        } else {
          score += keyword.length;
        }
      }
    }

    if (score > highestScore) {
      highestScore = score;
      bestMatch = subTitle;
    }
  }

  return {
    subTitle: bestMatch || "Other",
    confidence: highestScore > 0 ? Math.min(highestScore / 15, 1) : 0.5
  };
}

/* ======================= TEXT PROCESSING ======================= */

function cleanSpeech(text) {
  if (!text) return "";
  return text
    .toLowerCase()
    .replace(/[à¥¤.,!?]/g, "")
    .replace(/\s+/g, " ")
    .trim();
}

function safeAscii(text) {
  if (!text) return "Unknown";
  return text.replace(/[^\w\s-]/g, '').trim() || "Unknown";
}

function detectBranchAndOutlet(city) {
  if (!city) return { branch: "NA", outlet: "NA", cityCode: "NA" };

  const normalized = city.toLowerCase().trim();
  return cityToBranchMap[normalized] || { branch: "NA", outlet: "NA", cityCode: "NA" };
}

function formatDateForExternal(date) {
  if (!date || date === "NA") return null;

  if (typeof date === "string" && /^\d{4}-\d{2}-\d{2}$/.test(date)) {
    return date;
  }

  const d = new Date(date);
  if (isNaN(d.getTime())) return null;

  const yyyy = d.getFullYear();
  const mm = String(d.getMonth() + 1).padStart(2, "0");
  const dd = String(d.getDate()).padStart(2, "0");

  return `${yyyy}-${mm}-${dd}`;
}

function ask(twiml, text) {
  const gather = twiml.gather({
    input: "speech dtmf",
    language: "hi-IN",
    speechTimeout: "auto",
    timeout: 8,
    actionOnEmptyResult: true,
    action: "/voice/process",
    method: "POST",
  });

  gather.say({ voice: "Polly.Aditi", language: "hi-IN" }, text);
}

function extractServiceDate(text) {
  if (!text) return null;

  const cleaned = text.toLowerCase();
  const today = new Date();

  if (/\baaj\b|\btoday\b|\bà¤†à¤œ\b/i.test(cleaned)) {
    return today;
  }

  if (/\bkal\b|\btomorrow\b|\bà¤•à¤²\b/i.test(cleaned)) {
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);
    return tomorrow;
  }

  if (/\bparso\b|\bà¤ªà¤°à¤¸à¥‹à¤‚\b|\bà¤ªà¤°à¤¸à¥‹\b/i.test(cleaned)) {
    const dayAfter = new Date(today);
    dayAfter.setDate(dayAfter.getDate() + 2);
    return dayAfter;
  }

  return null;
}

/* ======================= EXTERNAL API CALLS ======================= */

async function fetchCustomerFromExternal({ phone, chassisNo }) {
  try {
    let apiUrl = null;

    if (phone && isValidPhone(phone)) {
      apiUrl = `${EXTERNAL_API_BASE}/get_machine_by_phone_no.php?phone_no=${phone}`;
    } else if (chassisNo && isValidChassis(chassisNo)) {
      apiUrl = `${EXTERNAL_API_BASE}/get_machine_by_machine_no.php?machine_no=${chassisNo}`;
    }

    if (!apiUrl) {
      console.log("âš ï¸ No valid identifier for external API");
      return null;
    }

    console.log(`ðŸŒ Fetching from API: ${apiUrl}`);

    const response = await axios.get(apiUrl, {
      timeout: API_TIMEOUT,
      headers: API_HEADERS,
      validateStatus: (status) => status < 500,
    });

    if (
      response.status !== 200 ||
      !response.data ||
      response.data.status !== 1 ||
      !response.data.data
    ) {
      console.log("âš ï¸ API returned invalid response");
      return null;
    }

    const customerData = response.data.data;

    const normalized = {
      chassisNo: customerData.machine_no || chassisNo || "Unknown",
      phone: customerData.customer_phone_no || phone || "Unknown",
      name: customerData.customer_name || "Unknown",
      city: customerData.city || "Unknown",
      model: customerData.machine_model || "Unknown",
      subModel: customerData.sub_model || "NA",
      machineType: customerData.machine_type || "Unknown",
      businessPartnerCode: customerData.business_partner_code || "NA",
      purchaseDate: customerData.purchase_date || "NA",
      installationDate: customerData.installation_date || "NA",
    };

    console.log("âœ… Customer data fetched successfully");
    return normalized;

  } catch (error) {
    console.error("âŒ API Fetch Error:", error.message);
    return null;
  }
}

async function submitComplaintToExternal(complaintData) {
  try {
    console.log("\n" + "=".repeat(120));
    console.log("ðŸŒ SUBMITTING COMPLAINT TO EXTERNAL API");
    console.log("=".repeat(120));
    console.log(JSON.stringify(complaintData, null, 2));
    console.log("=".repeat(120) + "\n");

    const response = await axios.post(COMPLAINT_API_URL, complaintData, {
      timeout: API_TIMEOUT,
      headers: {
        "Content-Type": "application/json",
        ...API_HEADERS
      },
      validateStatus: (status) => status < 500,
    });

    if (
      response.status !== 200 ||
      !response.data ||
      response.data.status !== 1
    ) {
      console.log("âš ï¸ API Rejected:", response.data?.message || "Unknown error");
      return {
        success: false,
        error: response.data?.message || "API rejected"
      };
    }

    const sapId = response.data.data?.complaint_sap_id ||
                  response.data.data?.sap_id ||
                  null;

    console.log("âœ… Complaint submitted successfully. SAP ID:", sapId);

    return {
      success: true,
      data: response.data,
      sapId
    };

  } catch (error) {
    console.error("âŒ Submit Error:", error.message);
    return {
      success: false,
      error: error.message
    };
  }
}

/* ======================= SAVE COMPLAINT ======================= */

async function saveComplaint(twiml, callData) {
  try {
    const customerData = callData.customerData;
    const branchOutlet = detectBranchAndOutlet(customerData.city);

    const installationDate = customerData.installationDate &&
                            customerData.installationDate !== "NA"
      ? formatDateForExternal(customerData.installationDate)
      : null;

    const complaintApiData = {
      machine_no: callData.chassis || "Unknown",
      customer_name: safeAscii(customerData.name),
      caller_name: callData.callerName || "Not Provided",
      caller_no: callData.callerPhone || customerData.phone,
      contact_person: callData.callerName || "Customer",
      contact_person_number: callData.callerPhone || customerData.phone,
      machine_model: customerData.machineType || "Unknown",
      sub_model: customerData.model || "NA",
      installation_date: installationDate || "2025-01-01",
      machine_type: callData.machineType || "Warranty",
      city_id: branchOutlet.cityCode,
      complain_by: "Customer",
      machine_status: callData.machineStatus || "Running With Problem",
      job_location: callData.jobLocation || "Onsite",
      branch: branchOutlet.branch,
      outlet: branchOutlet.outlet,
      complaint_details: callData.rawComplaint || "Not provided",
      complaint_title: callData.complaintTitle || "General Problem",
      sub_title: callData.complaintSubTitle || "Other",
      business_partner_code: customerData.businessPartnerCode || "NA",
      complaint_sap_id: "NA",
      machine_location_address: callData.address || "Not Provided",
      pincode: callData.pincode || "",
      service_date: callData.serviceDate
        ? formatDateForExternal(callData.serviceDate)
        : "",
      from_time: callData.fromTime || "",
      to_time: callData.toTime || "",
      job_close_lat: "0.000000",
      job_close_lng: "0.000000",
      job_open_lat: "0.000000",
      job_open_lng: "0.000000",
    };

    const externalResult = await submitComplaintToExternal(complaintApiData);
    let sapId = null;

    if (externalResult.success) {
      sapId = externalResult.sapId;
    }

    const complaintDbData = {
      machineNo: callData.chassis || "Unknown",
      chassisNo: callData.chassis || "Unknown",
      customerName: safeAscii(customerData.name),
      registeredPhone: customerData.phone || "Unknown",
      machineModel: customerData.model || "Unknown",
      machineType: callData.machineType || "Warranty",
      machineStatus: callData.machineStatus || "Running With Problem",
      jobLocation: callData.jobLocation || "Onsite",
      complaintGivenByName: callData.callerName || "Not Provided",
      complaintGivenByPhone: callData.callerPhone || "Unknown",
      machineInstallationDate: installationDate ? new Date(installationDate) : null,
      description_raw: callData.rawComplaint || "",
      complaintTitle: callData.complaintTitle || "General Problem",
      complaintSubTitle: callData.complaintSubTitle || "Other",
      complaintSapId: sapId || null,
      branch: branchOutlet.branch,
      outlet: branchOutlet.outlet,
      source: "IVR_VOICE_BOT",
      machineLocationAddress: callData.address || "",
      machineLocationPincode: callData.pincode || "",
      serviceDate: callData.serviceDate || null,
      fromTime: callData.fromTime || "",
      toTime: callData.toTime || "",
    };

    const savedComplaint = await Complaint.create(complaintDbData);
    console.log(`âœ… Complaint saved to DB with ID: ${savedComplaint._id}`);

    return { success: true, sapId };

  } catch (error) {
    console.error("âŒ Database error:", error.message);
    return { success: false, error: error.message };
  }
}

/* ======================= INCOMING CALL HANDLER ======================= */

router.post("/", async (req, res) => {
  const { CallSid, From } = req.body;
  const twiml = new VoiceResponse();

  activeCalls.set(CallSid, {
    callSid: CallSid,
    from: From,
    step: "ivr_menu",
    retries: 0,
  });

  const gather = twiml.gather({
    input: "dtmf",
    numDigits: 1,
    timeout: 5,
    action: "/voice/process",
    method: "POST",
  });

  gather.say(
    { voice: "Polly.Aditi", language: "hi-IN" },
    "Namaste! Rajesh JCB Motors mein aapka swagat hai. Complaint register karne ke liye ek dabayein. Agar aap kisi agent se baat karna chahte hain to do dabayien."
  );

  res.type("text/xml").send(twiml.toString());
});

/* ======================= MAIN PROCESSING HANDLER ======================= */

router.post("/process", async (req, res) => {
  try {
    const twiml = new VoiceResponse();
  const { CallSid, Digits, SpeechResult } = req.body;

  let callData = activeCalls.get(CallSid);

  if (!callData) {
    callData = {
      callSid: CallSid,
      step: "ivr_menu",
      retries: 0,
    };
    activeCalls.set(CallSid, callData);
  }

  if (!SpeechResult && !Digits) {
    const lastQ = callData.lastQuestion || "Kripya apna jawab bolein.";
    ask(twiml, lastQ);
    activeCalls.set(CallSid, callData);
    return res.type("text/xml").send(twiml.toString());
  }

  // ===== IVR MENU =====
  if (callData.step === "ivr_menu") {
    if (Digits === "2") {
      twiml.say(
        { voice: "Polly.Aditi", language: "hi-IN" },
        "Theek hai. Aapko agent se connect kiya ja raha hai."
      );
      twiml.dial(process.env.HUMAN_AGENT_NUMBER);
      activeCalls.delete(CallSid);
      return res.type("text/xml").send(twiml.toString());
    }

    if (Digits === "1") {
      callData.step = "ask_chassis";
      callData.retries = 0;
      callData.lastQuestion = "Bilkul theek hai. Sabse pehle mujhe aapni machine ka chassis number batayein. Jaise ki, teen teen zero paanch char char saat.";
      ask(twiml, callData.lastQuestion);
      activeCalls.set(CallSid, callData);
      return res.type("text/xml").send(twiml.toString());
    }

    ask(twiml, "Kripya ek ya do dabayien.");
    activeCalls.set(CallSid, callData);
    return res.type("text/xml").send(twiml.toString());
  }

  const rawSpeech = cleanSpeech(SpeechResult || "");

  console.log("\n" + "=".repeat(120));
  console.log(`ðŸ“ž CALL: ${CallSid} | STEP: ${callData.step}`);
  console.log(`ðŸŽ¤ CUSTOMER: "${SpeechResult}"`);
  console.log(`ðŸ§¹ CLEANED: "${rawSpeech}"`);
  console.log("=".repeat(120));

  // ===== ASK CHASSIS =====
  if (callData.step === "ask_chassis") {
    const chassis = extractChassisNumberV2(rawSpeech);
    console.log(`âœ“ Chassis: ${chassis || "N/A"}`);

    if (!chassis || !isValidChassis(chassis)) {
      callData.retries = (callData.retries || 0) + 1;

      if (callData.retries >= 2) {
        console.log(`âŒ Invalid chassis after ${callData.retries} attempts - Escalating`);
        twiml.say(
          { voice: "Polly.Aditi", language: "hi-IN" },
          "Hum aapka chassis number samajh nahi paye. Aapko agent se connect kar rahe hain."
        );
        twiml.dial(process.env.HUMAN_AGENT_NUMBER);
        activeCalls.delete(CallSid);
        return res.type("text/xml").send(twiml.toString());
      }

      const hints = callData.retries === 1
        ? "Koi baat nahi. Chassis number ek ek digit ke saath dhire dhire boliye. Jaise: teen, teen, zero, paanch, char, char, saat."
        : "Apni machine ke documents mein dekh kar chassis number boliye. Ek ek number clear boliye.";

      callData.lastQuestion = hints;
      ask(twiml, hints);
      activeCalls.set(CallSid, callData);
      return res.type("text/xml").send(twiml.toString());
    }

    const customerData = await fetchCustomerFromExternal({ chassisNo: chassis });

    if (!customerData) {
      callData.retries = (callData.retries || 0) + 1;

      if (callData.retries >= 2) {
        console.log("âŒ Customer not found - Escalating");
        twiml.say(
          { voice: "Polly.Aditi", language: "hi-IN" },
          "Machine ka record nahi mila. Aapko agent se connect kar rahe hain."
        );
        twiml.dial(process.env.HUMAN_AGENT_NUMBER);
        activeCalls.delete(CallSid);
        return res.type("text/xml").send(twiml.toString());
      }

      callData.lastQuestion = "Record nahi mila. Phir se chassis number boliye.";
      ask(twiml, callData.lastQuestion);
      activeCalls.set(CallSid, callData);
      return res.type("text/xml").send(twiml.toString());
    }

    console.log(`âœ… Customer found: ${customerData.name}`);
    callData.chassis = chassis;
    callData.customerData = customerData;
    callData.step = "ask_caller_name";
    callData.retries = 0;
    callData.lastQuestion = "Bahut accha! Machine mil gayi. Ab mujhe batayein, complaint dene wale ka naam kya hai? Apna pura naam boliye.";
    ask(twiml, callData.lastQuestion);
    activeCalls.set(CallSid, callData);
    return res.type("text/xml").send(twiml.toString());
  }

  // ===== ASK CALLER NAME =====
  if (callData.step === "ask_caller_name") {
    if (rejectInvalid(rawSpeech)) {
      callData.retries = (callData.retries || 0) + 1;

      if (callData.retries >= 2) {
        twiml.say(
          { voice: "Polly.Aditi", language: "hi-IN" },
          "Naam samajh nahi aaya. Aapko agent se connect kiya ja raha hai."
        );
        twiml.dial(process.env.HUMAN_AGENT_NUMBER);
        activeCalls.delete(CallSid);
        return res.type("text/xml").send(twiml.toString());
      }

      ask(twiml, callData.lastQuestion);
      activeCalls.set(CallSid, callData);
      return res.type("text/xml").send(twiml.toString());
    }

    const name = extractNameV2(rawSpeech);
    console.log(`âœ“ Caller Name Extracted: ${name || "N/A"}`);

    if (!name || !isValidName(name)) {
      callData.retries = (callData.retries || 0) + 1;

      if (callData.retries >= 2) {
        twiml.say(
          { voice: "Polly.Aditi", language: "hi-IN" },
          "Naam sahi tarah se samajh nahi paye. Aapko agent se connect kar rahe hain."
        );
        twiml.dial(process.env.HUMAN_AGENT_NUMBER);
        activeCalls.delete(CallSid);
        return res.type("text/xml").send(twiml.toString());
      }

      callData.lastQuestion = "Kripya apna pura naam saaf saaf boliye.";
      ask(twiml, callData.lastQuestion);
      activeCalls.set(CallSid, callData);
      return res.type("text/xml").send(twiml.toString());
    }

    callData.callerName = name;
    callData.retries = 0;
    callData.step = "ask_caller_phone";
    callData.lastQuestion = "Dhanyavaad. Ab apna mobile number batayein.";
    ask(twiml, callData.lastQuestion);
    activeCalls.set(CallSid, callData);
    return res.type("text/xml").send(twiml.toString());
  }

  // ===== ASK CALLER PHONE =====
  if (callData.step === "ask_caller_phone") {
    if (rejectInvalid(rawSpeech)) {
      callData.retries = (callData.retries || 0) + 1;

      if (callData.retries >= 2) {
        twiml.say(
          { voice: "Polly.Aditi", language: "hi-IN" },
          "Samajh nahi aaya. Agent se connect kar rahe hain."
        );
        twiml.dial(process.env.HUMAN_AGENT_NUMBER);
        activeCalls.delete(CallSid);
        return res.type("text/xml").send(twiml.toString());
      }

      ask(twiml, callData.lastQuestion);
      activeCalls.set(CallSid, callData);
      return res.type("text/xml").send(twiml.toString());
    }

    const phone = extractPhoneNumberV2(rawSpeech);
    console.log(`âœ“ Phone: ${phone || "N/A"}`);

    if (!phone || !isValidPhone(phone)) {
      callData.retries = (callData.retries || 0) + 1;

      if (callData.retries >= 2) {
        console.log("âŒ Invalid phone - Using registered phone");
        callData.callerPhone = callData.customerData.phone;
        callData.step = "confirm_phone";
        const spokenDigits = phoneToSpokenDigits(callData.callerPhone);
        callData.lastQuestion = `Theek hai. Aapka registered number use karenge: ${spokenDigits}. Kya sahi hai?`;
        ask(twiml, callData.lastQuestion);
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      }

      callData.lastQuestion = "Das digit mobile number. Ek ek digit clear bolein. Jaise: nau, aath, saat, chhe, paanch...";
      ask(twiml, callData.lastQuestion);
      activeCalls.set(CallSid, callData);
      return res.type("text/xml").send(twiml.toString());
    }

    callData.callerPhone = phone;
    callData.step = "confirm_phone";
    const spokenDigits = phoneToSpokenDigits(phone);
    callData.lastQuestion = `Theek hai. Maine aapka number likh liya: ${spokenDigits}. Kya ye bilkul sahi hai?`;
    ask(twiml, callData.lastQuestion);
    activeCalls.set(CallSid, callData);
    return res.type("text/xml").send(twiml.toString());
  }

  // ===== CONFIRM PHONE =====
  if (callData.step === "confirm_phone") {
    const isAffirm = isAffirmative(rawSpeech);
    const isNeg = isNegative(rawSpeech);

    console.log(`ðŸ” Confirmation - Affirmative: ${isAffirm}, Negative: ${isNeg}`);

    if (isAffirm) {
      console.log(`âœ“ Phone confirmed: ${callData.callerPhone}`);
      callData.step = "ask_machine_type";
      callData.retries = 0;
      callData.lastQuestion = "Bahut badhiya. Ab batayein, aapki machine warranty mein hai, ya JCB care mein, ya koi aur plan mein hai?";
      ask(twiml, callData.lastQuestion);
      activeCalls.set(CallSid, callData);
      return res.type("text/xml").send(twiml.toString());
    }

    if (isNeg) {
      console.log(`âŒ Phone not confirmed - Re-asking`);
      callData.step = "ask_caller_phone";
      callData.retries = 0;
      callData.lastQuestion = "Theek hai. Ek baar phir se apna 10 digit mobile number boliye.";
      ask(twiml, callData.lastQuestion);
      activeCalls.set(CallSid, callData);
      return res.type("text/xml").send(twiml.toString());
    }

    callData.retries = (callData.retries || 0) + 1;
    if (callData.retries >= 2) {
      callData.step = "ask_machine_type";
      callData.retries = 0;
      callData.lastQuestion = "Theek hai. Ab batayein, machine warranty mein hai ya care mein?";
      ask(twiml, callData.lastQuestion);
      activeCalls.set(CallSid, callData);
      return res.type("text/xml").send(twiml.toString());
    }

    callData.lastQuestion = "Haan ya nahi mein jawab dijiye.";
    ask(twiml, callData.lastQuestion);
    activeCalls.set(CallSid, callData);
    return res.type("text/xml").send(twiml.toString());
  }

  // ===== ASK MACHINE TYPE =====
  if (callData.step === "ask_machine_type") {
    const machineType = detectMachineType(rawSpeech);
    console.log(`âœ“ Machine Type: ${machineType}`);

    callData.machineType = machineType;
    callData.step = "ask_machine_status";
    callData.lastQuestion = "Machine bilkul band hai, breakdown hai, ya problem ke saath chal rahi hai?";
    ask(twiml, callData.lastQuestion);
    activeCalls.set(CallSid, callData);
    return res.type("text/xml").send(twiml.toString());
  }

  // ===== ASK MACHINE STATUS =====
  if (callData.step === "ask_machine_status") {
    const status = detectMachineStatus(rawSpeech);
    console.log(`âœ“ Machine Status: ${status}`);

    callData.machineStatus = status;
    callData.step = "ask_job_location";
    callData.lastQuestion = "Accha. Ab batayein, machine kahan hai? Workshop mein hai ya site par hai?";
    ask(twiml, callData.lastQuestion);
    activeCalls.set(CallSid, callData);
    return res.type("text/xml").send(twiml.toString());
  }

  // ===== ASK JOB LOCATION =====
  if (callData.step === "ask_job_location") {
    if (rejectInvalid(rawSpeech)) {
      callData.retries = (callData.retries || 0) + 1;

      if (callData.retries >= 2) {
        twiml.say(
          { voice: "Polly.Aditi", language: "hi-IN" },
          "Samajh nahi aaya. Agent se connect kar rahe hain."
        );
        twiml.dial(process.env.HUMAN_AGENT_NUMBER);
        activeCalls.delete(CallSid);
        return res.type("text/xml").send(twiml.toString());
      }

      ask(twiml, callData.lastQuestion);
      activeCalls.set(CallSid, callData);
      return res.type("text/xml").send(twiml.toString());
    }

    const location = detectJobLocation(rawSpeech);
    console.log(`âœ“ Job Location: ${location}`);

    callData.jobLocation = location;
    callData.step = "ask_address";
    callData.retries = 0;
    callData.lastQuestion = "Theek hai. Ab machine ka full address bataiye. City, area, aur 6 digit pincode zaroori hai.";
    ask(twiml, callData.lastQuestion);
    activeCalls.set(CallSid, callData);
    return res.type("text/xml").send(twiml.toString());
  }

  // ===== ASK ADDRESS =====
  if (callData.step === "ask_address") {
    if (rejectInvalid(rawSpeech)) {
      callData.retries = (callData.retries || 0) + 1;

      if (callData.retries >= 2) {
        callData.address = "Not Provided";
        callData.step = "ask_pincode";
        callData.retries = 0;
        callData.lastQuestion = "Theek hai. Ab apna 6 digit pincode batayein.";
        ask(twiml, callData.lastQuestion);
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      }

      ask(twiml, callData.lastQuestion);
      activeCalls.set(CallSid, callData);
      return res.type("text/xml").send(twiml.toString());
    }

    const address = extractLocationAddressV2(rawSpeech);
    console.log(`âœ“ Address: ${address || "N/A"}`);

    if (!address || !isValidAddress(address)) {
      callData.retries = (callData.retries || 0) + 1;

      if (callData.retries >= 2) {
        callData.address = "Not Provided";
        callData.step = "ask_pincode";
        callData.retries = 0;
        callData.lastQuestion = "Theek hai. Ab apna 6 digit pincode batayein.";
        ask(twiml, callData.lastQuestion);
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      }

      callData.lastQuestion = "Address clear samajh nahi aaya. City aur area naam dobara boliye.";
      ask(twiml, callData.lastQuestion);
      activeCalls.set(CallSid, callData);
      return res.type("text/xml").send(twiml.toString());
    }

    callData.address = address;
    callData.step = "ask_pincode";
    callData.retries = 0;
    callData.lastQuestion = "Bahut accha! Ab apna 6 digit ka pincode batayein.";
    ask(twiml, callData.lastQuestion);
    activeCalls.set(CallSid, callData);
    return res.type("text/xml").send(twiml.toString());
  }

  // ===== ASK PINCODE =====
  if (callData.step === "ask_pincode") {
    if (rejectInvalid(rawSpeech)) {
      callData.retries = (callData.retries || 0) + 1;

      if (callData.retries >= 3) {
        twiml.say(
          { voice: "Polly.Aditi", language: "hi-IN" },
          "Pincode samajh nahi aaya. Aapko agent se connect kar rahe hain."
        );
        twiml.dial(process.env.HUMAN_AGENT_NUMBER);
        activeCalls.delete(CallSid);
        return res.type("text/xml").send(twiml.toString());
      }

      ask(twiml, callData.lastQuestion);
      activeCalls.set(CallSid, callData);
      return res.type("text/xml").send(twiml.toString());
    }

    const pincode = extractPincodeV2(rawSpeech);

    if (!pincode || !isValidPincode(pincode)) {
      callData.retries = (callData.retries || 0) + 1;

      if (callData.retries >= 3) {
        twiml.say(
          { voice: "Polly.Aditi", language: "hi-IN" },
          "Sahi 6 digit pincode nahi mila. Agent se connect kar rahe hain."
        );
        twiml.dial(process.env.HUMAN_AGENT_NUMBER);
        activeCalls.delete(CallSid);
        return res.type("text/xml").send(twiml.toString());
      }

      callData.lastQuestion = "Kripya apna 6 digit ka sahi pincode batayein.";
      ask(twiml, callData.lastQuestion);
      activeCalls.set(CallSid, callData);
      return res.type("text/xml").send(twiml.toString());
    }

    callData.pincode = pincode;
    callData.retries = 0;
    callData.step = "ask_complaint";
    callData.lastQuestion = "Bilkul theek hai. Ab mujhe batayein, machine mein kya problem hai?";
    ask(twiml, callData.lastQuestion);
    activeCalls.set(CallSid, callData);
    return res.type("text/xml").send(twiml.toString());
  }

  // ===== ASK COMPLAINT =====
  if (callData.step === "ask_complaint") {
    if (rejectInvalid(rawSpeech)) {
      callData.retries = (callData.retries || 0) + 1;

      if (callData.retries >= 2) {
        twiml.say(
          { voice: "Polly.Aditi", language: "hi-IN" },
          "Samajh nahi aaya. Agent se connect kar rahe hain."
        );
        twiml.dial(process.env.HUMAN_AGENT_NUMBER);
        activeCalls.delete(CallSid);
        return res.type("text/xml").send(twiml.toString());
      }

      ask(twiml, callData.lastQuestion);
      activeCalls.set(CallSid, callData);
      return res.type("text/xml").send(twiml.toString());
    }

    callData.rawComplaint = rawSpeech;
    const detected = detectComplaint(rawSpeech);

    if (!detected || detected.score < 5) {
      callData.step = "ask_complaint_detail";
      callData.lastQuestion = "Machine mein exactly kya problem hai? Thoda detail mein batayein.";
      ask(twiml, callData.lastQuestion);
      activeCalls.set(CallSid, callData);
      return res.type("text/xml").send(twiml.toString());
    }

    if (!detected || !detected.complaint || detected.score < 3) {
      callData.retries = (callData.retries || 0) + 1;

      if (callData.retries >= 2) {
        console.log("âŒ Complaint not clear - Using General Problem");
        callData.complaintTitle = "General Problem";
        callData.complaintSubTitle = "Other";
        callData.step = "ask_service_date";
        callData.retries = 0;
        callData.lastQuestion = "Theek hai. Engineer kab aaye? Aaj, kal, parso?";
        ask(twiml, callData.lastQuestion);
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      }

      callData.lastQuestion = "Problem clear samajh nahi aaya. Dobara batayein. Engine mein dikkat, AC mein, brake mein, tyre mein, battery mein, hydraulic mein, ya kuch aur?";
      ask(twiml, callData.lastQuestion);
      activeCalls.set(CallSid, callData);
      return res.type("text/xml").send(twiml.toString());
    }

    console.log(`âœ“ Complaint detected: ${detected.complaint} (Score: ${detected.score})`);
    callData.complaintTitle = detected.complaint;

    // Check if this complaint has sub-complaints
    const hasSubComplaints = complaintMap[detected.complaint]?.subTitles &&
                            Object.keys(complaintMap[detected.complaint].subTitles).length > 0;

    if (hasSubComplaints) {
      const subResult = detectSubComplaint(detected.complaint, rawSpeech);

      if (subResult && subResult.subTitle !== "Other" && subResult.confidence > 0.6) {
        callData.complaintSubTitle = subResult.subTitle;
        console.log(`âœ“ Sub-complaint auto-detected: ${subResult.subTitle}`);
        
        callData.step = "confirm_complaint";
        callData.lastQuestion = `Theek hai, samajh gaya. Toh aapka complaint hai: ${callData.complaintTitle} - ${callData.complaintSubTitle}. Kya sahi hai?`;
        ask(twiml, callData.lastQuestion);
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      } else {
        callData.step = "ask_sub_complaint";
        callData.retries = 0;
        const subQuestion = getSubComplaintQuestion(detected.complaint);
        callData.lastQuestion = subQuestion;
        ask(twiml, subQuestion);
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      }
    } else {
      callData.complaintSubTitle = "Other";
      callData.step = "confirm_complaint";
      callData.lastQuestion = `Theek hai. Toh aapka complaint hai: ${callData.complaintTitle}. Kya sahi hai?`;
      ask(twiml, callData.lastQuestion);
      activeCalls.set(CallSid, callData);
      return res.type("text/xml").send(twiml.toString());
    }
  }

  // ===== ASK COMPLAINT DETAIL =====
  if (callData.step === "ask_complaint_detail") {
    callData.rawComplaint = rawSpeech;
    const detected = detectComplaint(rawSpeech);

    if (!detected || !detected.complaint) {
      callData.complaintTitle = "General Problem";
      callData.complaintSubTitle = "Other";
    } else {
      callData.complaintTitle = detected.complaint;
      const subResult = detectSubComplaint(detected.complaint, rawSpeech);
      callData.complaintSubTitle = subResult.subTitle || "Other";
    }

    callData.step = "confirm_complaint";
    callData.lastQuestion = `Theek hai. Toh aapka complaint hai: ${callData.complaintTitle} - ${callData.complaintSubTitle}. Kya sahi hai?`;
    ask(twiml, callData.lastQuestion);
    activeCalls.set(CallSid, callData);
    return res.type("text/xml").send(twiml.toString());
  }

  // ===== ASK SUB-COMPLAINT =====
  if (callData.step === "ask_sub_complaint") {
    const subResult = detectSubComplaint(callData.complaintTitle, rawSpeech);

    console.log(`âœ“ Sub-complaint: ${subResult.subTitle} (Confidence: ${subResult.confidence})`);

    if (subResult && subResult.subTitle !== "Other" && subResult.confidence > 0.3) {
      callData.complaintSubTitle = subResult.subTitle;
      callData.step = "confirm_complaint";
      callData.lastQuestion = `Theek hai. Toh aapka complaint hai: ${callData.complaintTitle} - ${callData.complaintSubTitle}. Kya ye sahi hai?`;
      ask(twiml, callData.lastQuestion);
      activeCalls.set(CallSid, callData);
      return res.type("text/xml").send(twiml.toString());
    }

    callData.retries = (callData.retries || 0) + 1;

    if (callData.retries >= 2) {
      console.log("âŒ Sub-complaint not clear - Using Other");
      callData.complaintSubTitle = "Other";
      callData.step = "confirm_complaint";
      callData.lastQuestion = `Theek hai. Toh aapka complaint hai: ${callData.complaintTitle}. Confirm hai?`;
      ask(twiml, callData.lastQuestion);
      activeCalls.set(CallSid, callData);
      return res.type("text/xml").send(twiml.toString());
    }

    const subQuestion = getSubComplaintQuestion(callData.complaintTitle);
    callData.lastQuestion = "Mujhe clear samajh nahi aaya. " + subQuestion;
    ask(twiml, callData.lastQuestion);
    activeCalls.set(CallSid, callData);
    return res.type("text/xml").send(twiml.toString());
  }

  // ===== CONFIRM COMPLAINT =====
  if (callData.step === "confirm_complaint") {
    const isAffirm = isAffirmative(rawSpeech);
    const isNeg = isNegative(rawSpeech);

    console.log(`ðŸ” Complaint confirmation - Affirmative: ${isAffirm}, Negative: ${isNeg}`);

    if (isAffirm) {
      console.log(`âœ“ Complaint confirmed`);
      callData.step = "ask_service_date";
      callData.retries = 0;
      callData.lastQuestion = "Bahut accha. Ab batayein, engineer ko kab bulana hai? Aaj, kal, ya parso?";
      ask(twiml, callData.lastQuestion);
      activeCalls.set(CallSid, callData);
      return res.type("text/xml").send(twiml.toString());
    }

    if (isNeg) {
      console.log(`âŒ Complaint not confirmed - Re-asking`);
      callData.step = "ask_complaint";
      callData.retries = 0;
      callData.lastQuestion = "Theek hai. Phir se batayein, machine mein kya problem hai?";
      ask(twiml, callData.lastQuestion);
      activeCalls.set(CallSid, callData);
      return res.type("text/xml").send(twiml.toString());
    }

    callData.retries = (callData.retries || 0) + 1;
    if (callData.retries >= 2) {
      callData.step = "ask_service_date";
      callData.retries = 0;
      callData.lastQuestion = "Theek hai. Engineer kab aaye? Aaj, kal ya parso?";
      ask(twiml, callData.lastQuestion);
      activeCalls.set(CallSid, callData);
      return res.type("text/xml").send(twiml.toString());
    }

    callData.lastQuestion = "Haan ya nahi mein jawab dijiye.";
    ask(twiml, callData.lastQuestion);
    activeCalls.set(CallSid, callData);
    return res.type("text/xml").send(twiml.toString());
  }

  // ===== ASK SERVICE DATE =====
  if (callData.step === "ask_service_date") {
    const date = extractServiceDate(rawSpeech);

    if (!date) {
      callData.retries = (callData.retries || 0) + 1;

      if (callData.retries >= 2) {
        const tomorrow = new Date();
        tomorrow.setDate(tomorrow.getDate() + 1);
        callData.serviceDate = tomorrow;
        callData.step = "ask_service_time_from";
        callData.retries = 0;
        callData.lastQuestion = "Kitne baje se engineer aa sakta hai?";
        ask(twiml, callData.lastQuestion);
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      }

      callData.lastQuestion = "Aaj, kal, parso ya specific date boliye.";
      ask(twiml, callData.lastQuestion);
      activeCalls.set(CallSid, callData);
      return res.type("text/xml").send(twiml.toString());
    }

    console.log(`âœ“ Service Date: ${date.toDateString()}`);
    callData.serviceDate = date;
    callData.step = "ask_service_time_from";
    callData.lastQuestion = "Theek hai. Kitne baje se engineer aa sakta hai? Subah, dopahar ya sham, koi bhi time bata dijiye.";
    ask(twiml, callData.lastQuestion);
    activeCalls.set(CallSid, callData);
    return res.type("text/xml").send(twiml.toString());
  }

  // ===== ASK FROM TIME =====
  if (callData.step === "ask_service_time_from") {
    const fromTime = extractTimeV2(rawSpeech);

    if (!fromTime) {
      callData.retries = (callData.retries || 0) + 1;

      if (callData.retries >= 2) {
        callData.fromTime = "9:00 AM";
        callData.step = "ask_service_time_to";
        callData.retries = 0;
        callData.lastQuestion = "Kitne baje tak engineer ruk sakta hai?";
        ask(twiml, callData.lastQuestion);
        activeCalls.set(CallSid, callData);
        return res.type("text/xml").send(twiml.toString());
      }

      callData.lastQuestion = "Time clear batayein. Jaise: subah nau baje, dopahar do baje, sham paanch baje.";
      ask(twiml, callData.lastQuestion);
      activeCalls.set(CallSid, callData);
      return res.type("text/xml").send(twiml.toString());
    }

    console.log(`âœ“ From Time: ${fromTime}`);
    callData.fromTime = fromTime;
    callData.step = "ask_service_time_to";
    callData.lastQuestion = "Accha. Kitne baje tak engineer wahan ruk sakta hai?";
    ask(twiml, callData.lastQuestion);
    activeCalls.set(CallSid, callData);
    return res.type("text/xml").send(twiml.toString());
  }

  // ===== ASK TO TIME & SAVE =====
  if (callData.step === "ask_service_time_to") {
    const toTime = extractTimeV2(rawSpeech);

    if (!toTime) {
      callData.retries = (callData.retries || 0) + 1;

      if (callData.retries >= 2) {
        callData.toTime = "5:00 PM";

        console.log("\n" + "=".repeat(120));
        console.log("âœ… ALL DATA COLLECTED - SAVING COMPLAINT");
        console.log("=".repeat(120));
        console.log(`ðŸ”§ Chassis: ${callData.chassis}`);
        console.log(`ðŸ“± Caller: ${callData.callerName} (${callData.callerPhone})`);
        console.log(`ðŸ¢ Machine Type: ${callData.machineType}`);
        console.log(`ðŸ”´ Status: ${callData.machineStatus}`);
        console.log(`ðŸ“ Location: ${callData.jobLocation}`);
        console.log(`ðŸ  Address: ${callData.address}`);
        console.log(`ðŸ“® Pincode: ${callData.pincode}`);
        console.log(`ðŸŽ¯ Complaint: ${callData.complaintTitle} â†’ ${callData.complaintSubTitle}`);
        console.log(`ðŸ“… Service: ${callData.serviceDate?.toDateString()}`);
        console.log(`â° Time: ${callData.fromTime} - ${callData.toTime}`);
        console.log("=".repeat(120) + "\n");

        const result = await saveComplaint(twiml, callData);

        if (result.success) {
          twiml.say(
            { voice: "Polly.Aditi", language: "hi-IN" },
            `Bahut bahut dhanyavaad! Aapki complaint successfully register ho gayi hai${result.sapId ? '. Complaint number: ' + result.sapId : ''}. Hamara engineer jald hi aapse contact karega!`
          );
        } else {
          twiml.say(
            { voice: "Polly.Aditi", language: "hi-IN" },
            "Dhanyavaad! Aapki complaint register ho gayi hai. Hamari team aapko contact karega!"
          );
        }

        twiml.hangup();
        activeCalls.delete(CallSid);
        return res.type("text/xml").send(twiml.toString());
      }

      callData.lastQuestion = "Time boliye. Jaise: paanch baje, saat baje.";
      ask(twiml, callData.lastQuestion);
      activeCalls.set(CallSid, callData);
      return res.type("text/xml").send(twiml.toString());
    }

    console.log(`âœ“ To Time: ${toTime}`);
    callData.toTime = toTime;

    console.log("\n" + "=".repeat(120));
    console.log("âœ… ALL DATA COLLECTED - SAVING COMPLAINT");
    console.log("=".repeat(120));
    console.log(`ðŸ”§ Chassis: ${callData.chassis}`);
    console.log(`ðŸ“± Caller: ${callData.callerName} (${callData.callerPhone})`);
    console.log(`ðŸ¢ Machine Type: ${callData.machineType}`);
    console.log(`ðŸ”´ Status: ${callData.machineStatus}`);
    console.log(`ðŸ“ Location: ${callData.jobLocation}`);
    console.log(`ðŸ  Address: ${callData.address}`);
    console.log(`ðŸ“® Pincode: ${callData.pincode}`);
    console.log(`ðŸŽ¯ Complaint: ${callData.complaintTitle} â†’ ${callData.complaintSubTitle}`);
    console.log(`ðŸ“… Service: ${callData.serviceDate?.toDateString()}`);
    console.log(`â° Time: ${callData.fromTime} - ${toTime}`);
    console.log("=".repeat(120) + "\n");

    const result = await saveComplaint(twiml, callData);

    if (result.success) {
      twiml.say(
        { voice: "Polly.Aditi", language: "hi-IN" },
        `Bahut bahut dhanyavaad! Aapki complaint successfully register ho gayi hai${result.sapId ? '. Complaint number: ' + result.sapId : ''}. Hamara engineer jald hi aapse contact karega!`
      );
    } else {
      twiml.say(
        { voice: "Polly.Aditi", language: "hi-IN" },
        "Dhanyavaad! Aapki complaint register ho gayi hai. Hamari team aapko contact karega!"
      );
    }

    twiml.hangup();
    activeCalls.delete(CallSid);
    return res.type("text/xml").send(twiml.toString());
  }

  activeCalls.set(CallSid, callData);
  res.type("text/xml").send(twiml.toString());
  } catch (error) {
    console.error("âŒ Call Processing Error:", error);
    const twiml = new VoiceResponse();
    twiml.say(
      { voice: "Polly.Aditi", language: "hi-IN" },
      "Kshama karein, kuch technical problem hai. Kripya agent se baat karne ke liye do dabayein."
    );
    twiml.dial(process.env.HUMAN_AGENT_NUMBER);
    return res.type("text/xml").send(twiml.toString());
  }
});

export default router;




















/**
 * Enhanced Extraction Utilities for JCB IVR Voice Bot
 * 
 * Fixes:
 * 1. âœ… Better Name Extraction - Removes noise words like "à¤®à¥‡à¤°à¤¾", "à¤ªà¥‚à¤°à¤¾", "à¤¨à¤¾à¤®"
 * 2. âœ… Strict 6-Digit Pincode Validation
 * 3. âœ… Improved Address Extraction - Filters out pincodes and noise
 * 4. âœ… Accurate AM/PM Time Extraction - Contextual detection based on Hindi/English keywords
 * 5. âœ… Better Complaint Detection - More context-aware processing
 */

// ======================= NOISE WORDS TO FILTER =======================
const HINDI_NOISE_WORDS = [
  'à¤®à¥‡à¤°à¤¾', 'à¤®à¥‡à¤°à¥€', 'à¤®à¥‡à¤°à¥‡', 'à¤®à¥à¤à¥‡', 'à¤®à¥ˆà¤‚', 'à¤¹à¤®', 'à¤¹à¤®à¤¾à¤°à¤¾', 'à¤¹à¤®à¤¾à¤°à¥€',
  'à¤ªà¥‚à¤°à¤¾', 'à¤ªà¥‚à¤°à¥€', 'à¤ªà¥‚à¤°à¥‡', 'à¤¨à¤¾à¤®', 'à¤¹à¥ˆ', 'à¤¹à¥ˆà¤‚', 'à¤¹à¥‹', 'à¤¹à¥‚à¤‚',
  'à¤•à¤¾', 'à¤•à¥€', 'à¤•à¥‡', 'à¤•à¥€', 'à¤•à¥‹', 'à¤¸à¥‡', 'à¤®à¥‡à¤‚', 'à¤ªà¤°', 'à¤ªà¤°',
  'à¤¯à¤¹', 'à¤µà¤¹', 'à¤¯à¥‡', 'à¤µà¥‹', 'à¤¯à¤¹à¥€', 'à¤µà¤¹à¥€', 'à¤à¤•', 'à¤¦à¥‹', 'à¤¤à¥€à¤¨',
  'à¤”à¤°', 'à¤¤à¥‹', 'à¤­à¥€', 'à¤¹à¥€', 'à¤¤à¤•', 'à¤¤à¤•', 'à¤­à¤°', 'à¤­à¤°'
];

const ENGLISH_NOISE_WORDS = [
  'my', 'name', 'is', 'are', 'the', 'a', 'an', 'this', 'that',
  'these', 'those', 'be', 'have', 'has', 'had', 'do', 'does',
  'did', 'will', 'would', 'should', 'could', 'may', 'might',
  'full', 'complete', 'whole', 'entire', 'i', 'me', 'we'
];

// ======================= HINDI DIGIT WORDS =======================
const HINDI_DIGITS = {
  'à¤¶à¥‚à¤¨à¥à¤¯': '0', 'à¤œà¥€à¤°à¥‹': '0', 'zero': '0',
  'à¤à¤•': '1', 'à¤à¤•': '1', 'one': '1', 'ek': '1',
  'à¤¦à¥‹': '2', 'à¤¦à¥à¤ˆ': '2', 'two': '2', 'do': '2',
  'à¤¤à¥€à¤¨': '3', 'three': '3', 'teen': '3',
  'à¤šà¤¾à¤°': '4', 'four': '4', 'char': '4',
  'à¤ªà¤¾à¤‚à¤š': '5', 'paanch': '5', 'panch': '5', 'five': '5',
  'à¤›à¤ƒ': '6', 'à¤›à¤¹': '6', 'chhe': '6', 'six': '6',
  'à¤¸à¤¾à¤¤': '7', 'saat': '7', 'seven': '7',
  'à¤†à¤ ': '8', 'aath': '8', 'eight': '8',
  'à¤¨à¥Œ': '9', 'nau': '9', 'nine': '9'
};

// ======================= COMMON NAMES DATABASE =======================
const COMMON_NAMES = new Set([
  'à¤°à¤¾à¤œ', 'à¤°à¤¾à¤œà¥‡à¤¶', 'à¤…à¤‚à¤¶à¥', 'à¤…à¤‚à¤¶à¥à¤²', 'à¤¨à¥€à¤°à¤œ', 'à¤µà¤¿à¤œà¤¯', 'à¤¸à¤‚à¤œà¤¯',
  'à¤ªà¥à¤°à¤¿à¤¯à¤¾', 'à¤¦à¥€à¤ªà¥à¤¤à¤¿', 'à¤¶à¥€à¤²à¤¾', 'à¤®à¤¾à¤²à¤¾', 'à¤¸à¥€à¤®à¤¾', 'à¤¨à¥€à¤¤à¤¾', 'à¤¸à¥à¤¨à¥€à¤¤à¤¾',
  'à¤…à¤®à¤¿à¤¤', 'à¤­à¤¾à¤°à¤¤', 'à¤¸à¥à¤®à¤¿à¤¤', 'à¤ªà¥à¤°à¤®à¥‹à¤¦', 'à¤¸à¤‚à¤œà¥€à¤µ', 'à¤¸à¥à¤°à¥‡à¤¶', 'à¤°à¤®à¥‡à¤¶',
  'à¤†à¤¦à¤¿à¤¤à¥à¤¯', 'à¤¦à¤¿à¤µà¥à¤¯', 'à¤µà¤¿à¤•à¥à¤°à¤®', 'à¤¨à¤¿à¤–à¤¿à¤²', 'à¤°à¤¾à¤¹à¥à¤²', 'à¤¹à¥ƒà¤¦à¤¯', 'à¤¸à¤‚à¤¤',
  'à¤°à¤¹à¥€à¤®', 'à¤•à¤°à¥€à¤®', 'à¤¹à¤•à¥€à¤®', 'à¤«à¤°à¤¹à¤¾à¤¨', 'à¤‡à¤®à¤°à¤¾à¤¨', 'à¤¸à¤²à¥€à¤®', 'à¤¹à¤¸à¤¨',
  'à¤°à¤¾à¤œ', 'à¤°à¤¾à¤œ à¤•à¥à¤®à¤¾à¤°', 'à¤¸à¥€à¤®à¤¾ à¤¶à¤°à¥à¤®à¤¾', 'à¤ªà¥à¤°à¤¿à¤¯à¤¾ à¤µà¤°à¥à¤®à¤¾',
  'john', 'james', 'robert', 'michael', 'william', 'david', 'richard',
  'mary', 'patricia', 'jennifer', 'linda', 'barbara', 'susan', 'jessica'
]);

// ======================= NAME EXTRACTION V3 (ENHANCED) =======================
export function extractNameV3(text) {
  if (!text || text.trim().length === 0) return null;

  console.log(`\nðŸ‘¤ NAME EXTRACTION V3 START`);
  console.log(`   Input: ${text}`);

  // Step 1: Convert to lowercase for processing
  const lowerText = text.toLowerCase().trim();

  // Step 2: Remove common noise phrases
  let cleaned = lowerText;
  HINDI_NOISE_WORDS.forEach(word => {
    const regex = new RegExp(`\\b${word}\\b`, 'gi');
    cleaned = cleaned.replace(regex, '');
  });
  ENGLISH_NOISE_WORDS.forEach(word => {
    const regex = new RegExp(`\\b${word}\\b`, 'gi');
    cleaned = cleaned.replace(regex, '');
  });

  console.log(`   After removing noise: ${cleaned}`);

  // Step 3: Remove special characters but keep spaces
  cleaned = cleaned.replace(/[à¥¤,!?;:()[\]{}'"]/g, '').trim();
  console.log(`   After cleaning special chars: ${cleaned}`);

  // Step 4: Split into words and filter
  let words = cleaned.split(/\s+/).filter(w => w.length > 0);
  console.log(`   Words after split: [${words.join(', ')}]`);

  // Step 5: Filter out remaining noise
  words = words.filter(w => {
    const isNoise = HINDI_NOISE_WORDS.includes(w) || ENGLISH_NOISE_WORDS.includes(w);
    const isNumber = /^\d+$/.test(w);
    const isTooShort = w.length < 2;
    return !isNoise && !isNumber && !isTooShort;
  });

  console.log(`   Filtered words: [${words.join(', ')}]`);

  // Step 6: Attempt to extract meaningful name
  if (words.length === 0) return null;

  // If we have known names, prioritize those
  for (const word of words) {
    if (COMMON_NAMES.has(word)) {
      console.log(`   âœ… Known name found: ${word}`);
      return word.charAt(0).toUpperCase() + word.slice(1);
    }
  }

  // If all words are valid length and alphabetic, take first 2-3 words as name
const validWords = words.filter(w => /^[a-z\u0900-\u097F]+$/i.test(w));
  
  if (validWords.length > 0) {
    // Take 1-3 words max for name
    const nameWords = validWords.slice(0, Math.min(3, validWords.length));
    const extractedName = nameWords.join(' ');
    
    // Capitalize each word
    const properName = extractedName
      .split(' ')
      .map(w => w.charAt(0).toUpperCase() + w.slice(1))
      .join(' ');
    
    console.log(`   âœ… Name extracted: ${properName}`);
    return properName;
  }

  console.log(`   âŒ Could not extract valid name`);
  return null;
}

// ======================= PINCODE EXTRACTION V3 (STRICT 6-DIGIT) =======================
export function extractPincodeV3(text) {
  if (!text || text.trim().length === 0) return null;

  console.log(`\nðŸ“® PINCODE EXTRACTION V3 START`);
  console.log(`   Input: ${text}`);

  // Remove common text noise
  let cleaned = text.toLowerCase()
    .replace(/[à¥¤,!?;:()[\]{}'"]/g, '')
    .replace(/\s+/g, ' ')
    .trim();

  console.log(`   Cleaned input: ${cleaned}`);

  // Find ALL sequences of digits
  const allDigitSequences = cleaned.match(/\d+/g) || [];
  console.log(`   All digit sequences found: [${allDigitSequences.join(', ')}]`);

  if (allDigitSequences.length === 0) {
    console.log(`   âŒ No digits found`);
    return null;
  }

  // Try to find exactly 6-digit sequences first
  for (const sequence of allDigitSequences) {
    if (sequence.length === 6) {
      // Validate: Should start with 1-9 (Indian pincode rule)
      const firstDigit = parseInt(sequence[0]);
      if (firstDigit >= 1 && firstDigit <= 9) {
        console.log(`   âœ… Valid 6-digit pincode found: ${sequence}`);
        return sequence;
      }
    }
  }

  // If no 6-digit found, try to construct from 5+1 or other combinations
  if (allDigitSequences.length > 1) {
    // Try combining first two sequences if they form 6 digits
    const combined = allDigitSequences[0] + allDigitSequences[1];
    if (combined.length === 6) {
      const firstDigit = parseInt(combined[0]);
      if (firstDigit >= 1 && firstDigit <= 9) {
        console.log(`   âœ… Valid 6-digit pincode (combined): ${combined}`);
        return combined;
      }
    }
  }

  // Last resort: extract exactly 6 consecutive digits from anywhere
  const sixDigitRegex = /\d{6}/;
  const match = cleaned.match(sixDigitRegex);
  if (match) {
    const pincode = match[0];
    const firstDigit = parseInt(pincode[0]);
    if (firstDigit >= 1 && firstDigit <= 9) {
      console.log(`   âœ… Valid 6-digit pincode (regex): ${pincode}`);
      return pincode;
    }
  }

  console.log(`   âŒ No valid 6-digit pincode found`);
  return null;
}

// ======================= ADDRESS EXTRACTION V3 (IMPROVED) =======================
export function extractAddressV3(text) {
  if (!text || text.trim().length === 0) return null;

  console.log(`\nðŸ“ ADDRESS EXTRACTION V3 START`);
  console.log(`   Input: ${text}`);

  let cleaned = text.toLowerCase()
    .replace(/[à¥¤,!?;:()[\]{}'"]/g, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  console.log(`   Cleaned: ${cleaned}`);

  // Step 1: Extract and remove pincode
  const pincodeMatch = cleaned.match(/\d{6}/);
  let addressWithoutPincode = cleaned;
  if (pincodeMatch) {
    console.log(`   Found pincode: ${pincodeMatch[0]}`);
    addressWithoutPincode = cleaned.replace(pincodeMatch[0], ' ').trim();
  }

  // Step 2: Remove other numbers/special sequences
  let address = addressWithoutPincode
    .replace(/\d{3,}/g, '') // Remove sequences of 3+ digits
    .replace(/\d+/g, '') // Remove remaining numbers
    .trim();

  console.log(`   After removing pincode and numbers: ${address}`);

  // Step 3: Remove noise words
  let words = address.split(/\s+/);
  
  const addressNoiseWords = ['mein', 'main', 'me', 'à¤®à¥‡à¤‚', 'à¤ªà¤°', 'at', 'the', 'a', 'an'];
  words = words.filter(w => {
    return !addressNoiseWords.includes(w.toLowerCase()) && w.length > 1;
  });

  address = words.join(' ').trim();
  console.log(`   After removing noise words: ${address}`);

  // Step 4: Validate minimum length and word count
  if (address.length < 3) {
    console.log(`   âŒ Address too short`);
    return null;
  }

  if (address.split(/\s+/).length < 1) {
    console.log(`   âŒ Address has no meaningful words`);
    return null;
  }

  console.log(`   âœ… Address extracted: ${address}`);
  return address;
}

// ======================= TIME EXTRACTION V3 (IMPROVED AM/PM) =======================
export function extractTimeV3(text) {
  if (!text || text.trim().length === 0) return null;

  console.log(`\nâ° TIME EXTRACTION V3 START`);
  console.log(`   Input: ${text}`);

  const lowerText = text.toLowerCase();

  // Step 1: Detect AM/PM from context
  let isAM = false;
  let isPM = false;
  let isMorning = false;
  let isAfternoon = false;
  let isEvening = false;
  let isNight = false;

  // Hindi morning indicators (4 AM - 11 AM)
  if (/\b(à¤¸à¥à¤¬à¤¹|subah|morning|à¤¸à¥à¤¬à¤¹|à¤¤à¤¡à¤¼à¤•à¤¾|à¤¤à¤¡à¤¼à¤•à¥‡|à¤°à¤¾à¤¤|à¤°à¤¾à¤¤ à¤•à¥‹|à¤†à¤§à¥€ à¤°à¤¾à¤¤)\b/i.test(lowerText)) {
    isMorning = true;
    isAM = true;
  }

  // Hindi afternoon indicators (12 PM - 5 PM)
  if (/\b(à¤¦à¥‹à¤ªà¤¹à¤°|dopahar|afternoon|à¤¦à¥‹à¤ªà¤¹à¤°|à¤¦à¥à¤ªà¤¹à¤°à¥€|à¤¦à¥à¤ªà¤¹à¤°)\b/i.test(lowerText)) {
    isAfternoon = true;
    isPM = true;
  }

  // Hindi evening indicators (5 PM - 8 PM)
  if (/\b(à¤¶à¤¾à¤®|sham|evening|à¤¸à¤‚à¤§à¥à¤¯à¤¾|à¤¸à¤¾à¤¯à¤‚à¤•à¤¾à¤²|à¤¶à¤¾à¤® à¤•à¥‹)\b/i.test(lowerText)) {
    isEvening = true;
    isPM = true;
  }

  // Hindi night indicators (8 PM - 4 AM)
  if (/\b(à¤°à¤¾à¤¤|raat|night|à¤°à¤¾à¤¤ à¤•à¥‹|à¤°à¤¾à¤¤ à¤­à¤°|à¤®à¤§à¥à¤¯ à¤°à¤¾à¤¤)\b/i.test(lowerText)) {
    isNight = true;
    isPM = true; // Typically 8 PM onwards
  }

  console.log(`   Time context: AM=${isAM}, PM=${isPM}, Morning=${isMorning}, Afternoon=${isAfternoon}, Evening=${isEvening}, Night=${isNight}`);

  // Step 2: Extract time pattern (HH:MM or single digit)
  let timeMatch = null;
  let hour = null;
  let minute = '00';

  // Pattern 1: HH:MM format
  timeMatch = lowerText.match(/(\d{1,2}):(\d{2})/);
  if (timeMatch) {
    hour = parseInt(timeMatch[1]);
    minute = timeMatch[2];
    console.log(`   Found time format HH:MM: ${hour}:${minute}`);
  }

  // Pattern 2: Single number (hour only)
  if (!timeMatch) {
    const singleNumberMatch = lowerText.match(/\b(\d{1,2})\s*(à¤¬à¤œà¥‡|baje|o'clock|oclock|à¤¬à¤œ|à¤¬à¤œà¤¼à¥‡|am|pm|a\.m|p\.m)\b/i);
    if (singleNumberMatch) {
      hour = parseInt(singleNumberMatch[1]);
      console.log(`   Found single hour: ${hour}`);
    }
  }

  // Pattern 3: Hindi number words
  if (!timeMatch && !hour) {
    const hindiTimeWords = {
      'à¤¨à¥Œ': 9, 'à¤¨O': 9, 'à¤¨': 9,
      'à¤¦à¤¸': 10, 'à¤¦à¥‰à¤¸': 10,
      'à¤—à¥à¤¯à¤¾à¤°à¤¹': 11, 'à¤—à¥à¤¯à¤¾à¤°à¤¾': 11,
      'à¤¬à¤¾à¤°à¤¹': 12, 'à¤¬à¤¾à¤°à¤¾à¤¹': 12,
      'à¤à¤•': 1, 'à¤¦à¥‹': 2, 'à¤¤à¥€à¤¨': 3, 'à¤šà¤¾à¤°': 4,
      'à¤ªà¤¾à¤à¤š': 5, 'à¤ªà¤¾à¤‚à¤š': 5, 'à¤›à¤ƒ': 6, 'à¤›à¤¹': 6,
      'à¤¸à¤¾à¤¤': 7, 'à¤†à¤ ': 8
    };

    for (const [word, num] of Object.entries(hindiTimeWords)) {
      if (lowerText.includes(word)) {
        hour = num;
        console.log(`   Found Hindi number: ${word} = ${hour}`);
        break;
      }
    }
  }

  // If hour not found, return null
  if (hour === null) {
    console.log(`   âŒ No time found`);
    return null;
  }

  // Step 3: Apply AM/PM logic
  let finalHour = hour;

  // If context suggests PM and hour is 1-9 (single digit morning hour), assume PM
  if (isPM && hour >= 1 && hour <= 9) {
    // If it's evening (5-8 PM range) and single digit
    if (isEvening && hour >= 5) {
      finalHour = hour; // 5-8 is already correct
    } else if (isEvening || isNight) {
      // Afternoon to night: add 12 if needed
      finalHour = hour < 12 ? hour + 12 : hour;
    } else if (isAfternoon) {
      // Afternoon: add 12 if 1-12
      finalHour = hour < 12 ? hour + 12 : hour;
    }
  }

  // If morning context
  if (isAM && hour >= 1 && hour <= 12) {
    finalHour = hour;
    if (hour === 12) finalHour = 0; // 12 AM = 00:00
  }

  // Convert to 12-hour format with AM/PM
  const displayHour = finalHour > 12 ? finalHour - 12 : (finalHour === 0 ? 12 : finalHour);
  const displayPeriod = finalHour >= 12 ? 'PM' : 'AM';

  const timeString = `${String(displayHour).padStart(2, '0')}:${minute} ${displayPeriod}`;
  console.log(`   âœ… Time extracted: ${timeString} (24h: ${finalHour}:${minute})`);

  return timeString;
}

// ======================= COMPLAINT DETECTION V3 (ENHANCED) =======================
export function detectComplaintV3(text) {
  if (!text || text.trim().length === 0) return null;

  console.log(`\nðŸ”§ COMPLAINT DETECTION V3 START`);
  console.log(`   Input: ${text}`);

  const textLower = text.toLowerCase();

  // Remove common filler words that might confuse detection
  const fillerWords = [
    'à¤®à¥‡à¤°à¥€', 'à¤®à¥‡à¤°à¤¾', 'à¤®à¥‡à¤°à¥‡', 'à¤®à¤¶à¥€à¤¨', 'à¤•à¤¾à¤®', 'à¤šà¤²', 'à¤¨à¤¹à¥€à¤‚', 'à¤¹à¥ˆ', 'à¤¹à¥‹', 'à¤¹à¥‹ à¤°à¤¹à¥€',
    'à¤•à¥€', 'à¤•à¤¾', 'à¤¸à¥‡', 'à¤®à¥‡à¤‚', 'à¤ªà¤°', 'à¤”à¤°', 'à¤­à¥€', 'à¤¤à¥‹', 'à¤²à¥‡à¤•à¤¿à¤¨'
  ];

  let cleanedForDetection = textLower;
  fillerWords.forEach(word => {
    const regex = new RegExp(`\\b${word}\\b`, 'g');
    cleanedForDetection = cleanedForDetection.replace(regex, ' ');
  });

  cleanedForDetection = cleanedForDetection.replace(/\s+/g, ' ').trim();
  console.log(`   After removing fillers: ${cleanedForDetection}`);

  // If text is too short after cleaning, use original
  const processText = cleanedForDetection.length > 2 ? cleanedForDetection : textLower;

  // Check if this is actually describing a working machine with problem
  const isRunningButProblematic = /\b(à¤šà¤²|à¤•à¤¾à¤®|à¤šà¤² à¤°à¤¹|à¤•à¤¾à¤® à¤•à¤°|running|working)\b/i.test(textLower) &&
                                  /\b(à¤²à¥‡à¤•à¤¿à¤¨|à¤ªà¤°|à¤²à¥‡à¤•à¤¿à¤¨|but|issue|problem|à¤¦à¤¿à¤•à¥à¤•à¤¤|à¤¸à¤®à¤¸à¥à¤¯à¤¾)\b/i.test(textLower);

  // Specific complaint detection
  const complaints = {
    'AC': /\b(à¤à¤¸à¥€|à¤à¤¸à¥€|ac|cooler|cooling|thanda|à¤ à¤‚à¤¡)\b/i,
    'Engine': /\b(à¤‡à¤‚à¤œà¤¨|engine|motor|start|à¤¶à¥à¤°à¥‚|smoke|à¤§à¥à¤†|overheat|à¤—à¤°à¥à¤®)\b/i,
    'Brake': /\b(à¤¬à¥à¤°à¥‡à¤•|brake|stop|à¤°à¥‹à¤•|à¤°à¥à¤•)\b/i,
    'Hydraulic': /\b(à¤¹à¤¾à¤‡à¤¡à¥à¤°à¥‹|pressure|pump|oil|à¤¤à¥‡à¤²|à¤¸à¥à¤²à¥‹|slow)\b/i,
    'Electrical': /\b(à¤¬à¤¿à¤œà¤²à¥€|electrical|electric|battery|à¤¬à¥ˆà¤Ÿà¤°à¥€|light|à¤²à¤¾à¤‡à¤Ÿ)\b/i,
    'Transmission': /\b(transmission|gear|à¤—à¤¿à¤¯à¤°|axle|clutch|à¤•à¥à¤²à¤š)\b/i,
    'Tyre': /\b(à¤Ÿà¤¾à¤¯à¤°|tyre|tire|puncture|à¤ªà¤‚à¤•à¥à¤šà¤°|wheel|à¤ªà¤¹à¤¿à¤¯à¤¾)\b/i,
    'Cabin': /\b(à¤•à¥‡à¤¬à¤¿à¤¨|cabin|cab|door|à¤¦à¤°à¤µà¤¾à¤œà¤¾|glass|à¤¶à¥€à¤¶à¤¾|seat|à¤¸à¥€à¤Ÿ)\b/i,
    'Fabrication': /\b(crack|à¤•à¥à¤°à¥ˆà¤•|boom|bucket|chassis|à¤Ÿà¥‚à¤Ÿà¤¾|à¤«à¤Ÿà¤¾)\b/i
  };

  console.log(`   Checking complaints...`);
  for (const [complaint, regex] of Object.entries(complaints)) {
    if (regex.test(processText)) {
      console.log(`   âœ… Detected: ${complaint}`);
      return {
        complaint,
        isRunningButProblematic,
        confidence: 0.9
      };
    }
  }

  console.log(`   âš ï¸ No specific complaint detected`);
  return null;
}

// ======================= VALIDATION FUNCTIONS =======================

export function isValidNameV3(name) {
  if (!name || name.trim().length < 2) return false;
  // Name should have at least 2 characters and not be all numbers
  return !/^\d+$/.test(name) && name.length >= 2 && name.length <= 100;
}

export function isValidPincodeV3(pincode) {
  // Must be exactly 6 digits, starting with 1-9
  if (!pincode) return false;
  return /^[1-9]\d{5}$/.test(pincode.toString());
}

export function isValidAddressV3(address) {
  if (!address) return false;
  // At least 3 characters and contains meaningful words
  return address.trim().length >= 3;
}

export function isValidTimeV3(time) {
  if (!time) return false;
  // Format: HH:MM AM/PM
  return /^\d{2}:\d{2}\s(AM|PM)$/.test(time);
}

// ======================= LEGACY WRAPPER FUNCTIONS =======================
// These maintain backward compatibility with existing code

export function extractNameV2(text) {
  return extractNameV3(text);
}

export function extractPincodeV2(text) {
  return extractPincodeV3(text);
}

export function extractLocationAddressV2(text) {
  return extractAddressV3(text);
}

export function extractTimeV2(text) {
  return extractTimeV3(text);
}

export function isValidName(name) {
  return isValidNameV3(name);
}

export function isValidPincode(pincode) {
  return isValidPincodeV3(pincode);
}

export function isValidAddress(address) {
  return isValidAddressV3(address);
}

// ======================= PHONE & CHASSIS (KEEPING EXISTING) =======================

export function extractPhoneNumberV2(text) {
  if (!text) return null;

  console.log(`\nðŸ“± PHONE EXTRACTION START`);
  console.log(`   Input: ${text}`);

  const cleaned = text.toLowerCase()
    .replace(/[a-z]/g, '') // Remove all letters
    .replace(/[^0-9\s]/g, '') // Keep only digits and spaces
    .replace(/\s+/g, ''); // Remove all spaces

  console.log(`   Digits only: ${cleaned}`);

  // Extract all digit sequences
  const digitSequences = cleaned.match(/\d+/g) || [];
  console.log(`   Digit sequences: [${digitSequences.join(', ')}]`);

  // Try to find or construct a 10-digit number
  if (digitSequences.length === 1 && digitSequences[0].length === 10) {
    const phone = digitSequences[0];
    if (/^[6-9]/.test(phone)) {
      console.log(`   âœ… Valid phone (10 digits): ${phone}`);
      return phone;
    }
  }

  // Try combining sequences
  if (digitSequences.length > 1) {
    const combined = digitSequences.slice(0, 2).join('');
    if (combined.length === 10 && /^[6-9]/.test(combined)) {
      console.log(`   âœ… Valid phone (combined): ${combined}`);
      return combined;
    }
  }

  // Extract exactly 10 consecutive digits
  const tenDigits = cleaned.match(/[6-9]\d{9}/);
  if (tenDigits) {
    console.log(`   âœ… Valid phone (regex): ${tenDigits[0]}`);
    return tenDigits[0];
  }

  console.log(`   âŒ No valid phone found`);
  return null;
}

export function isValidPhone(phone) {
  if (!phone) return false;
  // 10 digits, starting with 6-9
  return /^[6-9]\d{9}$/.test(phone.toString());
}

export function extractChassisNumberV2(text) {
  if (!text) return null;

  console.log(`\nðŸ”§ CHASSIS EXTRACTION START`);
  console.log(`   Input: ${text}`);

  // Remove noise words
  let cleaned = text.toLowerCase()
    .replace(/[à¥¤,!?;:'"-]/g, ' ') // Remove punctuation
    .replace(/\b(à¤®à¥‡à¤°à¥€|à¤®à¥‡à¤°à¤¾|à¤®à¥‡à¤°à¥‡|à¤®à¤¶à¥€à¤¨|à¤¨à¤‚à¤¬à¤°|à¤¸à¤‚à¤–à¥à¤¯à¤¾|à¤¹à¥ˆ|à¤¹à¥ˆà¤‚|à¤•à¤¾|à¤•à¥€|à¤šà¥‡à¤¸à¤¿à¤¸|chassis|number|no)\b/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  console.log(`   After removing noise: ${cleaned}`);

  // Extract longest digit sequence (usually chassis)
  const digitSequences = cleaned.match(/\d+/g) || [];
  console.log(`   Digit sequences: [${digitSequences.join(', ')}]`);

  if (digitSequences.length === 0) return null;

  // Find longest sequence
  let chassis = digitSequences.reduce((a, b) => a.length >= b.length ? a : b);
  
  // Chassis should be 6-12 digits typically
  if (chassis.length >= 6 && chassis.length <= 12) {
    console.log(`   âœ… Chassis extracted: ${chassis}`);
    return chassis;
  }

  console.log(`   âŒ No valid chassis found`);
  return null;
}

export function isValidChassis(chassis) {
  if (!chassis) return false;
  // Should be 6-12 digit sequence
  return /^\d{6,12}$/.test(chassis.toString());
}